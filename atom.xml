<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>碧漾的自我</title>
  
  <subtitle>beyond myself</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rivers-shall.github.io/"/>
  <updated>2020-06-15T10:03:05.843Z</updated>
  <id>https://rivers-shall.github.io/</id>
  
  <author>
    <name>碧漾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法复习-02-链表</title>
    <link href="https://rivers-shall.github.io/2020/06/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0-02-%E9%93%BE%E8%A1%A8/"/>
    <id>https://rivers-shall.github.io/2020/06/15/数据结构与算法复习-02-链表/</id>
    <published>2020-06-15T08:50:16.000Z</published>
    <updated>2020-06-15T10:03:05.843Z</updated>
    
    <content type="html"><![CDATA[<p>本文是数据结构与算法复习的第二篇博文，复习</p><ul><li>链表的概念</li><li>常见的链表类型和设计取舍</li><li>链表的反转操作</li></ul><a id="more"></a><h2 id="链表的概念"><a href="#链表的概念" class="headerlink" title="链表的概念"></a>链表的概念</h2><p>链表可以定义为:</p><ul><li>空</li><li>拥有一个节点，该节点有两个属性<ul><li>val，本节点的值</li><li>next，另一个链表</li></ul></li></ul><p>首先，这个定义是单链表的定义，但是双向链表也是类似的</p><p>其次，从这个定义可以看到，链表是可以递归定义的</p><h2 id="常见的链表类型和设计取舍"><a href="#常见的链表类型和设计取舍" class="headerlink" title="常见的链表类型和设计取舍"></a>常见的链表类型和设计取舍</h2><p>比较常见的链表类型有</p><ul><li>单链表</li><li>双向链表</li></ul><p>所谓的设计取舍主要是考虑:</p><ul><li>选择单链表还是双向链表？</li><li>是否需要卫士节点(sentinel node)?</li></ul><h3 id="单链表与双向链表"><a href="#单链表与双向链表" class="headerlink" title="单链表与双向链表"></a>单链表与双向链表</h3><p>双向链表与单链表的区别就在于</p><ul><li>单链表每个节点只有一个next指向额外的链表(也就是后继元素)</li><li>双链表每个节点有两个属性指向额外的链表(也就是前驱和后继)</li></ul><p>所以双向链表的使用更加灵活</p><h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><p>对于单链表和双链表的选择，主要是考虑两点:</p><ul><li>空间，双链表由于多了一个属性，消耗空间更多</li><li>时间，这里是指<ul><li>如果有访问前驱节点的需求，可以考虑<ul><li>双链表</li><li>如果需要访问的前驱结点是固定的，比如固定是前一个节点或者前两个节点<ul><li>就可以直接使用额外的一个节点指针进行存储</li></ul></li></ul></li></ul></li></ul><h3 id="是否需要卫士节点"><a href="#是否需要卫士节点" class="headerlink" title="是否需要卫士节点"></a>是否需要卫士节点</h3><p>卫士节点就是指</p><blockquote><p>对于任意的链表，都向其中添加一个无用的节点，使得链表不会是0节点的链表</p></blockquote><p>是否需要卫士节点主要是看个人的使用习惯</p><ul><li>使用卫士节点可以在一定程度上规避空指针的问题<ul><li>毕竟链表中一定会有节点</li></ul></li><li>但是会多出一个节点的空间消耗，且编程逻辑和无卫士节点的编程逻辑不同(<del>废话，当然不同</del>)</li></ul><h2 id="链表的翻转操作"><a href="#链表的翻转操作" class="headerlink" title="链表的翻转操作"></a>链表的翻转操作</h2><p>链表考的最多的就是翻转(淡然还有单链表的快排，不过那个可以留到排序的时候再说)</p><p>链表的翻转有两种实现:</p><ul><li>循环实现</li><li>递归实现</li></ul><p>其实就是逻辑烦了点，实在不行代码背下来</p><h3 id="循环实现链表翻转"><a href="#循环实现链表翻转" class="headerlink" title="循环实现链表翻转"></a>循环实现链表翻转</h3><p>如下代码的关键在于循环的不变式</p><blockquote><p>每次循环开始前,<code>head</code>指向的是还未反转的链表头，<code>prev</code>指向的是已经反转的链表头</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>, next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归实现链表翻转"><a href="#递归实现链表翻转" class="headerlink" title="递归实现链表翻转"></a>递归实现链表翻转</h3><p>以下代码的关键在于函数声明</p><blockquote><p><code>reverseList(headA, headB)</code>会将<code>headA</code>的链表反转，然后将<code>headB</code>的链表拼接到反转的<code>headA</code>链表后</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reverseList(head, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode next = headA.next;</span><br><span class="line">        headA.next = headB;</span><br><span class="line">        <span class="keyword">return</span> reverseList(next, headA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是数据结构与算法复习的第二篇博文，复习&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表的概念&lt;/li&gt;
&lt;li&gt;常见的链表类型和设计取舍&lt;/li&gt;
&lt;li&gt;链表的反转操作&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
      <category term="数据结构与算法复习" scheme="https://rivers-shall.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="data structure" scheme="https://rivers-shall.github.io/tags/data-structure/"/>
    
      <category term="union-find" scheme="https://rivers-shall.github.io/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法复习(01)-并查集</title>
    <link href="https://rivers-shall.github.io/2020/06/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0-01-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://rivers-shall.github.io/2020/06/12/数据结构与算法复习-01-并查集/</id>
    <published>2020-06-12T13:42:58.000Z</published>
    <updated>2020-06-15T08:49:43.583Z</updated>
    
    <content type="html"><![CDATA[<p>本文是数据结构预算法复习系列的第一篇博文，会介绍写作该系列博文的原因</p><p>本文复习了并查集的概念，基础的API，良好的实现(路径压缩与权重)，简单的应用和变式</p><p><a href="https://github.com/Rivers-Shall/DS-Algo-Review/tree/master/Union-Find" target="_blank" rel="noopener">相关代码</a></p><a id="more"></a><h2 id="写作本篇博文的原因"><a href="#写作本篇博文的原因" class="headerlink" title="写作本篇博文的原因"></a>写作本篇博文的原因</h2><ol><li>生活所迫<ol><li>懂的都懂，IT行业从业者(或者是考研保研)，跑不了的</li></ol></li><li>数据结构与算法是大学生活里花费的时间很多的部分，复习一下，也算是对自己的大学生涯有个交代</li><li>三次元的生活真的无聊，找点代码写，嘿嘿(<del>难道不能写工程项目吗？质问！</del>)</li></ol><h2 id="并查集的概念与基础API"><a href="#并查集的概念与基础API" class="headerlink" title="并查集的概念与基础API"></a>并查集的概念与基础API</h2><h3 id="并查集的概念"><a href="#并查集的概念" class="headerlink" title="并查集的概念"></a>并查集的概念</h3><p>假设拥有N个元素1…N，我们需要对其做两种基础的操作:</p><ol><li>宣告某两个元素a, b处在同一个等价类里</li><li>判断某两个元素a, b是否在一个等价类里</li></ol><p>用于处理这种问题，提供这两种操作接口的数据结构，可以被称为并查集</p><h3 id="并查集基础的API"><a href="#并查集基础的API" class="headerlink" title="并查集基础的API"></a>并查集基础的API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="良好的实现"><a href="#良好的实现" class="headerlink" title="良好的实现"></a>良好的实现</h3><p>良好的实现往往将一个等价类以<strong>树</strong>的形式进行组织，使用一个数组<code>int[] parent</code>，<code>parent[i]</code>记录了元素<code>i</code>的父亲节点</p><p>如下图</p><p><img src="union-find-tree.png" alt="union find tree"></p><ul><li><code>isConnected(a, b)</code>接口即判断<code>a</code>和<code>b</code>是否在同一棵树内(是否有同样的根)</li><li><code>union(a, b)</code>接口即需要将<code>a</code>所属的树归并到<code>b</code>所属的树下，或者将<code>b</code>所属的树归并到<code>a</code>所属的树下</li><li>提高执行速度，就是想办法降低树的高度</li></ul><h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>路径压缩基本上能够完全解决并查集的接口执行速度问题</p><p>其基本思想是:</p><blockquote><p>在沿着某条路径查询到<code>a</code>元素的根之后，将这条路径上所有的元素父亲，都直接设为根节点<br>这样，在以后查询的时候，查找到这条路径上的元素，只需要一次向上查询，就可以找到根节点了</p></blockquote><h5 id="路径压缩实现"><a href="#路径压缩实现" class="headerlink" title="路径压缩实现"></a>路径压缩实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathCompressUnionFindImpl</span> <span class="keyword">implements</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathCompressUnionFindImpl</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.length; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[a] == a) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[a] = find(parent[a]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = find(a), rootB = find(b);</span><br><span class="line">        parent[rootA] = rootB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(a) == find(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加权并查集"><a href="#加权并查集" class="headerlink" title="加权并查集"></a>加权并查集</h4><p>虽然路径压缩基本能够解决并查集的执行速度问题，但是还有一个解决方案值得我们思考</p><p>加权并查集，其实是基于这样的观察:</p><blockquote><p>在代表一个等价类的树的高度快速增长时，往往是由于将高的树合并成为了矮的树的子树<br>如果每次合并，都将矮的树合并成为高的树的子树，那么树的高度增长就会减缓</p></blockquote><p>从数学的角度来看，减缓的原因是</p><blockquote><p>每次当树的高度增加1，就意味着树的节点总数至少翻倍了<br>那么一共有N个节点，树的高度最多也就是lg N</p></blockquote><h5 id="加权并查集实现"><a href="#加权并查集实现" class="headerlink" title="加权并查集实现"></a>加权并查集实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedUnionFindImpl</span> <span class="keyword">implements</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent, size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[a] != a) &#123;</span><br><span class="line">            a = parent[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeightedUnionFindImpl</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = find(a), rootB = find(b);</span><br><span class="line">        <span class="keyword">if</span> (size[rootA] &gt; size[rootB]) &#123;</span><br><span class="line">            parent[rootB] = rootA;</span><br><span class="line">            size[rootA] += size[rootB];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootA] = rootB;</span><br><span class="line">            size[rootB] += size[rootA];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(a) == find(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集的简单应用"><a href="#并查集的简单应用" class="headerlink" title="并查集的简单应用"></a>并查集的简单应用</h3><p>贴两道OJ题目，都是简单练手的</p><p><a href="https://www.luogu.com.cn/problem/P3367" target="_blank" rel="noopener">洛谷P3367 模板题</a><br><a href="https://www.luogu.com.cn/problem/UVA10583" target="_blank" rel="noopener">洛谷UVA10583 简单变式</a></p><h3 id="并查集的简单变式"><a href="#并查集的简单变式" class="headerlink" title="并查集的简单变式"></a>并查集的简单变式</h3><h4 id="等价类的个数"><a href="#等价类的个数" class="headerlink" title="等价类的个数"></a>等价类的个数</h4><p>也就是树的根节点的个数，一个节点<code>a</code>是根节点当且仅当<code>parent[a] == a</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nClass = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[i] == i) &#123;</span><br><span class="line">            nClass++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可以维护的等价类性质"><a href="#可以维护的等价类性质" class="headerlink" title="可以维护的等价类性质"></a>可以维护的等价类性质</h4><p>比如:</p><ul><li>给定元素<code>a</code>，求<code>a</code>所在等价类的元素个数</li><li>给定元素<code>a</code>，求<code>a</code>所在等价类的最大值</li><li>给定元素<code>a</code>，求<code>a</code>所在等价类的最小值</li></ul><p>这类性质只需要新开一个数组，并在<code>union</code>时进行维护就可以了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    parent[rootA] = rootB;</span><br><span class="line">    size[rootB] += size[rootA];</span><br><span class="line">    maximum[rootB] = Math.max(maximum[rootA], maximum[rootB]);</span><br><span class="line">    minimum[rootB] = Math.max(minimum[rootA], minimum[rootB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是数据结构预算法复习系列的第一篇博文，会介绍写作该系列博文的原因&lt;/p&gt;
&lt;p&gt;本文复习了并查集的概念，基础的API，良好的实现(路径压缩与权重)，简单的应用和变式&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Rivers-Shall/DS-Algo-Review/tree/master/Union-Find&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;相关代码&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
      <category term="数据结构与算法复习" scheme="https://rivers-shall.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="data structure" scheme="https://rivers-shall.github.io/tags/data-structure/"/>
    
      <category term="union-find" scheme="https://rivers-shall.github.io/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>webpack教程01-webpack是什么与webpack命令行使用</title>
    <link href="https://rivers-shall.github.io/2020/06/11/webpack%E6%95%99%E7%A8%8B01-webpack%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%8Ewebpack%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://rivers-shall.github.io/2020/06/11/webpack教程01-webpack是什么与webpack命令行使用/</id>
    <published>2020-06-11T07:20:01.000Z</published>
    <updated>2020-06-11T10:45:28.751Z</updated>
    
    <content type="html"><![CDATA[<p>本文是webpack教程的第一篇文章，会介绍</p><ul><li>创作这个系列教程的原因</li><li>webpack是什么<ul><li>构建工具</li></ul></li><li>webpack CLI(命令行交互)的基本使用<ul><li><code>webpack &lt;入口文件&gt; -o &lt;目标文件&gt; --mode &lt;模式&gt;</code></li><li><code>webpack --config &lt;配置文件&gt;</code></li></ul></li><li>webpack CLI与npm结合使用<ul><li><code>scripts</code>添加与<code>npm run build</code></li></ul></li></ul><p>涉及到的代码有<a href="https://github.com/Rivers-Shall/webpack-demo/tree/45285d4873a2b62c4e5808d158aa6dfe9b71bf14" target="_blank" rel="noopener">不使用webpack版本</a>，<a href="https://github.com/Rivers-Shall/webpack-demo/tree/44a3c5436a1b85916a23a37d6903865df2437026" target="_blank" rel="noopener">使用webpack和npm版本</a><br><a id="more"></a></p><h2 id="创作这个系列教程的原因"><a href="#创作这个系列教程的原因" class="headerlink" title="创作这个系列教程的原因"></a>创作这个系列教程的原因</h2><ul><li>webpack是一个应用广泛的构建系统<ul><li>尽管现在各个框架，各个公司都有发展使用自己的构建系统(脚手架)的趋势，比如vue-cli</li><li>但是webpack仍然具有着很高的适用性和可扩展性</li><li>其接口和使用方式的设计也很值得学习</li></ul></li><li>把三次元的时间尽！数！挥！霍！</li></ul><h2 id="webpack是什么"><a href="#webpack是什么" class="headerlink" title="webpack是什么"></a>webpack是什么</h2><p>前面提到，webpack是一个构建系统，这究竟意味着什么呢？我们先来看webpack官网上的图</p><p><img src="webpack.png" alt="webpack"></p><p>我们可以看到:</p><ul><li>左边是<strong>杂乱的，拥有复杂依赖的</strong>项目文件</li><li>右边是<strong>整齐的，无依赖的，生成的</strong>独立文件</li></ul><p>所以webpack是构建系统的含义:</p><blockquote><p>根据项目文件中提供的依赖关系，自动构建整齐的独立文件</p></blockquote><h2 id="webpack-CLI-命令行交互-的基本使用"><a href="#webpack-CLI-命令行交互-的基本使用" class="headerlink" title="webpack CLI(命令行交互)的基本使用"></a>webpack CLI(命令行交互)的基本使用</h2><p>先贴一下<a href="https://webpack.js.org/api/cli/" target="_blank" rel="noopener">webpack CLI的官网文档</a></p><h3 id="一个不使用webpack的项目版本"><a href="#一个不使用webpack的项目版本" class="headerlink" title="一个不使用webpack的项目版本"></a>一个不使用webpack的项目版本</h3><p>为了体现使用webpack的优势，我们先准备一个不使用webpack的项目版本 <a href="https://github.com/Rivers-Shall/webpack-demo/tree/45285d4873a2b62c4e5808d158aa6dfe9b71bf14" target="_blank" rel="noopener">webpack-demo init commit</a></p><p>这个项目实现的功能是: 点击按钮，下方的文字会出现或者消失</p><p>我们可以看到，<code>index.html</code>中引用了两个js文件:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/dom-loader.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两个引用的顺序是不可改变的，如果改变，那么按钮就会失效</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>这样搭建的web项目，需要我们手动去关注引用的代码顺序，<ul><li>demo项目中只有两个js文件，但是如果真实的项目中，或许会有数十个js文件，那时还要不断处理引用顺序，就会很头疼</li></ul></li><li>js代码的修改，可能需要额外修改html代码<ul><li>如果引用顺序改变，就必须修改引用js代码的html代码，修改的地方变多</li></ul></li></ul><p>缺点其实还有很多，比如后期引入Sass这种扩展CSS，或者Babel这种JS转译器，都需要手动引入和管理，非常麻烦，webpack会帮我们完成这些管理，当然，这些内容稍后再介绍，先看最基础的使用</p><h3 id="使用webpack-CLI构建文件"><a href="#使用webpack-CLI构建文件" class="headerlink" title="使用webpack CLI构建文件"></a>使用webpack CLI构建文件</h3><p>我们首先使用如下命令安装webpack和webpack-cli(当然，项目需要使用<code>npm init</code>初始化，需要安装<code>node.js</code>和<code>npm</code>):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --save-dev</span><br></pre></td></tr></table></figure><p>在使用webpack之前，我们需要明白，webpack是<strong>根据源代码中的依赖关系</strong>进行构建的</p><p>那么，我们就必须在源代码中对依赖关系进行声明</p><p>声明的方式是ES6的<code>import, export</code>语法</p><blockquote><p>注意: 这里使用ES6的<code>import, export</code>语法只是因为webpack可以识别它们，在项目中使用其他的ES6语法仍然会导致兼容性问题，关于如何将ES6或更新的语法转化为ES5语法，后续教程会涉及</p></blockquote><p>所以我们对源代码作出修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dom-loader.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">"#toggle-button"</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> graph = <span class="built_in">document</span>.querySelector(<span class="string">"#toggled-graph"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;button, graph&#125; <span class="keyword">from</span> <span class="string">"./dom-loader"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>声明了依赖关系之后，就需要使用webpack构建文件了，为了构建，我们需要指定两类文件以及模式</p><ol><li>入口文件<ol><li>webpack会从这个文件开始分析依赖关系，将所有涉及的文件进行打包</li></ol></li><li>目标文件<ol><li>webpack会将构建出的文件保存到目标文件上</li></ol></li><li>构建模式<ol><li>不提供的话默认是<code>production</code>，但是会报Warning</li><li>开发阶段使用<code>development</code>就好</li><li>二者的一个主要区别是<code>production</code>会<em>最小化</em>文件，导致整个文件没有多余的空白符，可读性为0</li></ol></li></ol><p>而后使用webpack CLI</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; webpack &lt;入口文件&gt; -o &lt;目标文件&gt; --mode &lt;模式&gt;</span><br></pre></td></tr></table></figure><p>在这里，就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack ./js/app.js -o bundle.js --mode development</span><br></pre></td></tr></table></figure><p>webpack就会直接生成<code>bundle.js</code></p><p>而在<code>index.html</code>中，我们只需要引入这一个<code>bundle.js</code>就可以了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;script src="js/dom-loader.js"&gt;&lt;/script&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;script src="js/app.js"&gt;&lt;/script&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="webpack与配置文件"><a href="#webpack与配置文件" class="headerlink" title="webpack与配置文件"></a>webpack与配置文件</h3><p>webpack CLI可以使用命令行参数的方式运作，也可以使用配置文件的方式运作</p><p>不过配置文件的书写方式涉及到webpack许多核心概念，下次再说，这里先放上指定配置文件的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; webpack --config &lt;配置文件&gt;</span><br></pre></td></tr></table></figure><h2 id="webpack-CLI与npm结合使用"><a href="#webpack-CLI与npm结合使用" class="headerlink" title="webpack CLI与npm结合使用"></a>webpack CLI与npm结合使用</h2><p>使用webpack原生命令比较繁琐，也没有办法记录在项目文件中，可以使用npm的scripts列表进行管理</p><p>在<code>package.json</code>中添加scripts</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"demo for webpack"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"app.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    # 添加 script</span><br><span class="line">    "build": "webpack ./js/app.js -o bundle.js --mode development"</span><br><span class="line">  &#125;,</span><br><span class="line">  "author": "rivers-shall",</span><br><span class="line">  "license": "ISC",</span><br><span class="line">  "devDependencies": &#123;</span><br><span class="line">    "webpack": "^4.43.0",</span><br><span class="line">    "webpack-cli": "^3.3.11"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后我们只需要:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm run build</span><br></pre></td></tr></table></figure><p>就可以便捷使用webpack构建文件了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是webpack教程的第一篇文章，会介绍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创作这个系列教程的原因&lt;/li&gt;
&lt;li&gt;webpack是什么&lt;ul&gt;
&lt;li&gt;构建工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;webpack CLI(命令行交互)的基本使用&lt;ul&gt;
&lt;li&gt;&lt;code&gt;webpack &amp;lt;入口文件&amp;gt; -o &amp;lt;目标文件&amp;gt; --mode &amp;lt;模式&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;webpack --config &amp;lt;配置文件&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;webpack CLI与npm结合使用&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scripts&lt;/code&gt;添加与&lt;code&gt;npm run build&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;涉及到的代码有&lt;a href=&quot;https://github.com/Rivers-Shall/webpack-demo/tree/45285d4873a2b62c4e5808d158aa6dfe9b71bf14&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不使用webpack版本&lt;/a&gt;，&lt;a href=&quot;https://github.com/Rivers-Shall/webpack-demo/tree/44a3c5436a1b85916a23a37d6903865df2437026&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用webpack和npm版本&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
      <category term="webpack教程" scheme="https://rivers-shall.github.io/categories/webpack%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="webpack" scheme="https://rivers-shall.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>star-history源码阅读笔记(01)-项目介绍,Github的stargazers接口与分页机制，获取star历史的思路</title>
    <link href="https://rivers-shall.github.io/2020/06/09/star-history%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-01-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D-Github%E7%9A%84stargazers%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/"/>
    <id>https://rivers-shall.github.io/2020/06/09/star-history源码阅读笔记-01-项目介绍-Github的stargazers接口与分页机制/</id>
    <published>2020-06-09T08:20:00.000Z</published>
    <updated>2020-06-11T02:35:03.274Z</updated>
    
    <content type="html"><![CDATA[<p>本文是<a href="https://github.com/timqian/star-history" target="_blank" rel="noopener">star-history项目</a>源码阅读的第一篇文章，会包含:</p><ul><li>作者对项目的介绍，这个系列博文的目的</li><li>Github的stargazers接口</li><li>Github接口的分页策略</li><li>获取star历史的思路</li></ul><p>本次对代码的分析基于Commit - <a href="https://github.com/timqian/star-history/tree/deecd92097809f39cd0ccd521b85ad54ac8fad24" target="_blank" rel="noopener">first commit deecd92 timqian</a></p><a id="more"></a><h2 id="项目的介绍与系列博文的目的"><a href="#项目的介绍与系列博文的目的" class="headerlink" title="项目的介绍与系列博文的目的"></a>项目的介绍与系列博文的目的</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>首先说明，本文作者并非项目作者，各种介绍和分析，如有不当，还请谅解。</p><p><a href="https://github.com/timqian/star-history" target="_blank" rel="noopener">star-history项目</a>(<a href="https://star-history.t9t.io/" target="_blank" rel="noopener">体验地址</a>)是一个用于统计github项目获得star历史的组件，包括web app网页版本和chrome extension版本</p><p>产生这个项目的原因，是Github官方并没有提供查看项目star历史的功能</p><h3 id="博文目的"><a href="#博文目的" class="headerlink" title="博文目的"></a>博文目的</h3><ul><li>留作知识沉淀<ul><li>从体验界面来看，前端效果和功能都很不错，希望学习一下</li></ul></li><li>将我三次元的时间，尽！情！挥！霍！</li></ul><h2 id="Github的stargazers接口"><a href="#Github的stargazers接口" class="headerlink" title="Github的stargazers接口"></a>Github的stargazers接口</h2><p>Github官方提供了一系列REST API(现在有向graphql上迁移的趋势)，通过REST API，可以获得许多Github上的信息，以此为基础，我们可以构建各式各样的APP，star-history这个项目也是这样建立起来的</p><p>Github虽然没有提供直接查看项目star历史的功能，但是却提供了<a href="https://developer.github.com/v3/activity/starring/" target="_blank" rel="noopener">stargazers接口</a>，这个接口有两种形式</p><ol><li>查看star了一个项目的所有用户</li><li>同上，并且加入该用户star该项目的时间</li></ol><p>这二者共用同一个rest url，不同的是：</p><blockquote><p>方法2需要在HTTP请求头中加入<code>Accept: application/vnd.github.v3.star+json</code></p></blockquote><p>其rest url和返回的json格式分别是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">GET /repos/:owner/:repo/stargazers</span><br><span class="line"># 没有时间</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"login"</span>: <span class="string">"octocat"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"node_id"</span>: <span class="string">"MDQ6VXNlcjE="</span>,</span><br><span class="line">    <span class="attr">"avatar_url"</span>: <span class="string">"https://github.com/images/error/octocat_happy.gif"</span>,</span><br><span class="line">    <span class="attr">"gravatar_id"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://api.github.com/users/octocat"</span>,</span><br><span class="line">    <span class="attr">"html_url"</span>: <span class="string">"https://github.com/octocat"</span>,</span><br><span class="line">    <span class="attr">"followers_url"</span>: <span class="string">"https://api.github.com/users/octocat/followers"</span>,</span><br><span class="line">    <span class="attr">"following_url"</span>: <span class="string">"https://api.github.com/users/octocat/following&#123;/other_user&#125;"</span>,</span><br><span class="line">    <span class="attr">"gists_url"</span>: <span class="string">"https://api.github.com/users/octocat/gists&#123;/gist_id&#125;"</span>,</span><br><span class="line">    <span class="attr">"starred_url"</span>: <span class="string">"https://api.github.com/users/octocat/starred&#123;/owner&#125;&#123;/repo&#125;"</span>,</span><br><span class="line">    <span class="attr">"subscriptions_url"</span>: <span class="string">"https://api.github.com/users/octocat/subscriptions"</span>,</span><br><span class="line">    <span class="attr">"organizations_url"</span>: <span class="string">"https://api.github.com/users/octocat/orgs"</span>,</span><br><span class="line">    <span class="attr">"repos_url"</span>: <span class="string">"https://api.github.com/users/octocat/repos"</span>,</span><br><span class="line">    <span class="attr">"events_url"</span>: <span class="string">"https://api.github.com/users/octocat/events&#123;/privacy&#125;"</span>,</span><br><span class="line">    <span class="attr">"received_events_url"</span>: <span class="string">"https://api.github.com/users/octocat/received_events"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"User"</span>,</span><br><span class="line">    <span class="attr">"site_admin"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">GET /repos/:owner/:repo/stargazers</span><br><span class="line">Header:</span><br><span class="line">Accept: application/vnd.github.v3.star+json</span><br><span class="line"># 有star时间</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"starred_at"</span>: <span class="string">"2011-01-16T19:06:43Z"</span>,</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">      <span class="attr">"login"</span>: <span class="string">"octocat"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"node_id"</span>: <span class="string">"MDQ6VXNlcjE="</span>,</span><br><span class="line">      <span class="attr">"avatar_url"</span>: <span class="string">"https://github.com/images/error/octocat_happy.gif"</span>,</span><br><span class="line">      <span class="attr">"gravatar_id"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"url"</span>: <span class="string">"https://api.github.com/users/octocat"</span>,</span><br><span class="line">      <span class="attr">"html_url"</span>: <span class="string">"https://github.com/octocat"</span>,</span><br><span class="line">      <span class="attr">"followers_url"</span>: <span class="string">"https://api.github.com/users/octocat/followers"</span>,</span><br><span class="line">      <span class="attr">"following_url"</span>: <span class="string">"https://api.github.com/users/octocat/following&#123;/other_user&#125;"</span>,</span><br><span class="line">      <span class="attr">"gists_url"</span>: <span class="string">"https://api.github.com/users/octocat/gists&#123;/gist_id&#125;"</span>,</span><br><span class="line">      <span class="attr">"starred_url"</span>: <span class="string">"https://api.github.com/users/octocat/starred&#123;/owner&#125;&#123;/repo&#125;"</span>,</span><br><span class="line">      <span class="attr">"subscriptions_url"</span>: <span class="string">"https://api.github.com/users/octocat/subscriptions"</span>,</span><br><span class="line">      <span class="attr">"organizations_url"</span>: <span class="string">"https://api.github.com/users/octocat/orgs"</span>,</span><br><span class="line">      <span class="attr">"repos_url"</span>: <span class="string">"https://api.github.com/users/octocat/repos"</span>,</span><br><span class="line">      <span class="attr">"events_url"</span>: <span class="string">"https://api.github.com/users/octocat/events&#123;/privacy&#125;"</span>,</span><br><span class="line">      <span class="attr">"received_events_url"</span>: <span class="string">"https://api.github.com/users/octocat/received_events"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"User"</span>,</span><br><span class="line">      <span class="attr">"site_admin"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Github接口的分页策略"><a href="#Github接口的分页策略" class="headerlink" title="Github接口的分页策略"></a>Github接口的分页策略</h2><p>对于stargazers接口，一个仓库很可能有数万甚至数十万个用户star过，如果我们在一次请求<br><code>GET /repos/:owner/:repo/stargazers</code><br>中，就将所有的信息全部都拿出来，会导致:</p><ul><li>网络IO和内存IO负荷过大</li><li>不灵活，也许有些接口调用方并不想要全部的数据，只想要部分的，这样的请求IO就全部浪费了</li></ul><p>为此，Github的很多API都引入了分页机制</p><p>分页机制中，比较重要的有几点：</p><ul><li>如何知道一个url的资源被分成了多少页？</li><li>如何知道目前是哪一页？</li><li>如何知道一个url的资源在一页上有多少个？</li><li>如何获取一个url任意一页的资源？</li></ul><p>我们先来看看Github的REST API是如何接受和提供分页信息的</p><h3 id="接受分页信息"><a href="#接受分页信息" class="headerlink" title="接受分页信息"></a>接受分页信息</h3><p>对于每一个url，我们可以在后面加上<code>page</code>和<code>per_page</code>参数:</p><ul><li><code>per_page</code>参数指定了一页上有多少个资源<ul><li>这个参数可以没有，不同的url接口会有不同的默认值，有的是30，有的是100，具体靠阅读文档</li><li>并不是所有的url接口都接受这个参数，有些url接口不接受，具体靠阅读文档</li></ul></li><li><code>page</code>参数指定了需要拿哪一页的资源</li></ul><h3 id="提供分页信息"><a href="#提供分页信息" class="headerlink" title="提供分页信息"></a>提供分页信息</h3><p>在HTTP响应中，Github接口加入一个响应头<code>Link</code>，这个响应头的样式大概是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 注意这个请求没有加上page参数，也能获得Link响应头</span><br><span class="line">GET https://api.github.com/search/code?q=addClass+user%3Amozilla</span><br><span class="line"></span><br><span class="line"># HTTP响应的响应头</span><br><span class="line">Link: &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=15&gt;; rel=&quot;next&quot;,</span><br><span class="line">  &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=34&gt;; rel=&quot;last&quot;,</span><br><span class="line">  &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=1&gt;; rel=&quot;first&quot;,</span><br><span class="line">  &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=13&gt;; rel=&quot;prev&quot;</span><br></pre></td></tr></table></figure><p>其中<code>rel</code>表示的是url和当前url的关系:</p><ul><li><code>prev</code>，前一页的url</li><li><code>next</code>，下一页的url</li><li><code>last</code>，最后一页的url，也就是总页数</li><li><code>first</code>，第一页的url</li></ul><h3 id="疑问的解答"><a href="#疑问的解答" class="headerlink" title="疑问的解答"></a>疑问的解答</h3><p>所以我们之前的数个疑问就可以得到解答</p><ul><li>如何知道一个url的资源被分成了多少页？<ul><li>首先不带<code>page</code>参数进行请求，而后通过响应头，提取出<code>last</code>对应的url中的<code>page</code>参数即可</li></ul></li><li>如何知道目前是哪一页？<ul><li>当前url的<code>page</code>参数就是当前页数</li><li>响应头中的<code>next</code>对应的url中的<code>page</code>参数是下一页</li></ul></li><li>如何知道一个url的资源在一页上有多少个？<ul><li>查看文档，会有默认值</li><li>查看文档，如果url接口接受<code>per_page</code>参数，就可以自行设置(注意可能会有最大值限制)</li></ul></li><li>如何获取一个url任意一页的资源？<ul><li>加入<code>page</code>参数</li></ul></li></ul><h2 id="获取star历史的思路"><a href="#获取star历史的思路" class="headerlink" title="获取star历史的思路"></a>获取star历史的思路</h2><p>了解了Github的stargazers接口及分页策略，我们就可以来分析一下获取star历史的方法:</p><ol><li>调用stargazers接口，要带star日期的</li><li>根据star日期进行排序</li><li>统计出star发生改变的时间(也就是某个用户star了仓库的时间)和当时的star数目(就是排序后的索引值)</li><li>以改变的时间作为横轴，改变当时的star数目作为纵轴，绘制图像</li></ol><p>这样来看，基本上是没错的，但是还要考虑一点</p><blockquote><p>如果一个仓库有数千数万数十万star，我们就要绘制数千数万数十万的点吗？</p></blockquote><p>可以当然是可以的，但是这么做，对于高star的项目，内存和网络消耗过大，处理时间过长，项目初期，不利于我们开发和调试</p><p>所以我们可以利用分页机制进行<strong>取样</strong></p><p>比如，我们选定取样点数为20，那么，</p><ul><li>对于star数目不足20的项目，<ul><li>我们获取所有的信息，并绘制出所有的点</li></ul></li><li>对于star数目高于20的项目(假设star数为N)，<ul><li>我们获取0, N/20, 2N/20, 3N/20, …, N时的时间</li><li>然后以这二十个时间点和star数，绘制20个点即可</li></ul></li></ul><p>上面描述的是如何取样，那么<strong>取样</strong>与<strong>分页</strong>有什么关系呢？</p><p>那就是——我们不需要获取<em>总star数目</em>，我们只需要获取<em>总页数</em></p><ul><li>对于一个stargazers接口页数为N的项目<ul><li>我们获取0, N/20, 2N/20, 3N/20, …, N页上最早的时间</li><li>然后以这二十个时间点和star数(页编号 * 每页资源数目)，绘制20个点即可</li></ul></li></ul><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>事实上，项目代码中也是这么操作的(事实上刚才的思路是我从代码中倒推出来的，尬笑)</p><p><code>generateUrls.js</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getConfig = &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    Accept: <span class="string">'application/vnd.github.v3.star+json'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">repo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> initUrl = <span class="string">`https://api.github.com/repos/<span class="subst">$&#123;repo&#125;</span>/stargazers`</span>;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> axios.get(initUrl, getConfig).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表明我们使用的是stargazers的带时间的接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> link = res.headers.link;</span><br><span class="line"><span class="keyword">if</span> (!link) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> pageNumArray = <span class="regexp">/next.*?page=(\d*).*?last/</span>.exec(link);</span><br><span class="line">  <span class="keyword">const</span> pageNum = pageNumArray[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> samplePageUrls = [];</span><br><span class="line">  <span class="keyword">let</span> pageIndexes = [];</span><br><span class="line">  <span class="keyword">if</span> (pageNum &lt;= sampleNum) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= pageNum; i++) &#123;</span><br><span class="line">      pageIndexes.push(i);</span><br><span class="line">      samplePageUrls.push(initUrl + <span class="string">'?page='</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; sampleNum; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> pageIndex = <span class="built_in">Math</span>.round(i / sampleNum * pageNum);</span><br><span class="line">      pageIndexes.push(pageIndex);</span><br><span class="line">      samplePageUrls.push(initUrl + <span class="string">'?page='</span> + pageIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    samplePageUrls, pageIndexes,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这一段代码是通过响应头<code>Link</code>，使用正则表达式提取出总页数，然后取样<code>sampleNum</code>个点</p><p><code>getStarHistory.js</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">repo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    samplePageUrls, pageIndexes</span><br><span class="line">  &#125; = <span class="keyword">await</span> generateUrls(repo).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">// throw don't work</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getArray = samplePageUrls.map(<span class="function"><span class="params">url</span> =&gt;</span> axios.get(url, getConfig));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> resArray = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(getArray).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">// throw don't work</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> starHistory = pageIndexes.map(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      date: resArray[i].data[<span class="number">0</span>].starred_at.slice(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">      starNum: <span class="number">30</span> * (p - <span class="number">1</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(starHistory);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> starHistory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段代码，</p><ol><li>通过<code>generateUrls.js</code>的接口获取所有采样的url接口，而后进行请求</li><li>请求后获得每一页最小的时间，并把最小的时间和当页代表的star数组合起来返回</li></ol><p>这样，就得到了一个项目的star历史</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是&lt;a href=&quot;https://github.com/timqian/star-history&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;star-history项目&lt;/a&gt;源码阅读的第一篇文章，会包含:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作者对项目的介绍，这个系列博文的目的&lt;/li&gt;
&lt;li&gt;Github的stargazers接口&lt;/li&gt;
&lt;li&gt;Github接口的分页策略&lt;/li&gt;
&lt;li&gt;获取star历史的思路&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次对代码的分析基于Commit - &lt;a href=&quot;https://github.com/timqian/star-history/tree/deecd92097809f39cd0ccd521b85ad54ac8fad24&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;first commit deecd92 timqian&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
      <category term="star-history源码阅读笔记" scheme="https://rivers-shall.github.io/categories/star-history%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Github" scheme="https://rivers-shall.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>goland提取方法与...interface{}类型的注意点</title>
    <link href="https://rivers-shall.github.io/2020/06/08/goland%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E4%B8%8E-interface-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>https://rivers-shall.github.io/2020/06/08/goland提取方法与-interface-类型的注意点/</id>
    <published>2020-06-08T09:15:04.000Z</published>
    <updated>2020-06-08T11:50:33.943Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用goland提供的提取方法(Extract Method)功能时，由于<code>...interface{}</code>的类型问题而遭遇到的bug和一点感悟，简单来说:</p><ul><li>可变长的参数会被goland的Extract Method转化为切片(slice)，比如<code>...interface{}</code>会被转化为<code>[]interface{}</code></li><li>由于<code>interface{}</code>的特殊性，需要额外注意</li></ul><a id="more"></a><h2 id="bug的产生"><a href="#bug的产生" class="headerlink" title="bug的产生"></a>bug的产生</h2><p>在代码中有如下片段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在想要将循环提取出来，作为一个方法，在goland中可以直接选中文本然后Extract Method，但是结果是这样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ExtractedMethod(payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtractedMethod</span><span class="params">(payload []<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>期望中的函数签名是<code>ExtractedMethod(payload ...interface{})</code>，不符合预期，所以要进行修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG!!!!!!!!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ExtractedMethod(payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtractedMethod</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码不会有编译错误，但是是完全不符合预期的，为什么呢？</p><h2 id="bug的原因"><a href="#bug的原因" class="headerlink" title="bug的原因"></a>bug的原因</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG!!!!!!!!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// we need to unpack payload</span></span><br><span class="line">    ExtractedMethod(payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtractedMethod</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述注释所说，我们需要对<code>f</code>中传递给<code>ExtractedMethod</code>的参数<code>payload</code>做一个解包工作，因为</p><ul><li>我们<code>f</code>函数的本意是要用<code>ExtractedMehtod</code>对<code>payload</code>中的每一个元素做处理</li><li>现在不解包，<code>payload</code>原本一个<code>[]interface{}</code>又被<strong>额外自动包装了一层</strong>，成为了<code>interface{}</code>传递给了<code>ExtractedMethod</code>，只会对整个<code>payload</code>做一次处理</li></ul><h2 id="bug的解决与思考"><a href="#bug的解决与思考" class="headerlink" title="bug的解决与思考"></a>bug的解决与思考</h2><p>将代码修改为如下后正确</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ExtractedMethod(payload...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtractedMethod</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后可以采取的方法是，先将传参的地方<code>payload</code>改为<code>payload...</code>，这样的话如果忘记修改参数<code>[]interface{}</code>为<code>...interface{}</code>，是会有编译器报错的</p><p>这个修改顺序可以让编译器为我们保驾</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用goland提供的提取方法(Extract Method)功能时，由于&lt;code&gt;...interface{}&lt;/code&gt;的类型问题而遭遇到的bug和一点感悟，简单来说:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可变长的参数会被goland的Extract Method转化为切片(slice)，比如&lt;code&gt;...interface{}&lt;/code&gt;会被转化为&lt;code&gt;[]interface{}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;interface{}&lt;/code&gt;的特殊性，需要额外注意&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="goland" scheme="https://rivers-shall.github.io/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>常见的git工作流</title>
    <link href="https://rivers-shall.github.io/2020/06/07/%E5%B8%B8%E8%A7%81%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>https://rivers-shall.github.io/2020/06/07/常见的git工作流/</id>
    <published>2020-06-07T03:58:16.000Z</published>
    <updated>2020-06-07T05:18:53.805Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了作者了解到的三种常见的<em>单仓库</em>的git工作流，它们是:</p><ol><li>Centralized工作流<ul><li>仅使用master一个分支</li></ul></li><li>Feature Branch工作流<ul><li>使用一个master分支管理稳定版本</li><li>使用多个feature分支管理需求开发</li></ul></li><li>Gitflow工作流<ul><li>使用一个master分支管理发布版本历史</li><li>使用一个develop分支管理开发流程</li><li>使用多个feature分支管理需求开发</li><li>使用多个release分支管理版本发布</li><li>使用多个hotfix分支修复紧急bug</li></ul></li></ol><a id="more"></a><h2 id="Centralized工作流"><a href="#Centralized工作流" class="headerlink" title="Centralized工作流"></a>Centralized工作流</h2><p><img src="centralized-rebase.svg" alt="centralized"></p><p>这种工作流只使用唯一的master分支</p><h3 id="Centralized需求开发的过程"><a href="#Centralized需求开发的过程" class="headerlink" title="Centralized需求开发的过程"></a>Centralized需求开发的过程</h3><ul><li>拉取远端分支(pull/clone)</li><li>开发(add, commit)<ul><li>上图中的白色master</li></ul></li><li>再次拉取远端分支(fetch)<ul><li>上图中的紫色origin/master</li></ul></li><li>合入，处理冲突(rebase)<ul><li>上图中的蓝色master</li><li>注意这里不使用merge，merge会导致master分支出现类似新branch的分叉行为, 丢失了单分支的简洁性</li></ul></li><li>提交修改(push)</li></ul><h3 id="Centralized工作流优点"><a href="#Centralized工作流优点" class="headerlink" title="Centralized工作流优点"></a>Centralized工作流优点</h3><ul><li>简单，对于单人小项目，没有必要考虑太多管理的情况下直接使用，没有问题</li><li>和SVN的工作流非常相似，方便从SVN迁移到Git的团队做一段时间的缓冲</li></ul><h3 id="Centralized工作流缺点"><a href="#Centralized工作流缺点" class="headerlink" title="Centralized工作流缺点"></a>Centralized工作流缺点</h3><ul><li>太过简单，没有利用好Git的分支特性</li></ul><h2 id="Feature-Branch工作流"><a href="#Feature-Branch工作流" class="headerlink" title="Feature Branch工作流"></a>Feature Branch工作流</h2><p><img src="feature-branch.svg" alt="feature-branch"></p><p>对于这种工作流，开发者需要使用:</p><ul><li>一个master分支管理稳定版本</li><li>多个feature分支管理需求开发</li></ul><h3 id="Feature-Branch需求开发的过程"><a href="#Feature-Branch需求开发的过程" class="headerlink" title="Feature Branch需求开发的过程"></a>Feature Branch需求开发的过程</h3><ul><li>拉取远端分支(pull/clone)</li><li>从master新建feature分支(checkout -b feature/XXX)</li><li>开发(add, commit)</li><li>再次拉取远端分支(fetch)</li><li>合入，处理冲突(merge)<ul><li>注意这里需要的合入处理冲突是指将feature/XXX合入master，而不是将master合入feature/XXX</li><li>另外，merge的时候建议使用<code>--no-ff</code>，保证只产生一个merge commit，原因下面会讲</li></ul></li><li>提交修改(push)</li></ul><h3 id="Feature-Branch工作流优点"><a href="#Feature-Branch工作流优点" class="headerlink" title="Feature Branch工作流优点"></a>Feature Branch工作流优点</h3><p>该工作流相比于Centralized工作流，更加复杂，利用了Git分支的特性，相比之下，优点有:</p><ul><li>需求开发的管理更加清晰，有单独的分支</li><li>由于使用的是不同的分支，可以开启pull request和merge review，通过强制code review提高代码质量</li><li>需求分支合入master时，只会产生唯一的merge commit(如果merge的时候使用了<code>--no-ff</code>的话)，这样如果想要把一个feature revert掉，只需要revert唯一的一个commit，而不需要选出有关的commit一个个地revert</li></ul><h3 id="Feature-Branch工作流缺点"><a href="#Feature-Branch工作流缺点" class="headerlink" title="Feature Branch工作流缺点"></a>Feature Branch工作流缺点</h3><p>缺点/不足:</p><ul><li>没有专门用于版本发布的机制<ul><li>版本发布可能涉及到很多非开发的杂事(比如文档编写与生成，项目打包等等)，这些不适合作为feature来开发</li><li>在该工作流中，没有办法清晰看出哪些commit是发布的版本</li></ul></li><li>没有用于紧急修复bug的机制<ul><li>紧急bug修复，也不适合作为feature来开发</li></ul></li></ul><h2 id="Gitflow工作流"><a href="#Gitflow工作流" class="headerlink" title="Gitflow工作流"></a>Gitflow工作流</h2><p><img src="gitflow.svg" alt="gitflow"></p><p>这个工作流需要开发者:</p><ul><li>使用一个master分支管理发布版本历史</li><li>使用一个develop分支管理开发流程</li><li>使用多个feature分支管理需求开发</li><li>使用多个release分支管理版本发布</li><li>使用多个hotfix分支修复紧急bug</li></ul><h3 id="Gitflow需求开发流程-feature分支"><a href="#Gitflow需求开发流程-feature分支" class="headerlink" title="Gitflow需求开发流程(feature分支)"></a>Gitflow需求开发流程(feature分支)</h3><ul><li>拉取远端分支(pull/clone)</li><li>从develop分支开启新的feature分支(checkout -b feature/XXX)</li><li>开发(add, commit)</li><li>再次拉取远端分支(fetch)</li><li>合入，解决冲突(merge)</li><li>提交修改(push)</li></ul><p>这个流程和feature branch是一致的，只不过把base分支从master改为了develop</p><p>注意所有的feature分支都:</p><ul><li>从<strong>develop</strong>分支新建而来</li><li>合入到develop分支而去</li></ul><h3 id="Gitflow版本发布流程-release分支"><a href="#Gitflow版本发布流程-release分支" class="headerlink" title="Gitflow版本发布流程(release分支)"></a>Gitflow版本发布流程(release分支)</h3><ul><li>拉取远端分支(pull/clone)</li><li>从develop分支开启新的release分支(checkout -b release/XXX)</li><li>版本发布开发(add, commit)<ul><li>包括文档生成，打包等杂事</li><li>也可以修复小bug</li><li>但是大的改动必须使用需求开发流程，去新feature分支进行处理，并移动到下个版本上</li></ul></li><li>再次拉取远端分支(fetch)</li><li>合入，解决冲突(merge)<ul><li>这里，需要将release分支同时合入master和develop分支</li><li>合入master，是为了保存版本发布记录</li><li>合入develop，是为了后续开发能够兼容该版本<ul><li>比如说在release上修复了小bug，或者添加了文档注释等，都要反映到后续开发上</li></ul></li></ul></li><li>提交(push)</li></ul><p>注意所有的release分支都:</p><ul><li>从<strong>develop</strong>分支新建而来</li><li>合入到master和develop分支而去</li></ul><h3 id="Gitflow紧急修复bug流程"><a href="#Gitflow紧急修复bug流程" class="headerlink" title="Gitflow紧急修复bug流程"></a>Gitflow紧急修复bug流程</h3><ul><li>拉取远端分支(pull/clone)</li><li>从master分支新建hotfix分支(checkout -b hotfix/XXX)</li><li>开发，修复bug(add, commit)</li><li>再次拉取远端分支(fetch)</li><li>合入，解决冲突(merge)<ul><li>这里的合入需要同时合入master和develop，理由同release分支</li><li>但是理论上合入master分支的时候不应该有冲突，只能在合入develop分支的时候才会有可能冲突</li></ul></li><li>提交(push)</li></ul><p>注意所有的release分支都:</p><ul><li>从<strong>master</strong>分支新建而来</li><li>合入到master和develop分支而去</li></ul><h3 id="Gitflow工作流评价"><a href="#Gitflow工作流评价" class="headerlink" title="Gitflow工作流评价"></a>Gitflow工作流评价</h3><p>这里就不放优缺点了，因为Gitflow是目前使用最广，最为流行的git工作流</p><p>或许会有一些小的出入，但是各大公司基本上内部都会遵守这样的规则</p><p>大小项目，大小团队，都适用gitflow工作流</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了作者了解到的三种常见的&lt;em&gt;单仓库&lt;/em&gt;的git工作流，它们是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Centralized工作流&lt;ul&gt;
&lt;li&gt;仅使用master一个分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Feature Branch工作流&lt;ul&gt;
&lt;li&gt;使用一个master分支管理稳定版本&lt;/li&gt;
&lt;li&gt;使用多个feature分支管理需求开发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Gitflow工作流&lt;ul&gt;
&lt;li&gt;使用一个master分支管理发布版本历史&lt;/li&gt;
&lt;li&gt;使用一个develop分支管理开发流程&lt;/li&gt;
&lt;li&gt;使用多个feature分支管理需求开发&lt;/li&gt;
&lt;li&gt;使用多个release分支管理版本发布&lt;/li&gt;
&lt;li&gt;使用多个hotfix分支修复紧急bug&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
    
      <category term="git" scheme="https://rivers-shall.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>defer+recover保护gin不panic</title>
    <link href="https://rivers-shall.github.io/2020/06/04/defer-recover%E4%BF%9D%E6%8A%A4gin%E4%B8%8Dpanic/"/>
    <id>https://rivers-shall.github.io/2020/06/04/defer-recover保护gin不panic/</id>
    <published>2020-06-04T10:33:59.000Z</published>
    <updated>2020-06-04T10:51:31.819Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者保护gin构建的web app不panic的方式，简单来说：</p><ol><li>主程中的panic本身是会被gin拦截的</li><li>协程中的panic需要使用<code>defer</code>和<code>recover</code>进行保护</li></ol><a id="more"></a><h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>在我们用gin构建，运行web app并上线了之后，或许有一些请求会经过业务，在特定的情况下出发会触发golang中的<code>panic</code></p><p>按照golang的设定，一旦<code>panic</code>，如果不在函数调用栈中存在<code>recover</code>，那么是一定会使得整个程序终止的</p><p>但是线上的服务是不能够因为一个两个的请求就直接终止了的，这样非常危险，所以我们需要手段来阻止web app在<code>panic</code>的情况下直接终止</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="主程序中的panic"><a href="#主程序中的panic" class="headerlink" title="主程序中的panic"></a>主程序中的<code>panic</code></h3><p>对于gin这个web框架来说，主程序中的<code>panic</code>是会被自动<code>recover</code>的，还会打印出非常详细的日志信息，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/panic"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后我们作如下HTTP请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl localhost:8080/panic</span><br></pre></td></tr></table></figure><p>会发现在gin的运行窗口出现如下信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">2020/06/04 18:42:12 [Recovery] 2020/06/04 - 18:42:12 panic recovered:</span><br><span class="line">GET /panic HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: curl/7.64.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">panic</span><br><span class="line">/Users/admin/go/src/gin-test/main.go:10 (0x1581418)</span><br><span class="line">        main.func1: panic(<span class="string">"panic"</span>)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/context.go:165 (0x156baca)</span><br><span class="line">        (*Context).Next: c.handlers[c.index](c)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/recovery.go:83 (0x157fb13)</span><br><span class="line">        RecoveryWithWriter.func1: c.Next()</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/context.go:165 (0x156baca)</span><br><span class="line">        (*Context).Next: c.handlers[c.index](c)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/logger.go:241 (0x157ec40)</span><br><span class="line">        LoggerWithConfig.func1: c.Next()</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/context.go:165 (0x156baca)</span><br><span class="line">        (*Context).Next: c.handlers[c.index](c)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/gin.go:420 (0x1575d20)</span><br><span class="line">        (*Engine).handleHTTPRequest: c.Next()</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/gin.go:376 (0x157548c)</span><br><span class="line">        (*Engine).ServeHTTP: engine.handleHTTPRequest(c)</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/go/1.13.8/libexec/src/net/http/server.go:2802 (0x12cb6d3)</span><br><span class="line">        serverHandler.ServeHTTP: handler.ServeHTTP(rw, req)</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/go/1.13.8/libexec/src/net/http/server.go:1890 (0x12c6f74)</span><br><span class="line">        (*conn).serve: serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/go/1.13.8/libexec/src/runtime/asm_amd64.s:1357 (0x105c030)</span><br><span class="line">        goexit: BYTE    <span class="variable">$0x90</span>   // NOP</span><br><span class="line"></span><br><span class="line">[GIN] 2020/06/04 - 18:42:12 | 500 |    1.238546ms |             ::1 | GET      <span class="string">"/panic"</span></span><br></pre></td></tr></table></figure><p>并且整个app还在正常运行，没有终止，这非常好</p><h3 id="协程中的panic"><a href="#协程中的panic" class="headerlink" title="协程中的panic"></a>协程中的<code>panic</code></h3><p>不过非常可惜的是，对于协程中的<code>panic</code>，gin并不能做到自动<code>recover</code>并打印日志信息，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/go-panic"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该app之后，我们作如下的HTTP请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl localhost:8080/go-panic</span><br></pre></td></tr></table></figure><p>会发现gin app退出了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">panic: panic</span><br><span class="line"></span><br><span class="line">goroutine 24 [running]:</span><br><span class="line">main.main.func1.1()</span><br><span class="line">        /Users/admin/go/src/gin-test/main.go:11 +0x39</span><br><span class="line">created by main.main.func1</span><br><span class="line">        /Users/admin/go/src/gin-test/main.go:10 +0x35</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure><h4 id="协程解决方案"><a href="#协程解决方案" class="headerlink" title="协程解决方案"></a>协程解决方案</h4><p>所以，对于协程，我们要手动进行<code>defer</code>和<code>recover</code>，来避免app的退出和打印日志信息，比如上面的代码应该修改为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/go-panic"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    fmt.Printf(<span class="string">"error: %v\n"</span>, err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;()</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后我们像刚才一样进行HTTP请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl localhost:8080/go-panic</span><br></pre></td></tr></table></figure><p>会得到如下打印</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: panic</span><br><span class="line">[GIN] 2020/06/04 - 18:50:20 | 200 |       2.951µs |             ::1 | GET      <span class="string">"/go-panic"</span></span><br></pre></td></tr></table></figure><p>可以看到app正常响应了请求，并且没有退出并打印了日志，想要更多定制操作可以修改<code>defer</code>的函数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者保护gin构建的web app不panic的方式，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主程中的panic本身是会被gin拦截的&lt;/li&gt;
&lt;li&gt;协程中的panic需要使用&lt;code&gt;defer&lt;/code&gt;和&lt;code&gt;recover&lt;/code&gt;进行保护&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="gin" scheme="https://rivers-shall.github.io/tags/gin/"/>
    
  </entry>
  
  <entry>
    <title>oop大作业总结与从中看到的未来计划</title>
    <link href="https://rivers-shall.github.io/2020/06/04/oop%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%8E%E4%B8%AD%E7%9C%8B%E5%88%B0%E7%9A%84%E6%9C%AA%E6%9D%A5%E8%AE%A1%E5%88%92/"/>
    <id>https://rivers-shall.github.io/2020/06/04/oop大作业总结与从中看到的未来计划/</id>
    <published>2020-06-04T03:12:09.000Z</published>
    <updated>2020-06-04T08:37:43.540Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是在我完成了oop大作业之后，重新审视自己的开发流程与系统设计的一点总结与展望，简单来说：</p><ol><li>这是个”154/“(一无是处)的项目</li><li>好在能够让我感受到一些努力的方向</li></ol><p>代码就不开源了，实在太差了，就在这里口嗨一下就好</p><a id="more"></a><h2 id="存在的问题与未来的计划"><a href="#存在的问题与未来的计划" class="headerlink" title="存在的问题与未来的计划"></a>存在的问题与未来的计划</h2><h3 id="前端问题"><a href="#前端问题" class="headerlink" title="前端问题"></a>前端问题</h3><ol><li>没有对界面做任何的优化</li><li>没有任何的自动化测试，没有任何的后端分离的测试</li><li>模块化做的很差</li></ol><h4 id="没有对界面做任何的优化"><a href="#没有对界面做任何的优化" class="headerlink" title="没有对界面做任何的优化"></a>没有对界面做任何的优化</h4><p>CSS，是前端三大件中，我认为最复杂的一件，重点在于，CSS并不能被称为一门”编程语言”，应该来说，它是一门”设计用语”，在大学计算机科学中接触到的训练，可以说对CSS的学习是没有任何帮助的，这就导致即便看了很多CSS相关的资料，到了要实现界面效果的时候，还是会出现无从下手的情况</p><p>这次的大作业中，我几乎没有涉及到任何的CSS，只有在数个<code>div</code>需要并列做出类似column的效果时，使用了<code>display: inline-block</code>这样的属性设置，其他的我也想不到什么了</p><p>虽然离提交还有两三个星期，这个时间拿来上手一下element-ui之类的高层库，也是可能优化界面的，但是我觉得简约也是一种特色吧，另外，布置大作业时，长度不到一页纸的需求文档，我也没有太大的兴趣做出一个炫酷的界面，简约的界面反而和这样简约的需求很配呢</p><h4 id="没有任何的自动化测试，没有任何的后端分离测试"><a href="#没有任何的自动化测试，没有任何的后端分离测试" class="headerlink" title="没有任何的自动化测试，没有任何的后端分离测试"></a>没有任何的自动化测试，没有任何的后端分离测试</h4><p>前端的开发流程中，当然会需要测试</p><p>而我这次开发，测试的手段就是把后端服务起来，然后把前端dev-server起来，在界面上点来点去</p><p>这样子的效率低到令人发指，还需要后端的配合：</p><ol><li>点来点去，人傻了都</li><li>如果几次操作之间记忆出现错误，很有可能上一回测到的路径，这次又没有测到</li><li>如果后端接口没有准备好，前端就没有办法测试</li></ol><h4 id="模块化做的很差"><a href="#模块化做的很差" class="headerlink" title="模块化做的很差"></a>模块化做的很差</h4><p>前端的模块化一直以来都是问题挺大的，说实在的设计类要做出非常好的模块化也有点尴尬，另外一方面没有使用高层框架，也会使得模块化更加困难</p><p>首先，vue中的各个模组就已经出现了类似的结构，但是我并没有很好地方法来模块化，做的也有点烦躁</p><p>其次，前端存储和请求发送没有能够很好的模块化，尤其是请求发送模块，完全耦合在了vue的代码里，前端存储模块由于使用的是vuex框架，模块性还好一些，但是由于使用上经验不足，在引入到vue中的时候，出现了一些可读性较差的冗余代码</p><h3 id="前端未来的计划"><a href="#前端未来的计划" class="headerlink" title="前端未来的计划"></a>前端未来的计划</h3><ol><li>basic knowledge + code snippet 学习界面设计</li><li>了解前端的测试方式方法</li><li>了解好的前端架构与模块化开发方式</li></ol><h4 id="basic-knowledge-code-snippet-学习界面设计"><a href="#basic-knowledge-code-snippet-学习界面设计" class="headerlink" title="basic knowledge + code snippet 学习界面设计"></a>basic knowledge + code snippet 学习界面设计</h4><p>如何学习界面的设计？如何用CSS+JS或者高层框架实现设计？这两个问题，每个人都有不同的答案</p><p>我的答案是: basic knowledge + code snippet</p><h5 id="basic-knowledge"><a href="#basic-knowledge" class="headerlink" title="basic knowledge"></a>basic knowledge</h5><p>这就是指对CSS+JS或者高层框架的基础知识要了解，不需要深入，只要能够做到，看到代码，不会感到一头雾水，而是明白，这个属性/样式作用在了哪里，至于效果如何，怎么配置，知道去那里可以查文档就行</p><h5 id="code-snippet"><a href="#code-snippet" class="headerlink" title="code snippet"></a>code snippet</h5><p>这个才是重头戏，毕竟设计类的，只要不是强要求，大部分都可以通过修改他人的设计，而后达到自己的目的</p><p>所以平时要多积累：</p><ol><li>页面经典的布局(导航栏，登录界面，展示界面等)与实现代码</li><li>特殊的交互逻辑(固定在顶部的导航栏，顶部页面滑动进度显示等)与实现代码</li></ol><p>到时候自己想要做炫酷的功能，就直接去code snippet库里找一找，改一改就好</p><h4 id="了解前端的测试方式与方法"><a href="#了解前端的测试方式与方法" class="headerlink" title="了解前端的测试方式与方法"></a>了解前端的测试方式与方法</h4><p>最重要的几个问题：</p><ol><li>如何自动化？<ul><li>如何模拟鼠标，键盘等的交互操作？</li><li>如何验证测试结果？</li><li>前端JS逻辑代码如何测试？如何单元测试？</li></ul></li><li>如何与后端分离？<ul><li>如何模拟(mock)后端接口？</li><li>怎样设计</li></ul></li></ol><h4 id="了解好的前端架构与模块化开发方式"><a href="#了解好的前端架构与模块化开发方式" class="headerlink" title="了解好的前端架构与模块化开发方式"></a>了解好的前端架构与模块化开发方式</h4><p>去看看好的开源项目，他们是</p><ol><li>如何联动使用vue，vuex，vue-router，axios的</li><li>如何将前端存储，请求发送包装成为独立的模块</li><li>如何包装前端框架中的各种模组</li><li>其他的优秀设计理念</li></ol><h3 id="后端的问题"><a href="#后端的问题" class="headerlink" title="后端的问题"></a>后端的问题</h3><ol><li>没有自动化测试</li><li>没有使用数据库事务</li><li>后端REST接口设计的不好</li></ol><h4 id="没有自动化测试"><a href="#没有自动化测试" class="headerlink" title="没有自动化测试"></a>没有自动化测试</h4><p>没有，真的没有，为了快速开发，测试代码为零</p><h4 id="没有使用数据库事务"><a href="#没有使用数据库事务" class="headerlink" title="没有使用数据库事务"></a>没有使用数据库事务</h4><p>这有需求文档的问题(其实大作业布置下来的要求根本没资格被称为需求文档，只能说是非常模糊的甲方需求，<del>啊！万恶的甲方</del>)</p><p>也有个人的问题，本身是有情景需要事务的，但是由于对技术栈不熟悉(JS的express.js+mongoose)，在尝试了几下之后，就放弃了，毕竟还要优先保证完成业务逻辑，现在想想实际上并不是很困难，完全可以做</p><h4 id="后端REST接口设计的不好"><a href="#后端REST接口设计的不好" class="headerlink" title="后端REST接口设计的不好"></a>后端REST接口设计的不好</h4><p>这个”不好”，指的是什么方面呢？</p><p>首先，后端接口在开发过程中还几经变迁，基本上是开发到哪算到哪，最终导致接口变来变去，同时REST的”面向资源的操作”特性不明显</p><p>特性不明显这一点倒感觉未必非常重要，但是几经变迁这件事槽点比较大</p><h3 id="后端未来的计划"><a href="#后端未来的计划" class="headerlink" title="后端未来的计划"></a>后端未来的计划</h3><ol><li>学会自动化测试</li><li>了解各类数据库的使用</li><li>学习各种后端接口的设计</li></ol><h4 id="学会自动化测试"><a href="#学会自动化测试" class="headerlink" title="学会自动化测试"></a>学会自动化测试</h4><ul><li>如何在框架内使用单元测试？</li><li>如何mock HTTP请求?(postman)</li><li>如何自动化mock HTTP请求并验证response？</li></ul><h4 id="了解各类数据库的使用"><a href="#了解各类数据库的使用" class="headerlink" title="了解各类数据库的使用"></a>了解各类数据库的使用</h4><ul><li>SQL与NoSQL</li><li>数据库事务</li><li>数据库底层的实现，各类锁</li></ul><h4 id="学习各种后端接口的设计"><a href="#学习各种后端接口的设计" class="headerlink" title="学习各种后端接口的设计"></a>学习各种后端接口的设计</h4><ul><li>REST风格</li><li>GraphQL接口设计</li><li>RPC调用接口设计</li></ul><h3 id="开发流程上的问题与计划"><a href="#开发流程上的问题与计划" class="headerlink" title="开发流程上的问题与计划"></a>开发流程上的问题与计划</h3><p>主要是文档和git的workflow</p><p>文档方面，要养成良好的习惯，多写点注释，使用文档，需求文档，接口文档，设计的优先级一定是要高于编码的</p><p>git的workflow，要采用master/dev/feature/hotfix的开发方式，保持主分支的干净</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的开发活动，需求不明确，开发者也缺少经验，同时缺少动力(既不能赚钱，也不是自己感兴趣的产品)，所以最终的成品是比较惨的</p><p>总的来说，需要多读，读开源项目的代码，多写，自己找到有兴趣的项目，做一些完整的，良好的开发活动</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是在我完成了oop大作业之后，重新审视自己的开发流程与系统设计的一点总结与展望，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这是个”154/“(一无是处)的项目&lt;/li&gt;
&lt;li&gt;好在能够让我感受到一些努力的方向&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码就不开源了，实在太差了，就在这里口嗨一下就好&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="https://rivers-shall.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>goland中Run与Debug里working-directory的含义</title>
    <link href="https://rivers-shall.github.io/2020/06/03/goland%E4%B8%ADRun%E4%B8%8EDebug%E9%87%8Cworking-directory%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>https://rivers-shall.github.io/2020/06/03/goland中Run与Debug里working-directory的含义/</id>
    <published>2020-06-03T12:15:43.000Z</published>
    <updated>2020-06-03T12:26:58.028Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者由于不了解goland中Run与Debug配置中working-directory含义而引起的bug，简单来说:</p><blockquote><p>working directory就是golang项目编译好后的二进制文件执行的文件夹路径</p></blockquote><h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>项目框架中存在<code>conf</code>这样的专门放置配置文件的文件夹，当使用项目框架自带的<code>build.sh</code>构建脚本时，会将编译好的二进制文件和<code>conf</code>中的配置文件分别拷贝到<code>output/bin</code>和<code>output/conf</code>这两个文件夹下，将<code>output</code>试做发布文件夹</p><p>但是，在goland中如果想要配置Run或者Debug，是不能使用<code>build.sh</code>脚本的，只能配置原始的go编译命令</p><p>在配置的同时，我将working-directory很随意地设置为了<code>output</code>文件夹</p><h2 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h2><p>当我修改了配置文件并进行Run或者Debug时，发现修改没有生效</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>没有生效是因为，working-directory被设置为<code>output</code>文件夹，那么goland在执行goland本身编译好的二进制文件时，会引用<code>output/conf</code>下的配置文件</p><p>但是，<code>conf</code>文件夹下的修改是不会自动同步到<code>output/conf</code>里的(对源代码的修改会同步到goland上，因为goland会重新编译)，必须执行<code>./build.sh</code>脚本才可以</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>可以每次修改配置文件是都先执行<code>./build.sh</code>，然后再goland使用Run或Debug</p><p>也可以将working-directory设置为<code>./</code>而不是设置为<code>./output</code>，这样以后goland编译执行引用的就是<code>./conf</code>中的配置文件，修改也就能直接同步了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文记录了作者由于不了解goland中Run与Debug配置中working-directory含义而引起的bug，简单来说:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;working directory就是golang项目编译好后的二进制文件执行的文件夹路径&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="goland" scheme="https://rivers-shall.github.io/tags/goland/"/>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>bash中的字符串处理操作</title>
    <link href="https://rivers-shall.github.io/2020/06/02/bash%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/"/>
    <id>https://rivers-shall.github.io/2020/06/02/bash中的字符串处理操作/</id>
    <published>2020-06-02T06:35:42.000Z</published>
    <updated>2020-06-02T06:54:41.375Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用bash过程中，为了解决去除前缀后缀的问题而了解到的bash的字符串操作，简单来说</p><ol><li><code>string:position</code>或者<code>string:position:length</code>进行子串提取</li><li><code>string#pattern</code>进行最短匹配前缀去除，<code>string##pattern</code>进行最长匹配前缀去除</li><li><code>string%pattern</code>进行最短匹配后缀去除，<code>string%%pattern</code>进行最长匹配后缀去除</li><li><code>string/pattern/string</code>进行首个<code>pattern</code>替换，<code>string//pattern/string</code>进行全部<code>pattern</code>替换</li><li>以上的<code>pattern</code>指的都是<em>wildcard</em>而不是<em>regular expression</em></li></ol><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有时在使用bash脚本的时候，希望对字符串做一些基本的操作，比如说去除前缀后缀（去除文件扩展名，统一前缀编号等），事实上，bash原生支持了许多字符串操作</p><h2 id="bash-中的字符串操作"><a href="#bash-中的字符串操作" class="headerlink" title="bash 中的字符串操作"></a>bash 中的字符串操作</h2><p><strong>下面所有的<code>pattern</code>指的都是bash wildcard而不是regular expression</strong></p><h3 id="子串提取"><a href="#子串提取" class="headerlink" title="子串提取"></a>子串提取</h3><p>使用<code>string:position</code>提取从<code>position</code>开始的子串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string:3&#125;</span></span><br><span class="line">t, dummy, text, dummy</span><br></pre></td></tr></table></figure><p>使用<code>string:position:length</code>提取从<code>position</code>开始，长度为<code>length</code>的子串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string:3:4&#125;</span></span><br><span class="line">t, d</span><br></pre></td></tr></table></figure><h3 id="前缀去除"><a href="#前缀去除" class="headerlink" title="前缀去除"></a>前缀去除</h3><p>使用<code>string#pattern</code>进行最短匹配前缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string#*text&#125;</span></span><br><span class="line">, dummy, text, dummy</span><br></pre></td></tr></table></figure><p>使用<code>string##pattern</code>进行最长匹配前缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string##*text&#125;</span></span><br><span class="line">, dummy</span><br></pre></td></tr></table></figure><h3 id="后缀去除"><a href="#后缀去除" class="headerlink" title="后缀去除"></a>后缀去除</h3><p>使用<code>string%pattern</code>进行最短匹配后缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string%dummy*&#125;</span></span><br><span class="line">text, dummy, text, y</span><br></pre></td></tr></table></figure><p>使用<code>string%%pattern</code>进行最长匹配后缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string%%dummy*&#125;</span></span><br><span class="line">text,</span><br></pre></td></tr></table></figure><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>使用<code>string/pattern/string</code>进行首个<code>pattern</code>的替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string/text/TEXT&#125;</span></span><br><span class="line">TEXT, dummy, text, dummy</span><br></pre></td></tr></table></figure><p>使用<code>string//pattern/string</code>进行全部<code>pattern</code>的替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string//text/TEXT&#125;</span></span><br><span class="line">TEXT, dummy, TEXT, dummy</span><br></pre></td></tr></table></figure><p>想要得到对正则表达式匹配替换的支持的话，可以使用<a href="https://man.linuxde.net/sed" target="_blank" rel="noopener">sed</a>命令</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用bash过程中，为了解决去除前缀后缀的问题而了解到的bash的字符串操作，简单来说&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;string:position&lt;/code&gt;或者&lt;code&gt;string:position:length&lt;/code&gt;进行子串提取&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string#pattern&lt;/code&gt;进行最短匹配前缀去除，&lt;code&gt;string##pattern&lt;/code&gt;进行最长匹配前缀去除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string%pattern&lt;/code&gt;进行最短匹配后缀去除，&lt;code&gt;string%%pattern&lt;/code&gt;进行最长匹配后缀去除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string/pattern/string&lt;/code&gt;进行首个&lt;code&gt;pattern&lt;/code&gt;替换，&lt;code&gt;string//pattern/string&lt;/code&gt;进行全部&lt;code&gt;pattern&lt;/code&gt;替换&lt;/li&gt;
&lt;li&gt;以上的&lt;code&gt;pattern&lt;/code&gt;指的都是&lt;em&gt;wildcard&lt;/em&gt;而不是&lt;em&gt;regular expression&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="bash" scheme="https://rivers-shall.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中箭头函数与普通函数</title>
    <link href="https://rivers-shall.github.io/2020/06/01/JavaScript%E4%B8%AD%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://rivers-shall.github.io/2020/06/01/JavaScript中箭头函数与普通函数/</id>
    <published>2020-06-01T12:26:38.000Z</published>
    <updated>2020-06-01T12:46:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用mongoose的过程中，因为箭头函数与普通函数的区别而引起的一个bug，以及因此而学会的有关箭头函数与普通函数的区别，简单来说：</p><ol><li>箭头函数不能使用<code>arguments</code>参数，普通函数可以</li><li>箭头函数的<code>this</code>关键字是lexically bound，也就是<code>this</code>是和<strong>最近的外层普通函数</strong>所具有的<code>this</code>一致(如果没有这样的函数，就和文件本身代表的对象绑定)；普通函数的<code>this</code>是dynamically bound，视运行时环境而确定</li></ol><p>其实还有什么<code>new</code>之类的，作者觉得不大重要，就算了</p><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在使用mongoose的过程中，需要对schema构造一个“虚字段”，参考实现中使用如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">itemSchema.virtual(<span class="string">"id"</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._id.toHexString();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我寻思着可以少写点东西，更精简一些，于是在我的实现里使用了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">itemSchema.virtual(<span class="string">"id"</span>).get(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._id.toHexString();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行时报错:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined 没有 toHexString 成员函数</span><br></pre></td></tr></table></figure><p>这才意识到，原来使用箭头函数的时候，<code>this</code>的绑定规则和普通函数不一致</p><h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f2(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这段代码<strong>在浏览器中</strong>，<code>f1</code>可以正常打印，<code>f2</code>会报<code>undefined</code>，当然，在node.js环境下，还会有些不同，可以自己试试</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">exports.mod = <span class="string">"mod"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    f1() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = &#123;</span><br><span class="line">    f1 : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.f1()</span><br><span class="line">user2.f1()</span><br></pre></td></tr></table></figure><p>这段代码在node.js下，打印出如下结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; node test2.js</span><br><span class="line">&#123; f1: [Function: f1] &#125;</span><br><span class="line">&#123; mod: <span class="string">'mod'</span> &#125;</span><br></pre></td></tr></table></figure><p>可见，普通函数绑定的是运行时的对象，箭头函数绑定的是静态的编译时的对象</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用mongoose的过程中，因为箭头函数与普通函数的区别而引起的一个bug，以及因此而学会的有关箭头函数与普通函数的区别，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;箭头函数不能使用&lt;code&gt;arguments&lt;/code&gt;参数，普通函数可以&lt;/li&gt;
&lt;li&gt;箭头函数的&lt;code&gt;this&lt;/code&gt;关键字是lexically bound，也就是&lt;code&gt;this&lt;/code&gt;是和&lt;strong&gt;最近的外层普通函数&lt;/strong&gt;所具有的&lt;code&gt;this&lt;/code&gt;一致(如果没有这样的函数，就和文件本身代表的对象绑定)；普通函数的&lt;code&gt;this&lt;/code&gt;是dynamically bound，视运行时环境而确定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实还有什么&lt;code&gt;new&lt;/code&gt;之类的，作者觉得不大重要，就算了&lt;/p&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
    
      <category term="JavaScript" scheme="https://rivers-shall.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>grep打印匹配行的未匹配内容</title>
    <link href="https://rivers-shall.github.io/2020/06/01/grep%E6%89%93%E5%8D%B0%E5%8C%B9%E9%85%8D%E8%A1%8C%E7%9A%84%E6%9C%AA%E5%8C%B9%E9%85%8D%E5%86%85%E5%AE%B9/"/>
    <id>https://rivers-shall.github.io/2020/06/01/grep打印匹配行的未匹配内容/</id>
    <published>2020-06-01T10:47:40.000Z</published>
    <updated>2020-06-01T12:06:53.634Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用<code>grep</code>和<code>sed</code>命令来实现，打印<code>grep</code>匹配行中的未匹配内容的功能的方法，简单来说：</p><ol><li>先使用<code>grep &lt;pattern&gt;</code>提取出匹配行</li><li>再使用<code>sed -e &#39;s/&lt;pattern&gt;//g&#39;</code>将匹配内容消除，即可得到未匹配内容</li></ol><a id="more"></a><h2 id="场景与方案"><a href="#场景与方案" class="headerlink" title="场景与方案"></a>场景与方案</h2><p>使用<code>grep</code>时，我们可以用<code>grep &lt;pattern&gt;</code>来打印出匹配行，可以使用<code>grep -o &lt;pattern&gt;</code>来打印出匹配行中的匹配内容，但是如果希望能够实现“反选”，也就是打印出匹配行中的费匹配内容，应该怎么做呢？</p><p>单纯的<code>grep</code>命令没有提供这种机制的支持，但是同时使用<code>grep</code>和<code>sed</code>命令就可以实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"matched not\nmat"</span> | grep <span class="string">"matched"</span> | sed <span class="string">"s/matched//g"</span></span><br><span class="line"> not</span><br></pre></td></tr></table></figure><p>首先，我们使用<code>grep &lt;pattern&gt;</code>打印出匹配行，而后，使用<code>sed &quot;s/&lt;pattern&gt;//g&quot;</code>将匹配行中的匹配内容替换为空字符串，就消除了匹配内容，留下了非匹配内容</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用&lt;code&gt;grep&lt;/code&gt;和&lt;code&gt;sed&lt;/code&gt;命令来实现，打印&lt;code&gt;grep&lt;/code&gt;匹配行中的未匹配内容的功能的方法，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先使用&lt;code&gt;grep &amp;lt;pattern&amp;gt;&lt;/code&gt;提取出匹配行&lt;/li&gt;
&lt;li&gt;再使用&lt;code&gt;sed -e &amp;#39;s/&amp;lt;pattern&amp;gt;//g&amp;#39;&lt;/code&gt;将匹配内容消除，即可得到未匹配内容&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://rivers-shall.github.io/tags/sed/"/>
    
      <category term="grep" scheme="https://rivers-shall.github.io/tags/grep/"/>
    
  </entry>
  
  <entry>
    <title>bash实现trim字符串</title>
    <link href="https://rivers-shall.github.io/2020/06/01/bash%E5%AE%9E%E7%8E%B0trim%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://rivers-shall.github.io/2020/06/01/bash实现trim字符串/</id>
    <published>2020-06-01T10:27:53.000Z</published>
    <updated>2020-06-01T10:43:55.574Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用<code>sed</code>命令对bash中的字符串进行去头尾空格的操作的方法，简单来说</p><ol><li>使用<code>echo &#39;  string  &#39; | sed -e &#39;s/^[[:space:]]*//&#39;</code>去除开头的空格</li><li>使用<code>echo &#39;  string  &#39; | sed -e &#39;s/[[:space:]]*$//&#39;</code>去除结尾的空格</li><li>将二者用管道结合，去除头尾空格<code>echo &#39;  string  &#39; | sed -e &#39;s/[[:space:]]*$//&#39; | sed -e &#39;s/^[[:space:]]*//&#39;</code></li></ol><a id="more"></a><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>去除头尾空格的字符串处理操作是非常常用的操作，在许多语言的标准库里都会以<code>trim</code>函数的方式提供出来</p><p>要在bash中实现这一功能，可以使用<code>sed</code>命令的替换子命令</p><p><code>sed -e &#39;s/^[[:space:]]*//&#39;</code>是指匹配所有行开头的空格并将其替换为空字符串</p><p><code>sed -e &#39;s/[[:space:]]*$//&#39;</code>是指匹配所有行结尾的空格并将其替换为空字符串</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用&lt;code&gt;sed&lt;/code&gt;命令对bash中的字符串进行去头尾空格的操作的方法，简单来说&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/^[[:space:]]*//&amp;#39;&lt;/code&gt;去除开头的空格&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/[[:space:]]*$//&amp;#39;&lt;/code&gt;去除结尾的空格&lt;/li&gt;
&lt;li&gt;将二者用管道结合，去除头尾空格&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/[[:space:]]*$//&amp;#39; | sed -e &amp;#39;s/^[[:space:]]*//&amp;#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://rivers-shall.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>转义sed替换模式字符串</title>
    <link href="https://rivers-shall.github.io/2020/06/01/%E8%BD%AC%E4%B9%89sed%E6%9B%BF%E6%8D%A2%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://rivers-shall.github.io/2020/06/01/转义sed替换模式字符串/</id>
    <published>2020-06-01T05:47:34.000Z</published>
    <updated>2020-06-01T10:43:41.406Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用<code>sed</code>命令进行文本替换时，对于使用到的替换模式进行转义处理使用到的<code>sed</code>命令，简单来说：</p><ul><li>使用<code>sed -e &#39;s/[]\/$*.^[]/\\&amp;/g&#39;</code>即可对输入字符串进行转义</li></ul><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><code>sed</code>命令常常被用来对文本做处理，其中一个最经常用到的处理就是替换，替换的语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$STRING</span> | sed -e <span class="string">'s/&lt;match_pattern&gt;/&lt;replace_pattern&gt;/g'</span></span><br></pre></td></tr></table></figure><p>当然也可以有其他的变化，不过这是作者使用的最多的方式。</p><p>在使用这些的时候，我们可能会在<code>match_pattern</code>和<code>replace_pattern</code>中引用变量，已达到分别管理和增强可读性的目的，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"ff"</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>但是，如果上面引用的<code>REPLACE</code>里面有特殊字符，我们就会遇到问题，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"/a"</span></span><br><span class="line"><span class="comment"># 有问题</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>我们的本意是将<code>a</code>替换为<code>/a</code>，但是，使用这几条命令，会得到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed: 1: <span class="string">"s/a//a/g</span></span><br><span class="line"><span class="string">"</span>: bad flag <span class="keyword">in</span> substitute <span class="built_in">command</span>: <span class="string">'a'</span></span><br></pre></td></tr></table></figure><p>这里的原因就是<code>/a</code>中的<code>/</code>是一个特殊字符，如果希望得到我们上述的效果，应该这么操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"\/a"</span></span><br><span class="line"><span class="comment"># 成功</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>我们通过<code>\/</code>进行转义，取得了成功，但是这种方式使得我们编写<code>replace_pattern</code>变得麻烦，而且很不直观，我们希望有一个函数来达到如下效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"/a"</span></span><br><span class="line">REPLACE=$(func <span class="variable">$REPLACE</span>)</span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>也就是说，编写<code>replace_pattern</code>时，可以直接编写，而后使用一个函数或者命令自动转义再使用</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><a href="https://stackoverflow.com/questions/407523/escape-a-string-for-a-sed-replace-pattern" target="_blank" rel="noopener">stackoverflow</a></p><p>使用<code>sed -e &#39;s/[]\/$*.^[]/\\&amp;/g&#39;</code>即可</p><h3 id="方案解析"><a href="#方案解析" class="headerlink" title="方案解析"></a>方案解析</h3><p>我们这次的方案就是对原生的<code>replace_pattern</code>做一次替换:</p><ul><li><code>match_pattern</code>为<code>[]\/$*.^[]</code><ul><li>这个正则表达式的结构很具有迷惑性，其实它是一个大的<em>bracket group</em></li><li>也就是说，实际上是<code>[</code> <code>]\/$*.^[</code> <code>]</code>的结构</li><li>意味着匹配<code>]\/$*.^[</code>中的任一字符</li></ul></li><li><code>replace_pattern</code>为<code>\\&amp;</code><ul><li>这个<code>replace_pattern</code>用到了一个转义字符和一个特殊字符</li><li>转义字符<code>\\</code>表示的就是<code>\</code></li><li>特殊字符<code>&amp;</code>表示的是<code>match_pattern</code>匹配到的内容</li></ul></li></ul><p>综合起来，这个替换语句就是把<code>]\/$*.^[</code>前面全部加上一个斜杠，进行转义</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用&lt;code&gt;sed&lt;/code&gt;命令进行文本替换时，对于使用到的替换模式进行转义处理使用到的&lt;code&gt;sed&lt;/code&gt;命令，简单来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;sed -e &amp;#39;s/[]\/$*.^[]/\\&amp;amp;/g&amp;#39;&lt;/code&gt;即可对输入字符串进行转义&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://rivers-shall.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>date命令的两种常用法</title>
    <link href="https://rivers-shall.github.io/2020/06/01/date%E5%91%BD%E4%BB%A4%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%B3%95/"/>
    <id>https://rivers-shall.github.io/2020/06/01/date命令的两种常用法/</id>
    <published>2020-06-01T03:17:25.000Z</published>
    <updated>2020-06-01T10:43:59.583Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在平时工作中经常用到的Linux命令<code>date</code>的两种常见使用方式，简单来说：</p><ol><li>打印当前时间，<code>date &quot;+&lt;output_format&gt;&quot;</code></li><li>将Unix时间戳转化为可读的日期+时间<code>date -r &lt;unix-timestamp&gt; &quot;+&lt;output_format&gt;&quot;</code></li></ol><a id="more"></a><h2 id="打印当前时间"><a href="#打印当前时间" class="headerlink" title="打印当前时间"></a>打印当前时间</h2><p>只需要使用<code>date &quot;+&lt;output_format&gt;&quot;</code>就可以打印当前时间，其中，<code>output_format</code>由正常字符和转义字符组成，转义字符用来打印当前的年，月，日等等</p><table><thead><tr><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td>%Y</td><td>年</td></tr><tr><td>%m</td><td>月</td></tr><tr><td>%d</td><td>日</td></tr><tr><td>%H</td><td>小时</td></tr><tr><td>%M</td><td>分钟</td></tr><tr><td>%S</td><td>秒</td></tr><tr><td>%s</td><td>时间戳</td></tr></tbody></table><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date <span class="string">"+%Y-%m-%d-%H-%M-%S"</span></span><br><span class="line">2020-06-01-11-24-39</span><br></pre></td></tr></table></figure><h2 id="将Unix时间戳转化为可读的日期-时间"><a href="#将Unix时间戳转化为可读的日期-时间" class="headerlink" title="将Unix时间戳转化为可读的日期+时间"></a>将Unix时间戳转化为可读的日期+时间</h2><p>使用<code>date -r &lt;unix-timestamp&gt; &quot;+&lt;output_format&gt;&quot;</code>即可完成转化，其中的<code>output_format</code>和上文中介绍的一样，<code>&lt;unix-timestamp</code>就是一个数字</p><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date -r 0 <span class="string">"+%Y-%m-%d-%H-%M-%S"</span></span><br><span class="line">1970-01-01-08-00-00</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在平时工作中经常用到的Linux命令&lt;code&gt;date&lt;/code&gt;的两种常见使用方式，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打印当前时间，&lt;code&gt;date &amp;quot;+&amp;lt;output_format&amp;gt;&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将Unix时间戳转化为可读的日期+时间&lt;code&gt;date -r &amp;lt;unix-timestamp&amp;gt; &amp;quot;+&amp;lt;output_format&amp;gt;&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>git-status中文乱码问题</title>
    <link href="https://rivers-shall.github.io/2020/05/29/git-status%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://rivers-shall.github.io/2020/05/29/git-status中文乱码问题/</id>
    <published>2020-05-29T10:21:28.000Z</published>
    <updated>2020-06-01T10:43:31.134Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者解决<code>git status</code>命令中出现中文名乱码问题的方法，简单来说</p><blockquote><p>配置 core.quotepath 为 false 即可</p></blockquote><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>当我们的修改文件中出现中文文件名时，<code>git status</code>就会出现乱码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  project git:(master) ✗ git status -s</span><br><span class="line">?? <span class="string">"\344\270\255\346\226\207\346\226\207\344\273\266"</span></span><br></pre></td></tr></table></figure><p>这是由于Git默认会对ASCII以外的编码进行转义，只要将这个转义关掉，就可以恢复正常了，关掉的方式就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  project git:(master) ✗ git config core.quotepath <span class="literal">false</span></span><br><span class="line">➜  project git:(master) ✗ git status -s</span><br><span class="line">?? 中文文件</span><br></pre></td></tr></table></figure><p>当然，如果希望让这个设定在所有的Git本地仓库里都生效，可以加上<code>--global</code>选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  project git:(master) ✗ git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者解决&lt;code&gt;git status&lt;/code&gt;命令中出现中文名乱码问题的方法，简单来说&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置 core.quotepath 为 false 即可&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="git" scheme="https://rivers-shall.github.io/tags/git/"/>
    
      <category term="中文乱码" scheme="https://rivers-shall.github.io/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>golang抽取接口，依赖注入(依赖倒置)解决包引用关系</title>
    <link href="https://rivers-shall.github.io/2020/05/28/golang%E6%8A%BD%E5%8F%96%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE-%E8%A7%A3%E5%86%B3%E5%8C%85%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB/"/>
    <id>https://rivers-shall.github.io/2020/05/28/golang抽取接口，依赖注入-依赖倒置-解决包引用关系/</id>
    <published>2020-05-28T06:58:15.000Z</published>
    <updated>2020-06-09T08:16:14.109Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在golang开发中，通过抽取接口，依赖注入的方式，解决包与包之间的不合理引用关系。</p><p>总结来说：</p><blockquote><p>面向接口编程，并且golang中接口函数的参数最好是标准库的类型</p></blockquote><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>目前项目中有一个业务逻辑包<code>business_logic</code>，两个工具库包<code>pkg1</code>和<code>pkg2</code>，其中</p><ul><li><code>pkg1</code>是旧库，API不宜改动，<code>pkg2</code>是新库，尚未正式使用</li><li><code>business_logic</code>会使用<code>pkg1</code>和<code>pkg2</code></li><li><code>pkg1</code>内部要添加使用<code>pkg2</code>的逻辑</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg1/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"pkg2"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg2.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg2/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    param1 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">(s S)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// business_logic/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"pkg1"</span></span><br><span class="line">    <span class="string">"pkg2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg1.ExternalAPI()</span><br><span class="line">    pkg2.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就引起了一个问题：</p><blockquote><p><code>business_logic</code>其实引用了两次<code>pkg2</code>，一次是直接引用，一次是通过<code>pkg1</code>间接引用，将来在版本更迭中，很有可能会出现直接引用的版本和间接引用的版本不一致的情况，从而引起未知bug</p></blockquote><h2 id="解决尝试"><a href="#解决尝试" class="headerlink" title="解决尝试"></a>解决尝试</h2><p>如果不希望两次引用，那么最好的方式是消除<code>pkg1</code>对<code>pkg2</code>的引用，消除引用的方式是</p><ul><li><code>pkg1</code>抽象出一个接口，</li><li>让<code>pkg2</code>提供结构体，实现<code>pkg1</code>抽象出的接口</li></ul><p>这样，<code>pkg2</code>实际上就变成了<code>pkg1</code>的一个插件，只要在<code>business_logic</code>初始化的时候，将<code>pkg2</code>的插件注入到<code>pkg1</code>里去就行</p><p>但是这样的尝试失败了，我们先来看一下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg1/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"pkg2"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    ExternalAPI(s pkg2.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plugin Plugin</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> plugin != <span class="literal">nil</span> &#123;</span><br><span class="line">        plugin.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetPlugin</span><span class="params">(p Plugin)</span></span> &#123;</span><br><span class="line">    plugin = p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg2/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    param1 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Plugin)</span> <span class="title">ExternalAPI</span><span class="params">(s S)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">(s S)</span></span> &#123;</span><br><span class="line">    p := Plugin&#123;&#125;</span><br><span class="line">    p.ExternalAPI(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// business_logic/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"pkg1"</span></span><br><span class="line">    <span class="string">"pkg2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg1.SetPlugin(&amp;pkg2.Plugin&#123;&#125;)</span><br><span class="line">    pkg1.ExternalAPI()</span><br><span class="line">    pkg2.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，<code>pkg1</code>对<code>pkg2</code>的引用仍旧存在，其原因在于抽取出来的接口函数中的参数是属于<code>pkg2</code>的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    ExternalAPI(s pkg2.S)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终解决方案"><a href="#最终解决方案" class="headerlink" title="最终解决方案"></a>最终解决方案</h2><p>由于<code>pkg2</code>是新库，所以我们决定更改它的接口，最终的代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg1/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    ExternalAPI(param <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plugin Plugin</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> plugin != <span class="literal">nil</span> &#123;</span><br><span class="line">        plugin.ExternalAPI(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetPlugin</span><span class="params">(p Plugin)</span></span> &#123;</span><br><span class="line">    plugin = p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg2/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Plugin)</span> <span class="title">ExternalAPI</span><span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    p := Plugin&#123;&#125;</span><br><span class="line">    p.ExternalAPI(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// business_logic/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"pkg1"</span></span><br><span class="line">    <span class="string">"pkg2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg1.SetPlugin(&amp;pkg2.Plugin&#123;&#125;)</span><br><span class="line">    pkg1.ExternalAPI()</span><br><span class="line">    pkg2.ExternalAPI(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这回彻底解决了<code>pkg1</code>引用<code>pkg2</code>的问题，代价就是将<code>pkg2.S</code>这个结构体参数展开了</p><p>视具体业务情况而定，我们可以通过：</p><ol><li>展开结构体</li><li>将结构体换做<code>map[string]interface{}</code>（当然需要手动做字段的提取和塞入）</li><li>将结构体换做<code>string</code>，用JSON传参（手动Marshal和Unmarshal）</li><li>将参数类型放到新的第三方库<code>pkg3</code>中（这样就又要维护引用的<code>pkg3</code>版本一致）</li></ol><p>软件开发中没有silver-bullet，只有trade-off，这次的方案，也还算满意</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在golang开发中，通过抽取接口，依赖注入的方式，解决包与包之间的不合理引用关系。&lt;/p&gt;
&lt;p&gt;总结来说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;面向接口编程，并且golang中接口函数的参数最好是标准库的类型&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>一个golang的RPC框架设计中的坑点</title>
    <link href="https://rivers-shall.github.io/2020/05/27/%E4%B8%80%E4%B8%AAgolang%E7%9A%84RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%9D%91%E7%82%B9/"/>
    <id>https://rivers-shall.github.io/2020/05/27/一个golang的RPC框架设计中的坑点/</id>
    <published>2020-05-27T13:13:42.000Z</published>
    <updated>2020-06-01T10:45:39.404Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用公司的RPC框架时，由于RPC框架本身的设计以及程序员的投机取巧而遇到的一个坑点。</p><p>简单来说，RPC框架没有能够做足够好的封装，程序员（不是作者，是前人）也没有按照RPC框架约定的方式进行API调用。</p><a id="more"></a><h2 id="背景提要"><a href="#背景提要" class="headerlink" title="背景提要"></a>背景提要</h2><p>我们知道，RPC调用是不同主机间的进程通信的方式，如果想要额外传递消息，我们往往需要修改RPC调用的接口，通过新增参数的方式来新增传递信息。</p><p>但是这样修改参数，修改接口的方式侵入性太强，需要进行上下游调用接口的适配，很麻烦。</p><p>当我们面对一些遍布在各个RPC服务的需求（也就是很多人喜欢提及的编程”切面”Aspect），比如这回我接到的日志系统的需求，将所有的接口都修改一遍，显然是不现实的。</p><p>在这里，golang的RPC框架可以通过传递<code>context.Context</code>来实现，也就是说，这些额外的，遍布各个RPC服务的消息，通过<code>context.Context</code>来传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc 上游调用时，传递一个`context.Context`和本来必要的下游rpc接口参数</span></span><br><span class="line">rpcClient.remoteMethod(ctx, request)</span><br><span class="line"></span><br><span class="line"><span class="comment">// rpc 下游接受请求时，接受一个`context.Context`和本来必要的接口参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">methodHandler</span><span class="params">(ctx context.Context, request MethodRequest)</span></span></span><br></pre></td></tr></table></figure><h3 id="类比HTTP解释"><a href="#类比HTTP解释" class="headerlink" title="类比HTTP解释"></a>类比HTTP解释</h3><p>上面提及的RPC调用传递<code>context.Context</code>和本来的接口参数，其实可以类比HTTP协议：</p><ul><li><code>context.Context</code> -&gt; HTTP Request Headers</li><li>接口参数 -&gt; HTTP Request Body</li></ul><p>二者都是传递信息的手段，但是接口参数和Request Body往往是明面上的写出来的主要业务逻辑需要的消息，<code>context.Context</code>和Request Headers往往是一些元数据(metadata)。</p><h2 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h2><p>这次的日志系统，需要我记录RPC运行时的动态调用链，也就是说，如果有一条RPC调用链路是</p><blockquote><p>RPC1 -&gt; RPC2 -&gt; RPC3</p></blockquote><p>那么实时的日志里，会有如下条目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RPC1:</span><br><span class="line">stack : []</span><br><span class="line"></span><br><span class="line">RPC2:</span><br><span class="line">stack : [RPC1]</span><br><span class="line"></span><br><span class="line">RPC3:</span><br><span class="line">stack : [RPC1, RPC2]</span><br></pre></td></tr></table></figure><h2 id="解决过程中遇到的问题"><a href="#解决过程中遇到的问题" class="headerlink" title="解决过程中遇到的问题"></a>解决过程中遇到的问题</h2><p>对于这个功能，我们发现RPC框架提供了三个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向一个context.Context加入key-val键值对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInfo</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, val <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 获取上游通过<span class="title">AddInfo</span>传来的<span class="title">key</span>对应的<span class="title">val</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">GetUpstreamInfo</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 获取所有上游通过<span class="title">AddInfo</span>传来的键值对，组织成一个<span class="title">map</span>[<span class="title">string</span>][<span class="title">string</span>]</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">GetAllUpstreamInfo</span><span class="params">(ctx context.Context)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>为此，我们的解决方案是，将<code>stack</code>做成<code>[]RPC</code>，其中<code>struct RPC</code>记录RPC的信息，通过JSON将<code>[]RPC</code>转化成<code>string</code>，而后用<code>context.Context</code>里的<code>&quot;stack&quot; - JSON([]RPC)</code>的键值对进行传递。</p><p>在我之前编码的程序员，没有遵守API调用规则，不使用<code>AddInfo</code>，而是使用的是如下方式进行<code>stack</code>的传递的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有的键值对</span></span><br><span class="line">m := util.GetAllUpstreamInfo(ctx)</span><br><span class="line"><span class="comment">// 取出stack并使用JSON解析</span></span><br><span class="line">stack, err := json.Unmarshal(m[<span class="string">"stack"</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加现有RPC调用</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, currentRPC)</span><br><span class="line"><span class="comment">// JOSN编码，更新ctx内的map</span></span><br><span class="line">m[<span class="string">"stack"</span>], err = json.Marshal(stack)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于golang中的map是引用传值，所以看上去这个代码已经成功更新了ctx内部的map，使用Goland-Debug查看ctx也会发现map已经修改了</p><p>但事实上程序并没有按照预期的方式进行工作</p><h3 id="排查原因"><a href="#排查原因" class="headerlink" title="排查原因"></a>排查原因</h3><p>仔细观察<code>AddInfo</code>函数的签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInfo</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, val <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br></pre></td></tr></table></figure><p>该函数返回了一个全新的Context，事实上<code>AddInfo</code>的逻辑是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">newCtx := AddInfo(ctx, <span class="string">"key"</span>, <span class="string">"val"</span>)</span><br><span class="line"></span><br><span class="line">+------------------------------+</span><br><span class="line">|          newCtx              |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |        ctx             | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|    K_KV -&gt;                   |</span><br><span class="line">| <span class="keyword">struct</span>&#123;key:<span class="string">"key"</span>,val:<span class="string">"val"</span>&#125;  |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><p>也就是说，新的Context在原来的Context上多加了一层，这一层的结构是</p><p><code>K_KV(RPC框架定义的一个字符串) -&gt; struct{key: &quot;key&quot;, val: &quot;val&quot;}</code></p><p>我们通过<code>newCtx.Value(&quot;key&quot;)</code>是拿不到任何东西的，只能通过<code>newCtx.Value(K_KV)</code>才能拿到完整的键值对</p><h4 id="这时，RPC框架有了一个骚操作"><a href="#这时，RPC框架有了一个骚操作" class="headerlink" title="这时，RPC框架有了一个骚操作"></a>这时，RPC框架有了一个骚操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPC1 ctx -------中间对ctx做了转化----------&gt; RPC2</span><br></pre></td></tr></table></figure><p>假设我们上游RPC1使用了如下<code>AddInfo</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">newCtx := AddInfo(ctx, <span class="string">"key"</span>, <span class="string">"val"</span>)</span><br><span class="line">newCtx2 := AddInfo(newCtx, <span class="string">"key2"</span>, <span class="string">"val2"</span>)</span><br><span class="line"></span><br><span class="line">+------------------------------+</span><br><span class="line">|          newCtx2             |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|   |      newCtx            | |</span><br><span class="line">|   |   +-------------+      | |</span><br><span class="line">|   |   |    ctx      |      | |</span><br><span class="line">|   |   +-------------+      | |</span><br><span class="line">|   | K_KV -&gt; <span class="keyword">struct</span>&#123;        | |</span><br><span class="line">|   |          key:<span class="string">"key"</span>     | |</span><br><span class="line">|   |          val:<span class="string">"val"</span>&#125;    | |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|  K_KV -&gt; <span class="keyword">struct</span>&#123;key:<span class="string">"key2"</span>,  |</span><br><span class="line">|                 val:<span class="string">"val2"</span>&#125;  |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><p>那么<code>newCtx2</code>就该如图示的那样，但是下游RPC2拿到的是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------+</span><br><span class="line">|          newCtx              |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |        ctx             | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|    K_UPSTREAM -&gt;             |</span><br><span class="line">|     <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;       |</span><br><span class="line">|           <span class="string">"key"</span> : <span class="string">"val"</span>,     |</span><br><span class="line">|           <span class="string">"key2"</span> : <span class="string">"val2"</span>    |</span><br><span class="line">|     &#125;                        |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><p>所以，用于从Context取出键值对的索引从<code>K_KV</code>变为了<code>K_UPSTREAM</code>!!!</p><p>这意味着上游传来的消息最多只能保留一个RPC路径，所以我们必须使用<code>AddInfo</code>而不是直接写入map的方式来更新数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有的键值对</span></span><br><span class="line">m := util.GetAllUpstreamInfo(ctx)</span><br><span class="line"><span class="comment">// 取出stack并使用JSON解析</span></span><br><span class="line">stack, err := json.Unmarshal(m[<span class="string">"stack"</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加现有RPC调用</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, currentRPC)</span><br><span class="line"><span class="comment">// JOSN编码，更新ctx内的map</span></span><br><span class="line">jsonStack, err := json.Marshal(stack)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">ctx = util.AddInfo(ctx, <span class="string">"stack"</span>, jsonStack)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>框架底层的逻辑并不是很易懂，解释比较麻烦，一篇博文难以说明清楚，但是需要记住的是：</p><ol><li>使用框架，尽量使用框架的标准接口</li><li>框架封装的时候，如果有map这类可能会让人有hack欲望的，写明文档</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用公司的RPC框架时，由于RPC框架本身的设计以及程序员的投机取巧而遇到的一个坑点。&lt;/p&gt;
&lt;p&gt;简单来说，RPC框架没有能够做足够好的封装，程序员（不是作者，是前人）也没有按照RPC框架约定的方式进行API调用。&lt;/p&gt;
    
    </summary>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="RPC" scheme="https://rivers-shall.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>编写自定义启动脚本时的注意项</title>
    <link href="https://rivers-shall.github.io/2020/05/27/%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E9%A1%B9/"/>
    <id>https://rivers-shall.github.io/2020/05/27/编写自定义启动脚本时的注意项/</id>
    <published>2020-05-27T13:12:04.000Z</published>
    <updated>2020-06-01T10:44:34.420Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章介绍了作者在使用和编写自定义启动脚本时感受到的一个需要注意的点，简单来说，就是：</p><blockquote><p>一定要打印出事实上的最终启动命令</p></blockquote><a id="more"></a><h2 id="自定义启动脚本的使用场景"><a href="#自定义启动脚本的使用场景" class="headerlink" title="自定义启动脚本的使用场景"></a>自定义启动脚本的使用场景</h2><p>我们知道，启动一个程序需要固定的命令，比如说</p><ul><li>C/C++/Go可以编译出一个可执行文件，<code>./app</code>来启动</li><li>Java通过JDK<code>java</code>命令启动，<code>java APP</code></li></ul><p>但是，管理大型项目时，未必会是简单的<code>./app</code>这样就可以启动的，我们有可能会需要传入许多选项和参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./<span class="built_in">exec</span> -option1 -option2 arg1</span><br><span class="line"></span><br><span class="line">./app -debug -entryPoint 3000</span><br></pre></td></tr></table></figure><p>而这些选项和参数又有可能依赖于更高级的输入，比如说配置文件，环境变量等等</p><p>这时，就是自动化启动脚本登场的时候了，通过从高层输入（比如文件，环境变量）抽取出选项和参数，最终自动形成启动命令</p><h2 id="自动化启动脚本导致的问题"><a href="#自动化启动脚本导致的问题" class="headerlink" title="自动化启动脚本导致的问题"></a>自动化启动脚本导致的问题</h2><p>在各大IDE中，想要使用Debug功能，需要提供的正是<strong>最终启动命令</strong>，也就是上文的<code>./app -debug -entryPoint 3000</code>这种</p><p>否则IDE无法调用调试器连接调试端口，也就无法实现单步调试，变量检查等功能了</p><p>但是要想从自动化脚本和当下的高层输入一起来推算出最终启动命令，可能是一件比较困难或者至少是麻烦的事情（复杂的自动化启动脚本可能本身就有上百行）</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在自动化脚本启动最终命令之前，将最终命令打印出来。</p><p>这样，我们就只需要执行一次自动化脚本，而后将打印出来的最终命令提供给IDE，就可以开启Debug模式了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章介绍了作者在使用和编写自定义启动脚本时感受到的一个需要注意的点，简单来说，就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一定要打印出事实上的最终启动命令&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue中为对象添加字段</title>
    <link href="https://rivers-shall.github.io/2020/05/27/Vue%E4%B8%AD%E4%B8%BA%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5/"/>
    <id>https://rivers-shall.github.io/2020/05/27/Vue中为对象添加字段/</id>
    <published>2020-05-27T13:09:18.000Z</published>
    <updated>2020-06-01T10:43:19.589Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用Vue.js，并且在前端中为对象添加字段时遇到的坑点。</p><a id="more"></a><h2 id="场景与问题"><a href="#场景与问题" class="headerlink" title="场景与问题"></a>场景与问题</h2><p>从后端拿到数据之后，可能为了渲染时的方便，想要在对象里添加一些字段，而后直接在渲染时引用</p><p>直观上实现这种功能可以直接使用原生的js语法，抽象出来，可以用如下的代码段表示(为了复制就可以演示，没有组件化)</p><p>但是如下代码是有问题的，<code>obj.newField</code>不能被渲染出来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            &#123;&#123; obj.newField &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        let app = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">            el: "#app",</span></span><br><span class="line"><span class="undefined">            data : &#123;</span></span><br><span class="line"><span class="undefined">                obj : &#123;&#125;,</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            created() &#123;</span></span><br><span class="line"><span class="undefined">                obj.newField = "newData"</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正确的做法是使用<code>Vue.set</code>，因为在<a href="https://cn.vuejs.org/v2/api/#Vue-set" target="_blank" rel="noopener">Vue的官方文档</a>里有如下的表述</p><blockquote><p>因为 Vue 无法探测普通的新增 property (比如 this.myObject.newProperty = ‘hi’)</p></blockquote><p>所以上述代码应该改成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            &#123;&#123; obj.newField &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        let app = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">            el: "#app",</span></span><br><span class="line"><span class="undefined">            data : &#123;</span></span><br><span class="line"><span class="undefined">                obj : &#123;&#125;,</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            created() &#123;</span></span><br><span class="line"><span class="undefined">                Vue.set(obj, "newField", "newData")</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用Vue.js，并且在前端中为对象添加字段时遇到的坑点。&lt;/p&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Vue" scheme="https://rivers-shall.github.io/tags/Vue/"/>
    
  </entry>
  
</feed>
