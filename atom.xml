<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>碧漾的自我</title>
  
  <subtitle>beyond myself</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rivers-shall.github.io/"/>
  <updated>2020-06-23T09:36:36.238Z</updated>
  <id>https://rivers-shall.github.io/</id>
  
  <author>
    <name>碧漾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang json 多次Unmarshal至map/struct的坑</title>
    <link href="https://rivers-shall.github.io/2020/06/23/golang-json-%E5%A4%9A%E6%AC%A1Unmarshal%E8%87%B3map%E7%9A%84%E5%9D%91/"/>
    <id>https://rivers-shall.github.io/2020/06/23/golang-json-多次Unmarshal至map的坑/</id>
    <published>2020-06-23T09:13:29.000Z</published>
    <updated>2020-06-23T09:36:36.238Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍的是作者在使用golang的json库时发现的一个坑点，简单来说:</p><ul><li>当json库Unmarshal到map或者struct中时，并不会默认将<code>[]byte</code>中没有提供的字段置为零值</li></ul><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在服务中有配置以json形式存在于远程配置中心，需要不断拉取配置并Unmarshal到本地配置结构体中</p><p>但是在修改配置，进行功能验证的时候，发现部分配置的删除没有生效</p><p>最终排查发现是被删除的配置项是一个<code>map[string]string</code>，在多次Unmarshal时，map不会被清除，只会加入，导致了问题</p><h2 id="简单复现"><a href="#简单复现" class="headerlink" title="简单复现"></a>简单复现</h2><p>经过试验，发现除了map，对于struct也有同样的问题，且无论是官方json库还是第三方库，都有存在这样的问题</p><p>实验代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    jsoniter <span class="string">"github.com/json-iterator/go"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">    Str  <span class="keyword">string</span> <span class="string">`json:"str"`</span></span><br><span class="line">    Str2 <span class="keyword">string</span> <span class="string">`json:"str2"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    b1 := <span class="string">`&#123; "key1" : "value1", "key2" : "value2" &#125;`</span></span><br><span class="line">    jsoniter.Unmarshal([]<span class="keyword">byte</span>(b1), &amp;m)</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">    <span class="comment">// 仅仅添加了&lt;key3, value3&gt;，没有清除前面的两个kv对</span></span><br><span class="line">    b2 := <span class="string">`&#123; "key3" : "value3"&#125;`</span></span><br><span class="line">    jsoniter.Unmarshal([]<span class="keyword">byte</span>(b2), &amp;m)</span><br><span class="line">    fmt.Println(m)</span><br><span class="line"></span><br><span class="line">    t := test&#123;&#125;</span><br><span class="line">    s1 := <span class="string">`&#123;"str" :"s"&#125;`</span></span><br><span class="line">    jsoniter.Unmarshal([]<span class="keyword">byte</span>(s1), &amp;t)</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, t)</span><br><span class="line">    <span class="comment">// 仅仅将Str2字段置为s2，没有将Str字段置为空字符串</span></span><br><span class="line">    s2 := <span class="string">`&#123;"str2" : "s2"&#125;`</span></span><br><span class="line">    jsoniter.Unmarshal([]<span class="keyword">byte</span>(s2), &amp;t)</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其打印结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map[key1:value1 key2:value2]</span><br><span class="line">map[key1:value1 key2:value2 key3:value3]</span><br><span class="line">&#123;Str:s Str2:&#125;</span><br><span class="line">&#123;Str:s Str2:s2&#125;</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>对于map或者struct，如果存在多次Unmarshal的情况，需要在Unmarshal之前手动清空</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍的是作者在使用golang的json库时发现的一个坑点，简单来说:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当json库Unmarshal到map或者struct中时，并不会默认将&lt;code&gt;[]byte&lt;/code&gt;中没有提供的字段置为零值&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>star-history源码阅读笔记(04)-github-buttons</title>
    <link href="https://rivers-shall.github.io/2020/06/19/star-history%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-04-github-buttons/"/>
    <id>https://rivers-shall.github.io/2020/06/19/star-history源码阅读笔记-04-github-buttons/</id>
    <published>2020-06-19T09:34:12.000Z</published>
    <updated>2020-06-19T09:55:28.626Z</updated>
    
    <content type="html"><![CDATA[<p>本文是<a href="https://github.com/timqian/star-history" target="_blank" rel="noopener">star-history项目</a>源码阅读的第四篇文章，会包含:</p><ul><li>github button介绍与使用</li></ul><p>本次对代码的分析基于 <a href="https://github.com/timqian/star-history/commit/dca63d05369886573843839c08722d93a96cb047" target="_blank" rel="noopener">commit dca63d05369886573843839c08722d93a96cb047</a></p><a id="more"></a><h2 id="github-button"><a href="#github-button" class="headerlink" title="github button"></a>github button</h2><p>所谓的Github Button，可以认为是一种前端组件，效果如下，这个是<code>twbs/bootstrap</code>的star button</p><iframe src="https://ghbtns.com/github-btn.html?user=twbs&repo=bootstrap&type=star&count=true&size=large" frameborder="0" scrolling="0" width="170" height="30" title="GitHub"></iframe><p>Github Button主要有两个作用:</p><ul><li>展示数据<ul><li>根据类型的不同，展示star数，fork数，watch数等等</li></ul></li><li>点击后跳转到对应的Github仓库页面</li></ul><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>由于这样的Github Button使用非常广泛，所以已经有很多的开源库提供了这一组件功能</p><p>star-history仓库中使用的是<a href="https://github.com/mdo/github-buttons" target="_blank" rel="noopener">mdo/github-buttons</a></p><p>使用方式也非常简单，只要在需要的界面插入一个HTML标签，在属性<code>src</code>中填上对应的参数就可以了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://ghbtns.com/github-btn.html?user=twbs&amp;repo=bootstrap&amp;type=star&amp;count=true&amp;size=large"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">scrolling</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"170"</span> <span class="attr">height</span>=<span class="string">"30"</span> <span class="attr">title</span>=<span class="string">"GitHub"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时，还有许多开源项目提供了和Vue, Angular等前端框架相适用的组件，也可以试试</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是&lt;a href=&quot;https://github.com/timqian/star-history&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;star-history项目&lt;/a&gt;源码阅读的第四篇文章，会包含:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github button介绍与使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次对代码的分析基于 &lt;a href=&quot;https://github.com/timqian/star-history/commit/dca63d05369886573843839c08722d93a96cb047&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;commit dca63d05369886573843839c08722d93a96cb047&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
      <category term="star-history源码阅读笔记" scheme="https://rivers-shall.github.io/categories/star-history%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Github" scheme="https://rivers-shall.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>star-history源码阅读笔记(03)-include bundle.js</title>
    <link href="https://rivers-shall.github.io/2020/06/18/star-history%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-03-include-bundle-js/"/>
    <id>https://rivers-shall.github.io/2020/06/18/star-history源码阅读笔记-03-include-bundle-js/</id>
    <published>2020-06-18T08:19:21.000Z</published>
    <updated>2020-06-19T09:35:35.547Z</updated>
    
    <content type="html"><![CDATA[<p>本文是<a href="https://github.com/timqian/star-history" target="_blank" rel="noopener">star-history项目</a>源码阅读的第三篇文章，会包含:</p><ul><li>项目仓库中是否需要保存被构建文件的讨论</li></ul><p>简单来说:</p><ul><li>为了项目仓库的整洁，一般不保存被构建文件</li><li>如果有项目本身不是非常复杂，有展示需求且构建文件为跨平台文件，可以考虑直接保存在项目仓库中</li></ul><p>本次对代码的分析基于 <a href="https://github.com/timqian/star-history/commit/cb4d5828d5147df1d3db79ce728e6fb1f088e38b" target="_blank" rel="noopener">commit cb4d5828d5147df1d3db79ce728e6fb1f088e38b</a></p><a id="more"></a><h2 id="gitignore的改变"><a href="#gitignore的改变" class="headerlink" title="gitignore的改变"></a>gitignore的改变</h2><p>在<a href="https://github.com/timqian/star-history/commit/cb4d5828d5147df1d3db79ce728e6fb1f088e38b" target="_blank" rel="noopener">这个commit</a>中，做出的唯一改变就是将<code>bundle.js</code>从<code>.gitignore</code>中删除了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit remove</span><br><span class="line">- # Built by webpack</span><br><span class="line">- bundle.js</span><br></pre></td></tr></table></figure><p>这就意味着，以后的仓库中可以存储webpack构建的<code>bundle.js</code></p><h3 id="构建文件一般不会放置在代码仓库中"><a href="#构建文件一般不会放置在代码仓库中" class="headerlink" title="构建文件一般不会放置在代码仓库中"></a>构建文件一般不会放置在代码仓库中</h3><p>但是我们知道，对于这一类的构建文件，一般是不会直接存放在代码仓库中的</p><p>就好像用C/C++编写的项目，却把可执行文件放到了仓库里，或者Java编写的项目，却把Jar文件放到了仓库里</p><p>这违背了<strong>代码</strong>仓库的原则</p><h3 id="正常的做法"><a href="#正常的做法" class="headerlink" title="正常的做法"></a>正常的做法</h3><p>正常情况下，被构建文件当然可以公开，但是一般是以</p><ul><li>发布(Release)</li></ul><p>的方式进行公开，Github本身也提供了<a href="https://help.github.com/en/enterprise/2.13/user/articles/creating-releases" target="_blank" rel="noopener">产品发布</a>的<br>功能</p><p>比如C/C++编写，那么就将不同平台下编译好的可执行文件分别发布，Java编写的项目就考虑将Jar/War文件发布</p><h3 id="这里操作的合理性"><a href="#这里操作的合理性" class="headerlink" title="这里操作的合理性"></a>这里操作的合理性</h3><p>但是star-history选择了直接将构建文件放置在代码仓库里，我觉得是出于以下考虑:</p><ul><li>项目本身较小，处于起步阶段，还没有达到版本发布的级别</li><li>但是希望感兴趣的用户在下载了源代码后无需额外操作(安装webpack并构建)，立刻能够使用web app</li><li>Javascript代码仅依赖于浏览器，直接发布，不会有平台问题</li></ul><p>以上，有时我会觉得我<a href="https://zh.moegirl.org/zh-hans/%E5%A4%A7%E5%B8%88%E6%95%88%E5%BA%94" target="_blank" rel="noopener">迪化</a>了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是&lt;a href=&quot;https://github.com/timqian/star-history&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;star-history项目&lt;/a&gt;源码阅读的第三篇文章，会包含:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目仓库中是否需要保存被构建文件的讨论&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了项目仓库的整洁，一般不保存被构建文件&lt;/li&gt;
&lt;li&gt;如果有项目本身不是非常复杂，有展示需求且构建文件为跨平台文件，可以考虑直接保存在项目仓库中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次对代码的分析基于 &lt;a href=&quot;https://github.com/timqian/star-history/commit/cb4d5828d5147df1d3db79ce728e6fb1f088e38b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;commit cb4d5828d5147df1d3db79ce728e6fb1f088e38b&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
      <category term="star-history源码阅读笔记" scheme="https://rivers-shall.github.io/categories/star-history%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="git" scheme="https://rivers-shall.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>star-history源码阅读笔记(02)-搜索栏+大图的HTML与CSS排版</title>
    <link href="https://rivers-shall.github.io/2020/06/17/star-history%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-02-%E6%90%9C%E7%B4%A2%E6%A0%8F-%E5%A4%A7%E5%9B%BE%E7%9A%84HTML%E4%B8%8ECSS%E6%8E%92%E7%89%88/"/>
    <id>https://rivers-shall.github.io/2020/06/17/star-history源码阅读笔记-02-搜索栏-大图的HTML与CSS排版/</id>
    <published>2020-06-17T11:44:13.000Z</published>
    <updated>2020-06-18T08:21:22.240Z</updated>
    
    <content type="html"><![CDATA[<p>本文是<a href="https://github.com/timqian/star-history" target="_blank" rel="noopener">star-history项目</a>源码阅读的第二篇文章，会包含:</p><ul><li>搜索栏+大图的HTML与CSS排版</li></ul><p>本次对代码的分析基于Commit - <a href="https://github.com/timqian/star-history/tree/deecd92097809f39cd0ccd521b85ad54ac8fad24" target="_blank" rel="noopener">first commit deecd92 timqian</a></p><a id="more"></a><h2 id="项目页面排版"><a href="#项目页面排版" class="headerlink" title="项目页面排版"></a>项目页面排版</h2><p>在<a href="https://github.com/timqian/star-history/tree/deecd92097809f39cd0ccd521b85ad54ac8fad24" target="_blank" rel="noopener">这个commit</a>上，项目的外观还不是很美观，但是已经具备了一种模式，那就是”搜索栏+大图”的模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------------------------------------+</span><br><span class="line">|                   |search input|||search button|               |</span><br><span class="line">+----------------------------------------------------------------+</span><br><span class="line">|                                                                |</span><br><span class="line">|                                                                |</span><br><span class="line">|                                                                |</span><br><span class="line">|                                                                |</span><br><span class="line">|                           svg picture                          |</span><br><span class="line">|                                                                |</span><br><span class="line">|                                                                |</span><br><span class="line">|                                                                |</span><br><span class="line">|                                                                |</span><br><span class="line">|                                                                |</span><br><span class="line">|                                                                |</span><br><span class="line">+----------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="排版的HTML与CSS实现"><a href="#排版的HTML与CSS实现" class="headerlink" title="排版的HTML与CSS实现"></a>排版的HTML与CSS实现</h2><p>首先，我们可以看到整个页面被分做了两块，一块是搜索栏，另一块是svg图片(用于展示star历史)，也就是</p><ul><li>搜索栏<ul><li>搜索输入栏</li><li>搜索点击按钮</li></ul></li><li>svg图片</li></ul><p>项目使用的HTML结构则是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了界面的美观，当然还会使用CSS，这里选取一些比较重要的属性设置进行注解</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    # text-align使得input和button居中显示</span><br><span class="line">    <span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>,</span><br><span class="line">    # 设置背景色</span><br><span class="line">    <span class="selector-tag">background-color</span>: <span class="selector-tag">rgba</span>(46, 137, 216, 0<span class="selector-class">.88</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">    # 形状</span><br><span class="line">    <span class="selector-tag">width</span>: 350<span class="selector-tag">px</span>;</span><br><span class="line">    <span class="selector-tag">height</span>: 23<span class="selector-tag">px</span>;</span><br><span class="line">    # 字体大小</span><br><span class="line">    <span class="selector-tag">font-size</span>: 15<span class="selector-tag">pt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    # 原生文字格式</span><br><span class="line">    <span class="selector-tag">text-decoration</span>: <span class="selector-tag">none</span>;</span><br><span class="line">    # 文字居中</span><br><span class="line">    <span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</span><br><span class="line">    # 文字大小</span><br><span class="line">    <span class="selector-tag">font-size</span>: 16<span class="selector-tag">pt</span>;</span><br><span class="line">    # 背景色</span><br><span class="line">    <span class="selector-tag">background-color</span>: <span class="selector-id">#01A94C</span>;</span><br><span class="line">    # 字体色</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-tag">white</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是&lt;a href=&quot;https://github.com/timqian/star-history&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;star-history项目&lt;/a&gt;源码阅读的第二篇文章，会包含:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;搜索栏+大图的HTML与CSS排版&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次对代码的分析基于Commit - &lt;a href=&quot;https://github.com/timqian/star-history/tree/deecd92097809f39cd0ccd521b85ad54ac8fad24&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;first commit deecd92 timqian&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
      <category term="star-history源码阅读笔记" scheme="https://rivers-shall.github.io/categories/star-history%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="HTML" scheme="https://rivers-shall.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://rivers-shall.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>webpack教程02-webpack-dev-server是什么与webpack-dev-server命令行使用</title>
    <link href="https://rivers-shall.github.io/2020/06/16/webpack%E6%95%99%E7%A8%8B02-webpack-dev-server%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%8Ewebpack-dev-server%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://rivers-shall.github.io/2020/06/16/webpack教程02-webpack-dev-server是什么与webpack-dev-server命令行使用/</id>
    <published>2020-06-16T07:37:30.000Z</published>
    <updated>2020-06-16T12:05:20.844Z</updated>
    
    <content type="html"><![CDATA[<p>本文是webpack教程的第二篇文章，会介绍:</p><ul><li>webpack-dev-server的概念和作用</li><li>webpack-dev-server的基本命令行使用和一个坑点</li></ul><p>本次相关代码在<a href="https://github.com/Rivers-Shall/webpack-demo/commit/bbaea1bca75a4e6870b42d993e490415f8f4f253" target="_blank" rel="noopener">Github仓库 commit bbaea1bc</a></p><a id="more"></a><h2 id="webpack-dev-server的概念与作用"><a href="#webpack-dev-server的概念与作用" class="headerlink" title="webpack-dev-server的概念与作用"></a>webpack-dev-server的概念与作用</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>webpack-dev-server，顾名思义，这是一个<strong>server</strong>，也就是说，<code>webpack-dev-server</code>命令能够用来启动一个本地服务器，接受HTTP请求</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h4 id="不使用webpack-dev-server的场景"><a href="#不使用webpack-dev-server的场景" class="headerlink" title="不使用webpack-dev-server的场景"></a>不使用webpack-dev-server的场景</h4><p>在上一次的教程中，我们是采用直接打开<code>index.html</code>文件的方式来查看我们web app的实现效果</p><p>但是，这样的话我们的浏览器地址栏中会是<code>file://path/to/index.html</code></p><p>也就是说，使用的协议是<em>文件协议</em>，并不会发起HTTP请求，只会从本地文件系统将文件加载到浏览器里</p><p>这样的话，我们就无法使用很多HTTP协议特性，无法使用也就无法测试，调试，对开发工作有很大的阻碍</p><h4 id="使用webpack-dev-server"><a href="#使用webpack-dev-server" class="headerlink" title="使用webpack-dev-server"></a>使用webpack-dev-server</h4><p>通过webpack-dev-server，我们能够直接启动一个简易的服务器，通过这个服务器，可以使用HTTP协议进行web app的效果测试</p><p>除此之外，还能够实现许多额外的功能，比如热加载(一旦修改项目文件，就自动重新加载服务器)</p><h2 id="webpack-dev-server的基本命令行使用和一个坑点"><a href="#webpack-dev-server的基本命令行使用和一个坑点" class="headerlink" title="webpack-dev-server的基本命令行使用和一个坑点"></a>webpack-dev-server的基本命令行使用和一个坑点</h2><h3 id="基本命令行使用"><a href="#基本命令行使用" class="headerlink" title="基本命令行使用"></a>基本命令行使用</h3><p>想要从webpack转向webpack-dev-server是比较简单的，因为webpack-dev-server兼容了webpack所有的命令行选项</p><p>这也是很合理的，因为webpack-dev-server基本上就是”webpack打包 + 启动简易服务器”</p><p>所以我尝试直接将npm配置中的<code>webpack</code>命令修改为<code>webpack-dev-server</code>命令</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"build": "webpack-dev-server ./js/app.js -o bundle.js --mode development"</span><br></pre></td></tr></table></figure><p>而后<code>npm run build</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm run build</span><br><span class="line"> ｢wds｣: Project is running at http://localhost:8081/</span><br><span class="line"> ｢wds｣: webpack output is served from /</span><br><span class="line"> ｢wds｣: Content not from webpack is served from /path/to/working-dir</span><br></pre></td></tr></table></figure><p>打开<code>localhost:8081</code>，发现代码运行正常，且浏览器使用的是HTTP协议</p><h3 id="一个坑点"><a href="#一个坑点" class="headerlink" title="一个坑点"></a>一个坑点</h3><h4 id="坑点总结"><a href="#坑点总结" class="headerlink" title="坑点总结"></a>坑点总结</h4><ol><li><code>webpack-dev-server</code>不会在文件系统中生成打包后的文件，而是直接将文件加载到内存里</li><li>对于打包后的文件，默认会放置在host的<code>/</code>路径下，需要配置<code>publicPath</code>来自定义host路径</li></ol><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>但是，当我希望将生成的<code>bundle.js</code>放入固定文件夹<code>dist</code>时，问题出现了</p><p>npm配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"build": "webpack-dev-server ./js/app.js -o ./dist/bundle.js --mode development"</span><br></pre></td></tr></table></figure><p>HTML文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- .... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是在打开<code>localhost:8081</code>之后，代码运行异常(按钮不起作用)，console报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://localhost:8081/dist/bundle.js net::ERR_ABORTED 404 (Not Found)</span><br></pre></td></tr></table></figure><p>这说明<code>dist/bundle.js</code>没有能被加载，且磁盘上没有<code>dist/bundle.js</code>文件生成</p><p>查看<code>npm run build</code>的日志输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm run build</span><br><span class="line">ℹ ｢wds｣: Project is running at http://localhost:8081/</span><br><span class="line">ℹ ｢wds｣: webpack output is served from /</span><br><span class="line">ℹ ｢wds｣: Content not from webpack is served from</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ℹ ｢wds｣: webpack output is served from /</span><br></pre></td></tr></table></figure><p>这一行比较引人注意，因为<code>dist/bundle.js</code>正是<code>webpack output</code></p><p>于是我访问了<code>localhost:8081/bundle.js</code>，发现可以正常访问</p><p>于是去webpack的官网文档中寻找解决方案，在<a href="https://webpack.js.org/guides/development/#using-webpack-dev-server" target="_blank" rel="noopener">这个文档</a>上找到了这么一个提示</p><blockquote><p>webpack-dev-server doesn’t write any output files after compiling. Instead, it keeps bundle files in memory and serves them as if they were real files mounted at the server’s root path. If your page expects to find the bundle files on a different path, you can change this with the publicPath option in the dev server’s configuration.</p></blockquote><p>对于配置文件，我们需要指定<code>publicPath</code></p><p>对于webpack-dev-server CLI，我们需要指定<code>output-public-path</code>，所以将npm配置修改为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"build": "webpack-dev-server ./js/app.js -o ./dist/bundle.js --output-public-path /dist/  --mode development"</span><br></pre></td></tr></table></figure><p>代码运行就可以恢复正常，<code>localhost:8081/dist/bundle.js</code>也可以正常访问</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是webpack教程的第二篇文章，会介绍:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;webpack-dev-server的概念和作用&lt;/li&gt;
&lt;li&gt;webpack-dev-server的基本命令行使用和一个坑点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次相关代码在&lt;a href=&quot;https://github.com/Rivers-Shall/webpack-demo/commit/bbaea1bca75a4e6870b42d993e490415f8f4f253&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github仓库 commit bbaea1bc&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
      <category term="webpack教程" scheme="https://rivers-shall.github.io/categories/webpack%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="webpack" scheme="https://rivers-shall.github.io/tags/webpack/"/>
    
      <category term="webpack-dev-server" scheme="https://rivers-shall.github.io/tags/webpack-dev-server/"/>
    
  </entry>
  
  <entry>
    <title>CORS与CSRF</title>
    <link href="https://rivers-shall.github.io/2020/06/15/CORS%E4%B8%8ECSRF/"/>
    <id>https://rivers-shall.github.io/2020/06/15/CORS与CSRF/</id>
    <published>2020-06-15T12:15:26.000Z</published>
    <updated>2020-06-15T12:44:19.032Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章介绍了CORS和CSRF的概念(<del>作者前几天在和带佬们聊天的时候把两个概念搞混了，所以才想要了解</del>)，简单来说:</p><ul><li>CORS(Cross Origin Resource Sharing)跨域资源分享 是一种机制，通过在HTTP响应头中加入特定字段限制不同域的资源请求</li><li>CSRF(Cross Site Request Forgery)跨站请求伪造 是一种web攻击手段，通过向服务器发送伪造请求，进行恶意行为的攻击手段</li></ul><a id="more"></a><h2 id="CORS-Cross-Origin-Resource-Sharing-跨域资源分享"><a href="#CORS-Cross-Origin-Resource-Sharing-跨域资源分享" class="headerlink" title="CORS(Cross Origin Resource Sharing)跨域资源分享"></a>CORS(Cross Origin Resource Sharing)跨域资源分享</h2><h3 id="什么是域与跨域"><a href="#什么是域与跨域" class="headerlink" title="什么是域与跨域"></a>什么是域与跨域</h3><p>在讨论跨域之前，我们需要知道<strong>域</strong>是什么</p><blockquote><p>域是(scheme, host, port)三元组，也就是协议+主机+端口</p></blockquote><p>只要上述三者中有任何一个不同，就说是两个<strong>不同的域</strong></p><p>在web app中，经常会有一个站点请求另一个站点的资源的情况，比如</p><ul><li>前端App运行在<code>localhost:3000</code>上</li><li>后端App运行在<code>localhost:8080</code>上</li><li>前端调用<code>axios</code>向后端发起API请求，也就是<code>localhost:3000</code>到<code>localhost:8080</code>的请求</li><li>这样的请求就是<strong>跨域请求</strong></li></ul><h3 id="CORS-跨域资源分享-的目的和实现思想"><a href="#CORS-跨域资源分享-的目的和实现思想" class="headerlink" title="CORS(跨域资源分享)的目的和实现思想"></a>CORS(跨域资源分享)的目的和实现思想</h3><p>因为服务器方不希望随便一个什么域都能够想自己发送请求，或者通过请求获取资源，所以想出了CORS机制进行限制</p><p>首先我们细数一下一个web app进行请求的过程:</p><ul><li>app发起请求</li><li>浏览器收到app发起的请求，将真正的网络请求发到另外的站点上</li><li>浏览器收到站点的响应</li><li>浏览器将响应交给app处理</li></ul><p>CORS的实现思想就是在请求过程中做手脚，达到限制站点发送请求或者接受响应的目的</p><h3 id="CORS对于普通HTTP请求的修改"><a href="#CORS对于普通HTTP请求的修改" class="headerlink" title="CORS对于普通HTTP请求的修改"></a>CORS对于普通HTTP请求的修改</h3><p>所谓<strong>普通HTTP请求</strong>，就是指GET这种请求</p><p>HTTP协议认为GET应该只会从服务器获取资源，不会对服务器本身数据做出改变，所以基本上是安全的</p><p>原先请求的流程被修改为:</p><ul><li>app发起请求</li><li>浏览器收到app发起的请求，将真正的网络请求发到另外的站点上</li><li>浏览器收到站点的响应</li><li>浏览器检查响应头是否允许当前域执行GET请求<ul><li>如不允许，就报错并丢弃数据</li><li>如果允许，浏览器将响应交给app处理</li></ul></li></ul><p>所以浏览器是在<strong>执行请求之后</strong>进行了检查和限制</p><h3 id="CORS对于preflight请求的修改"><a href="#CORS对于preflight请求的修改" class="headerlink" title="CORS对于preflight请求的修改"></a>CORS对于preflight请求的修改</h3><p>preflight请求，指的是POST这种会对服务器本身数据做出改变的请求，很可能会造成严重恶意后果</p><p>原先请求的流程修改为:</p><ul><li>app发起请求</li><li>浏览器收到app发起的请求(比如POST)，先发送一个正常请求(OPTIONS请求)到目标站点上</li><li>收到响应后，检查响应头是否允许当前站点向目标站点发起POST请求，<ul><li>如果允许，将真正的网络请求发到另外的站点上<ul><li>浏览器收到站点的响应</li><li>浏览器将数据交给app处理</li></ul></li><li>如果不允许，直接报错</li></ul></li></ul><p>所以浏览器是在<strong>执行请求之前</strong>进行了检查和限制</p><h2 id="CSRF-Cross-Site-Request-Forgery-跨站请求伪造"><a href="#CSRF-Cross-Site-Request-Forgery-跨站请求伪造" class="headerlink" title="CSRF(Cross Site Request Forgery)跨站请求伪造"></a>CSRF(Cross Site Request Forgery)跨站请求伪造</h2><p>CSRF是一种攻击手段，CORS的一个重要作用就是防范CSRF</p><p>由于我们的浏览器只是个发送请求的<strong>代发工具人</strong>，所以服务器收到请求时，并不能知道请求是如何被制造出来的</p><p>那么可以有这样的场景:</p><ul><li>我要上<a href="http://www.aabbcc.com网站" target="_blank" rel="noopener">www.aabbcc.com网站</a></li><li>结果点到了<a href="http://www.aabbccc.com网站" target="_blank" rel="noopener">www.aabbccc.com网站</a></li><li>我输入了<a href="http://www.aabbcc.com的用户名和密码" target="_blank" rel="noopener">www.aabbcc.com的用户名和密码</a></li><li><a href="http://www.aabbccc.com利用我输入的用户名密码向www.aabbcc.com的服务器地址(假设为123.123.123.123:3000)发送恶意请求" target="_blank" rel="noopener">www.aabbccc.com利用我输入的用户名密码向www.aabbcc.com的服务器地址(假设为123.123.123.123:3000)发送恶意请求</a></li></ul><p>这样就是<code>www.aabbccc.com</code>伪造了<code>www.aabbcc.com</code>的请求，并发送了，这就是CSRF(跨站请求伪造)</p><p>但是如果我们有CORS，在<code>123.123.123.123:3000</code>的响应头中指出只有<code>www.aabbcc.com</code>可以发送请求过来，那么<code>www.aabbccc.com</code>发送的请求就会被CORS和浏览器协作清除掉，<code>www.aabbccc.com</code>也就无法恶意攻击了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章介绍了CORS和CSRF的概念(&lt;del&gt;作者前几天在和带佬们聊天的时候把两个概念搞混了，所以才想要了解&lt;/del&gt;)，简单来说:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CORS(Cross Origin Resource Sharing)跨域资源分享 是一种机制，通过在HTTP响应头中加入特定字段限制不同域的资源请求&lt;/li&gt;
&lt;li&gt;CSRF(Cross Site Request Forgery)跨站请求伪造 是一种web攻击手段，通过向服务器发送伪造请求，进行恶意行为的攻击手段&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
    
      <category term="CORS" scheme="https://rivers-shall.github.io/tags/CORS/"/>
    
      <category term="CSRF" scheme="https://rivers-shall.github.io/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法复习-02-链表</title>
    <link href="https://rivers-shall.github.io/2020/06/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0-02-%E9%93%BE%E8%A1%A8/"/>
    <id>https://rivers-shall.github.io/2020/06/15/数据结构与算法复习-02-链表/</id>
    <published>2020-06-15T08:50:16.000Z</published>
    <updated>2020-06-15T12:16:07.599Z</updated>
    
    <content type="html"><![CDATA[<p>本文是数据结构与算法复习的第二篇博文，复习</p><ul><li>链表的概念</li><li>常见的链表类型和设计取舍</li><li>链表的反转操作</li></ul><a id="more"></a><h2 id="链表的概念"><a href="#链表的概念" class="headerlink" title="链表的概念"></a>链表的概念</h2><p>链表可以定义为:</p><ul><li>空</li><li>拥有一个节点，该节点有两个属性<ul><li>val，本节点的值</li><li>next，另一个链表</li></ul></li></ul><p>首先，这个定义是单链表的定义，但是双向链表也是类似的</p><p>其次，从这个定义可以看到，链表是可以递归定义的</p><h2 id="常见的链表类型和设计取舍"><a href="#常见的链表类型和设计取舍" class="headerlink" title="常见的链表类型和设计取舍"></a>常见的链表类型和设计取舍</h2><p>比较常见的链表类型有</p><ul><li>单链表</li><li>双向链表</li></ul><p>所谓的设计取舍主要是考虑:</p><ul><li>选择单链表还是双向链表？</li><li>是否需要卫士节点(sentinel node)?</li></ul><h3 id="单链表与双向链表"><a href="#单链表与双向链表" class="headerlink" title="单链表与双向链表"></a>单链表与双向链表</h3><p>双向链表与单链表的区别就在于</p><ul><li>单链表每个节点只有一个next指向额外的链表(也就是后继元素)</li><li>双链表每个节点有两个属性指向额外的链表(也就是前驱和后继)</li></ul><p>所以双向链表的使用更加灵活</p><h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><p>对于单链表和双链表的选择，主要是考虑两点:</p><ul><li>空间，双链表由于多了一个属性，消耗空间更多</li><li>时间，这里是指<ul><li>如果有访问前驱节点的需求，可以考虑<ul><li>双链表</li><li>如果需要访问的前驱结点是固定的，比如固定是前一个节点或者前两个节点<ul><li>就可以直接使用额外的一个节点指针进行存储</li></ul></li></ul></li></ul></li></ul><h3 id="是否需要卫士节点"><a href="#是否需要卫士节点" class="headerlink" title="是否需要卫士节点"></a>是否需要卫士节点</h3><p>卫士节点就是指</p><blockquote><p>对于任意的链表，都向其中添加一个无用的节点，使得链表不会是0节点的链表</p></blockquote><p>是否需要卫士节点主要是看个人的使用习惯</p><ul><li>使用卫士节点可以在一定程度上规避空指针的问题<ul><li>毕竟链表中一定会有节点</li></ul></li><li>但是会多出一个节点的空间消耗，且编程逻辑和无卫士节点的编程逻辑不同(<del>废话，当然不同</del>)</li></ul><h2 id="链表的翻转操作"><a href="#链表的翻转操作" class="headerlink" title="链表的翻转操作"></a>链表的翻转操作</h2><p>链表考的最多的就是翻转(淡然还有单链表的快排，不过那个可以留到排序的时候再说)</p><p>链表的翻转有两种实现:</p><ul><li>循环实现</li><li>递归实现</li></ul><p>其实就是逻辑烦了点，实在不行代码背下来</p><h3 id="循环实现链表翻转"><a href="#循环实现链表翻转" class="headerlink" title="循环实现链表翻转"></a>循环实现链表翻转</h3><p>如下代码的关键在于循环的不变式</p><blockquote><p>每次循环开始前,<code>head</code>指向的是还未反转的链表头，<code>prev</code>指向的是已经反转的链表头</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val, ListNode next) &#123; <span class="keyword">this</span>.val = val; <span class="keyword">this</span>.next = next; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>, next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归实现链表翻转"><a href="#递归实现链表翻转" class="headerlink" title="递归实现链表翻转"></a>递归实现链表翻转</h3><p>以下代码的关键在于函数声明</p><blockquote><p><code>reverseList(headA, headB)</code>会将<code>headA</code>的链表反转，然后将<code>headB</code>的链表拼接到反转的<code>headA</code>链表后</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reverseList(head, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode next = headA.next;</span><br><span class="line">        headA.next = headB;</span><br><span class="line">        <span class="keyword">return</span> reverseList(next, headA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是数据结构与算法复习的第二篇博文，复习&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表的概念&lt;/li&gt;
&lt;li&gt;常见的链表类型和设计取舍&lt;/li&gt;
&lt;li&gt;链表的反转操作&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
      <category term="数据结构与算法复习" scheme="https://rivers-shall.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="data structure" scheme="https://rivers-shall.github.io/tags/data-structure/"/>
    
      <category term="union-find" scheme="https://rivers-shall.github.io/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法复习(01)-并查集</title>
    <link href="https://rivers-shall.github.io/2020/06/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0-01-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://rivers-shall.github.io/2020/06/12/数据结构与算法复习-01-并查集/</id>
    <published>2020-06-12T13:42:58.000Z</published>
    <updated>2020-06-15T08:49:43.583Z</updated>
    
    <content type="html"><![CDATA[<p>本文是数据结构预算法复习系列的第一篇博文，会介绍写作该系列博文的原因</p><p>本文复习了并查集的概念，基础的API，良好的实现(路径压缩与权重)，简单的应用和变式</p><p><a href="https://github.com/Rivers-Shall/DS-Algo-Review/tree/master/Union-Find" target="_blank" rel="noopener">相关代码</a></p><a id="more"></a><h2 id="写作本篇博文的原因"><a href="#写作本篇博文的原因" class="headerlink" title="写作本篇博文的原因"></a>写作本篇博文的原因</h2><ol><li>生活所迫<ol><li>懂的都懂，IT行业从业者(或者是考研保研)，跑不了的</li></ol></li><li>数据结构与算法是大学生活里花费的时间很多的部分，复习一下，也算是对自己的大学生涯有个交代</li><li>三次元的生活真的无聊，找点代码写，嘿嘿(<del>难道不能写工程项目吗？质问！</del>)</li></ol><h2 id="并查集的概念与基础API"><a href="#并查集的概念与基础API" class="headerlink" title="并查集的概念与基础API"></a>并查集的概念与基础API</h2><h3 id="并查集的概念"><a href="#并查集的概念" class="headerlink" title="并查集的概念"></a>并查集的概念</h3><p>假设拥有N个元素1…N，我们需要对其做两种基础的操作:</p><ol><li>宣告某两个元素a, b处在同一个等价类里</li><li>判断某两个元素a, b是否在一个等价类里</li></ol><p>用于处理这种问题，提供这两种操作接口的数据结构，可以被称为并查集</p><h3 id="并查集基础的API"><a href="#并查集基础的API" class="headerlink" title="并查集基础的API"></a>并查集基础的API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="良好的实现"><a href="#良好的实现" class="headerlink" title="良好的实现"></a>良好的实现</h3><p>良好的实现往往将一个等价类以<strong>树</strong>的形式进行组织，使用一个数组<code>int[] parent</code>，<code>parent[i]</code>记录了元素<code>i</code>的父亲节点</p><p>如下图</p><p><img src="union-find-tree.png" alt="union find tree"></p><ul><li><code>isConnected(a, b)</code>接口即判断<code>a</code>和<code>b</code>是否在同一棵树内(是否有同样的根)</li><li><code>union(a, b)</code>接口即需要将<code>a</code>所属的树归并到<code>b</code>所属的树下，或者将<code>b</code>所属的树归并到<code>a</code>所属的树下</li><li>提高执行速度，就是想办法降低树的高度</li></ul><h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>路径压缩基本上能够完全解决并查集的接口执行速度问题</p><p>其基本思想是:</p><blockquote><p>在沿着某条路径查询到<code>a</code>元素的根之后，将这条路径上所有的元素父亲，都直接设为根节点<br>这样，在以后查询的时候，查找到这条路径上的元素，只需要一次向上查询，就可以找到根节点了</p></blockquote><h5 id="路径压缩实现"><a href="#路径压缩实现" class="headerlink" title="路径压缩实现"></a>路径压缩实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathCompressUnionFindImpl</span> <span class="keyword">implements</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathCompressUnionFindImpl</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.length; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[a] == a) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[a] = find(parent[a]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = find(a), rootB = find(b);</span><br><span class="line">        parent[rootA] = rootB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(a) == find(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="加权并查集"><a href="#加权并查集" class="headerlink" title="加权并查集"></a>加权并查集</h4><p>虽然路径压缩基本能够解决并查集的执行速度问题，但是还有一个解决方案值得我们思考</p><p>加权并查集，其实是基于这样的观察:</p><blockquote><p>在代表一个等价类的树的高度快速增长时，往往是由于将高的树合并成为了矮的树的子树<br>如果每次合并，都将矮的树合并成为高的树的子树，那么树的高度增长就会减缓</p></blockquote><p>从数学的角度来看，减缓的原因是</p><blockquote><p>每次当树的高度增加1，就意味着树的节点总数至少翻倍了<br>那么一共有N个节点，树的高度最多也就是lg N</p></blockquote><h5 id="加权并查集实现"><a href="#加权并查集实现" class="headerlink" title="加权并查集实现"></a>加权并查集实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedUnionFindImpl</span> <span class="keyword">implements</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent, size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[a] != a) &#123;</span><br><span class="line">            a = parent[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeightedUnionFindImpl</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootA = find(a), rootB = find(b);</span><br><span class="line">        <span class="keyword">if</span> (size[rootA] &gt; size[rootB]) &#123;</span><br><span class="line">            parent[rootB] = rootA;</span><br><span class="line">            size[rootA] += size[rootB];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootA] = rootB;</span><br><span class="line">            size[rootB] += size[rootA];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(a) == find(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集的简单应用"><a href="#并查集的简单应用" class="headerlink" title="并查集的简单应用"></a>并查集的简单应用</h3><p>贴两道OJ题目，都是简单练手的</p><p><a href="https://www.luogu.com.cn/problem/P3367" target="_blank" rel="noopener">洛谷P3367 模板题</a><br><a href="https://www.luogu.com.cn/problem/UVA10583" target="_blank" rel="noopener">洛谷UVA10583 简单变式</a></p><h3 id="并查集的简单变式"><a href="#并查集的简单变式" class="headerlink" title="并查集的简单变式"></a>并查集的简单变式</h3><h4 id="等价类的个数"><a href="#等价类的个数" class="headerlink" title="等价类的个数"></a>等价类的个数</h4><p>也就是树的根节点的个数，一个节点<code>a</code>是根节点当且仅当<code>parent[a] == a</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nClass = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parent.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[i] == i) &#123;</span><br><span class="line">            nClass++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可以维护的等价类性质"><a href="#可以维护的等价类性质" class="headerlink" title="可以维护的等价类性质"></a>可以维护的等价类性质</h4><p>比如:</p><ul><li>给定元素<code>a</code>，求<code>a</code>所在等价类的元素个数</li><li>给定元素<code>a</code>，求<code>a</code>所在等价类的最大值</li><li>给定元素<code>a</code>，求<code>a</code>所在等价类的最小值</li></ul><p>这类性质只需要新开一个数组，并在<code>union</code>时进行维护就可以了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    parent[rootA] = rootB;</span><br><span class="line">    size[rootB] += size[rootA];</span><br><span class="line">    maximum[rootB] = Math.max(maximum[rootA], maximum[rootB]);</span><br><span class="line">    minimum[rootB] = Math.max(minimum[rootA], minimum[rootB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是数据结构预算法复习系列的第一篇博文，会介绍写作该系列博文的原因&lt;/p&gt;
&lt;p&gt;本文复习了并查集的概念，基础的API，良好的实现(路径压缩与权重)，简单的应用和变式&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Rivers-Shall/DS-Algo-Review/tree/master/Union-Find&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;相关代码&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
      <category term="数据结构与算法复习" scheme="https://rivers-shall.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="data structure" scheme="https://rivers-shall.github.io/tags/data-structure/"/>
    
      <category term="union-find" scheme="https://rivers-shall.github.io/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>webpack教程01-webpack是什么与webpack命令行使用</title>
    <link href="https://rivers-shall.github.io/2020/06/11/webpack%E6%95%99%E7%A8%8B01-webpack%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%8Ewebpack%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://rivers-shall.github.io/2020/06/11/webpack教程01-webpack是什么与webpack命令行使用/</id>
    <published>2020-06-11T07:20:01.000Z</published>
    <updated>2020-06-11T10:45:28.751Z</updated>
    
    <content type="html"><![CDATA[<p>本文是webpack教程的第一篇文章，会介绍</p><ul><li>创作这个系列教程的原因</li><li>webpack是什么<ul><li>构建工具</li></ul></li><li>webpack CLI(命令行交互)的基本使用<ul><li><code>webpack &lt;入口文件&gt; -o &lt;目标文件&gt; --mode &lt;模式&gt;</code></li><li><code>webpack --config &lt;配置文件&gt;</code></li></ul></li><li>webpack CLI与npm结合使用<ul><li><code>scripts</code>添加与<code>npm run build</code></li></ul></li></ul><p>涉及到的代码有<a href="https://github.com/Rivers-Shall/webpack-demo/tree/45285d4873a2b62c4e5808d158aa6dfe9b71bf14" target="_blank" rel="noopener">不使用webpack版本</a>，<a href="https://github.com/Rivers-Shall/webpack-demo/tree/44a3c5436a1b85916a23a37d6903865df2437026" target="_blank" rel="noopener">使用webpack和npm版本</a><br><a id="more"></a></p><h2 id="创作这个系列教程的原因"><a href="#创作这个系列教程的原因" class="headerlink" title="创作这个系列教程的原因"></a>创作这个系列教程的原因</h2><ul><li>webpack是一个应用广泛的构建系统<ul><li>尽管现在各个框架，各个公司都有发展使用自己的构建系统(脚手架)的趋势，比如vue-cli</li><li>但是webpack仍然具有着很高的适用性和可扩展性</li><li>其接口和使用方式的设计也很值得学习</li></ul></li><li>把三次元的时间尽！数！挥！霍！</li></ul><h2 id="webpack是什么"><a href="#webpack是什么" class="headerlink" title="webpack是什么"></a>webpack是什么</h2><p>前面提到，webpack是一个构建系统，这究竟意味着什么呢？我们先来看webpack官网上的图</p><p><img src="webpack.png" alt="webpack"></p><p>我们可以看到:</p><ul><li>左边是<strong>杂乱的，拥有复杂依赖的</strong>项目文件</li><li>右边是<strong>整齐的，无依赖的，生成的</strong>独立文件</li></ul><p>所以webpack是构建系统的含义:</p><blockquote><p>根据项目文件中提供的依赖关系，自动构建整齐的独立文件</p></blockquote><h2 id="webpack-CLI-命令行交互-的基本使用"><a href="#webpack-CLI-命令行交互-的基本使用" class="headerlink" title="webpack CLI(命令行交互)的基本使用"></a>webpack CLI(命令行交互)的基本使用</h2><p>先贴一下<a href="https://webpack.js.org/api/cli/" target="_blank" rel="noopener">webpack CLI的官网文档</a></p><h3 id="一个不使用webpack的项目版本"><a href="#一个不使用webpack的项目版本" class="headerlink" title="一个不使用webpack的项目版本"></a>一个不使用webpack的项目版本</h3><p>为了体现使用webpack的优势，我们先准备一个不使用webpack的项目版本 <a href="https://github.com/Rivers-Shall/webpack-demo/tree/45285d4873a2b62c4e5808d158aa6dfe9b71bf14" target="_blank" rel="noopener">webpack-demo init commit</a></p><p>这个项目实现的功能是: 点击按钮，下方的文字会出现或者消失</p><p>我们可以看到，<code>index.html</code>中引用了两个js文件:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/dom-loader.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两个引用的顺序是不可改变的，如果改变，那么按钮就会失效</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>这样搭建的web项目，需要我们手动去关注引用的代码顺序，<ul><li>demo项目中只有两个js文件，但是如果真实的项目中，或许会有数十个js文件，那时还要不断处理引用顺序，就会很头疼</li></ul></li><li>js代码的修改，可能需要额外修改html代码<ul><li>如果引用顺序改变，就必须修改引用js代码的html代码，修改的地方变多</li></ul></li></ul><p>缺点其实还有很多，比如后期引入Sass这种扩展CSS，或者Babel这种JS转译器，都需要手动引入和管理，非常麻烦，webpack会帮我们完成这些管理，当然，这些内容稍后再介绍，先看最基础的使用</p><h3 id="使用webpack-CLI构建文件"><a href="#使用webpack-CLI构建文件" class="headerlink" title="使用webpack CLI构建文件"></a>使用webpack CLI构建文件</h3><p>我们首先使用如下命令安装webpack和webpack-cli(当然，项目需要使用<code>npm init</code>初始化，需要安装<code>node.js</code>和<code>npm</code>):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --save-dev</span><br></pre></td></tr></table></figure><p>在使用webpack之前，我们需要明白，webpack是<strong>根据源代码中的依赖关系</strong>进行构建的</p><p>那么，我们就必须在源代码中对依赖关系进行声明</p><p>声明的方式是ES6的<code>import, export</code>语法</p><blockquote><p>注意: 这里使用ES6的<code>import, export</code>语法只是因为webpack可以识别它们，在项目中使用其他的ES6语法仍然会导致兼容性问题，关于如何将ES6或更新的语法转化为ES5语法，后续教程会涉及</p></blockquote><p>所以我们对源代码作出修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dom-loader.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">"#toggle-button"</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> graph = <span class="built_in">document</span>.querySelector(<span class="string">"#toggled-graph"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;button, graph&#125; <span class="keyword">from</span> <span class="string">"./dom-loader"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>声明了依赖关系之后，就需要使用webpack构建文件了，为了构建，我们需要指定两类文件以及模式</p><ol><li>入口文件<ol><li>webpack会从这个文件开始分析依赖关系，将所有涉及的文件进行打包</li></ol></li><li>目标文件<ol><li>webpack会将构建出的文件保存到目标文件上</li></ol></li><li>构建模式<ol><li>不提供的话默认是<code>production</code>，但是会报Warning</li><li>开发阶段使用<code>development</code>就好</li><li>二者的一个主要区别是<code>production</code>会<em>最小化</em>文件，导致整个文件没有多余的空白符，可读性为0</li></ol></li></ol><p>而后使用webpack CLI</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; webpack &lt;入口文件&gt; -o &lt;目标文件&gt; --mode &lt;模式&gt;</span><br></pre></td></tr></table></figure><p>在这里，就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack ./js/app.js -o bundle.js --mode development</span><br></pre></td></tr></table></figure><p>webpack就会直接生成<code>bundle.js</code></p><p>而在<code>index.html</code>中，我们只需要引入这一个<code>bundle.js</code>就可以了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;script src="js/dom-loader.js"&gt;&lt;/script&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;script src="js/app.js"&gt;&lt;/script&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="webpack与配置文件"><a href="#webpack与配置文件" class="headerlink" title="webpack与配置文件"></a>webpack与配置文件</h3><p>webpack CLI可以使用命令行参数的方式运作，也可以使用配置文件的方式运作</p><p>不过配置文件的书写方式涉及到webpack许多核心概念，下次再说，这里先放上指定配置文件的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; webpack --config &lt;配置文件&gt;</span><br></pre></td></tr></table></figure><h2 id="webpack-CLI与npm结合使用"><a href="#webpack-CLI与npm结合使用" class="headerlink" title="webpack CLI与npm结合使用"></a>webpack CLI与npm结合使用</h2><p>使用webpack原生命令比较繁琐，也没有办法记录在项目文件中，可以使用npm的scripts列表进行管理</p><p>在<code>package.json</code>中添加scripts</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"demo for webpack"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"app.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    # 添加 script</span><br><span class="line">    "build": "webpack ./js/app.js -o bundle.js --mode development"</span><br><span class="line">  &#125;,</span><br><span class="line">  "author": "rivers-shall",</span><br><span class="line">  "license": "ISC",</span><br><span class="line">  "devDependencies": &#123;</span><br><span class="line">    "webpack": "^4.43.0",</span><br><span class="line">    "webpack-cli": "^3.3.11"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后我们只需要:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; npm run build</span><br></pre></td></tr></table></figure><p>就可以便捷使用webpack构建文件了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是webpack教程的第一篇文章，会介绍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创作这个系列教程的原因&lt;/li&gt;
&lt;li&gt;webpack是什么&lt;ul&gt;
&lt;li&gt;构建工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;webpack CLI(命令行交互)的基本使用&lt;ul&gt;
&lt;li&gt;&lt;code&gt;webpack &amp;lt;入口文件&amp;gt; -o &amp;lt;目标文件&amp;gt; --mode &amp;lt;模式&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;webpack --config &amp;lt;配置文件&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;webpack CLI与npm结合使用&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scripts&lt;/code&gt;添加与&lt;code&gt;npm run build&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;涉及到的代码有&lt;a href=&quot;https://github.com/Rivers-Shall/webpack-demo/tree/45285d4873a2b62c4e5808d158aa6dfe9b71bf14&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不使用webpack版本&lt;/a&gt;，&lt;a href=&quot;https://github.com/Rivers-Shall/webpack-demo/tree/44a3c5436a1b85916a23a37d6903865df2437026&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用webpack和npm版本&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
      <category term="webpack教程" scheme="https://rivers-shall.github.io/categories/webpack%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="webpack" scheme="https://rivers-shall.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>star-history源码阅读笔记(01)-项目介绍,Github的stargazers接口与分页机制，获取star历史的思路</title>
    <link href="https://rivers-shall.github.io/2020/06/09/star-history%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-01-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D-Github%E7%9A%84stargazers%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/"/>
    <id>https://rivers-shall.github.io/2020/06/09/star-history源码阅读笔记-01-项目介绍-Github的stargazers接口与分页机制/</id>
    <published>2020-06-09T08:20:00.000Z</published>
    <updated>2020-06-11T02:35:03.274Z</updated>
    
    <content type="html"><![CDATA[<p>本文是<a href="https://github.com/timqian/star-history" target="_blank" rel="noopener">star-history项目</a>源码阅读的第一篇文章，会包含:</p><ul><li>作者对项目的介绍，这个系列博文的目的</li><li>Github的stargazers接口</li><li>Github接口的分页策略</li><li>获取star历史的思路</li></ul><p>本次对代码的分析基于Commit - <a href="https://github.com/timqian/star-history/tree/deecd92097809f39cd0ccd521b85ad54ac8fad24" target="_blank" rel="noopener">first commit deecd92 timqian</a></p><a id="more"></a><h2 id="项目的介绍与系列博文的目的"><a href="#项目的介绍与系列博文的目的" class="headerlink" title="项目的介绍与系列博文的目的"></a>项目的介绍与系列博文的目的</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>首先说明，本文作者并非项目作者，各种介绍和分析，如有不当，还请谅解。</p><p><a href="https://github.com/timqian/star-history" target="_blank" rel="noopener">star-history项目</a>(<a href="https://star-history.t9t.io/" target="_blank" rel="noopener">体验地址</a>)是一个用于统计github项目获得star历史的组件，包括web app网页版本和chrome extension版本</p><p>产生这个项目的原因，是Github官方并没有提供查看项目star历史的功能</p><h3 id="博文目的"><a href="#博文目的" class="headerlink" title="博文目的"></a>博文目的</h3><ul><li>留作知识沉淀<ul><li>从体验界面来看，前端效果和功能都很不错，希望学习一下</li></ul></li><li>将我三次元的时间，尽！情！挥！霍！</li></ul><h2 id="Github的stargazers接口"><a href="#Github的stargazers接口" class="headerlink" title="Github的stargazers接口"></a>Github的stargazers接口</h2><p>Github官方提供了一系列REST API(现在有向graphql上迁移的趋势)，通过REST API，可以获得许多Github上的信息，以此为基础，我们可以构建各式各样的APP，star-history这个项目也是这样建立起来的</p><p>Github虽然没有提供直接查看项目star历史的功能，但是却提供了<a href="https://developer.github.com/v3/activity/starring/" target="_blank" rel="noopener">stargazers接口</a>，这个接口有两种形式</p><ol><li>查看star了一个项目的所有用户</li><li>同上，并且加入该用户star该项目的时间</li></ol><p>这二者共用同一个rest url，不同的是：</p><blockquote><p>方法2需要在HTTP请求头中加入<code>Accept: application/vnd.github.v3.star+json</code></p></blockquote><p>其rest url和返回的json格式分别是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">GET /repos/:owner/:repo/stargazers</span><br><span class="line"># 没有时间</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"login"</span>: <span class="string">"octocat"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"node_id"</span>: <span class="string">"MDQ6VXNlcjE="</span>,</span><br><span class="line">    <span class="attr">"avatar_url"</span>: <span class="string">"https://github.com/images/error/octocat_happy.gif"</span>,</span><br><span class="line">    <span class="attr">"gravatar_id"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://api.github.com/users/octocat"</span>,</span><br><span class="line">    <span class="attr">"html_url"</span>: <span class="string">"https://github.com/octocat"</span>,</span><br><span class="line">    <span class="attr">"followers_url"</span>: <span class="string">"https://api.github.com/users/octocat/followers"</span>,</span><br><span class="line">    <span class="attr">"following_url"</span>: <span class="string">"https://api.github.com/users/octocat/following&#123;/other_user&#125;"</span>,</span><br><span class="line">    <span class="attr">"gists_url"</span>: <span class="string">"https://api.github.com/users/octocat/gists&#123;/gist_id&#125;"</span>,</span><br><span class="line">    <span class="attr">"starred_url"</span>: <span class="string">"https://api.github.com/users/octocat/starred&#123;/owner&#125;&#123;/repo&#125;"</span>,</span><br><span class="line">    <span class="attr">"subscriptions_url"</span>: <span class="string">"https://api.github.com/users/octocat/subscriptions"</span>,</span><br><span class="line">    <span class="attr">"organizations_url"</span>: <span class="string">"https://api.github.com/users/octocat/orgs"</span>,</span><br><span class="line">    <span class="attr">"repos_url"</span>: <span class="string">"https://api.github.com/users/octocat/repos"</span>,</span><br><span class="line">    <span class="attr">"events_url"</span>: <span class="string">"https://api.github.com/users/octocat/events&#123;/privacy&#125;"</span>,</span><br><span class="line">    <span class="attr">"received_events_url"</span>: <span class="string">"https://api.github.com/users/octocat/received_events"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"User"</span>,</span><br><span class="line">    <span class="attr">"site_admin"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">GET /repos/:owner/:repo/stargazers</span><br><span class="line">Header:</span><br><span class="line">Accept: application/vnd.github.v3.star+json</span><br><span class="line"># 有star时间</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"starred_at"</span>: <span class="string">"2011-01-16T19:06:43Z"</span>,</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">      <span class="attr">"login"</span>: <span class="string">"octocat"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"node_id"</span>: <span class="string">"MDQ6VXNlcjE="</span>,</span><br><span class="line">      <span class="attr">"avatar_url"</span>: <span class="string">"https://github.com/images/error/octocat_happy.gif"</span>,</span><br><span class="line">      <span class="attr">"gravatar_id"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"url"</span>: <span class="string">"https://api.github.com/users/octocat"</span>,</span><br><span class="line">      <span class="attr">"html_url"</span>: <span class="string">"https://github.com/octocat"</span>,</span><br><span class="line">      <span class="attr">"followers_url"</span>: <span class="string">"https://api.github.com/users/octocat/followers"</span>,</span><br><span class="line">      <span class="attr">"following_url"</span>: <span class="string">"https://api.github.com/users/octocat/following&#123;/other_user&#125;"</span>,</span><br><span class="line">      <span class="attr">"gists_url"</span>: <span class="string">"https://api.github.com/users/octocat/gists&#123;/gist_id&#125;"</span>,</span><br><span class="line">      <span class="attr">"starred_url"</span>: <span class="string">"https://api.github.com/users/octocat/starred&#123;/owner&#125;&#123;/repo&#125;"</span>,</span><br><span class="line">      <span class="attr">"subscriptions_url"</span>: <span class="string">"https://api.github.com/users/octocat/subscriptions"</span>,</span><br><span class="line">      <span class="attr">"organizations_url"</span>: <span class="string">"https://api.github.com/users/octocat/orgs"</span>,</span><br><span class="line">      <span class="attr">"repos_url"</span>: <span class="string">"https://api.github.com/users/octocat/repos"</span>,</span><br><span class="line">      <span class="attr">"events_url"</span>: <span class="string">"https://api.github.com/users/octocat/events&#123;/privacy&#125;"</span>,</span><br><span class="line">      <span class="attr">"received_events_url"</span>: <span class="string">"https://api.github.com/users/octocat/received_events"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"User"</span>,</span><br><span class="line">      <span class="attr">"site_admin"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Github接口的分页策略"><a href="#Github接口的分页策略" class="headerlink" title="Github接口的分页策略"></a>Github接口的分页策略</h2><p>对于stargazers接口，一个仓库很可能有数万甚至数十万个用户star过，如果我们在一次请求<br><code>GET /repos/:owner/:repo/stargazers</code><br>中，就将所有的信息全部都拿出来，会导致:</p><ul><li>网络IO和内存IO负荷过大</li><li>不灵活，也许有些接口调用方并不想要全部的数据，只想要部分的，这样的请求IO就全部浪费了</li></ul><p>为此，Github的很多API都引入了分页机制</p><p>分页机制中，比较重要的有几点：</p><ul><li>如何知道一个url的资源被分成了多少页？</li><li>如何知道目前是哪一页？</li><li>如何知道一个url的资源在一页上有多少个？</li><li>如何获取一个url任意一页的资源？</li></ul><p>我们先来看看Github的REST API是如何接受和提供分页信息的</p><h3 id="接受分页信息"><a href="#接受分页信息" class="headerlink" title="接受分页信息"></a>接受分页信息</h3><p>对于每一个url，我们可以在后面加上<code>page</code>和<code>per_page</code>参数:</p><ul><li><code>per_page</code>参数指定了一页上有多少个资源<ul><li>这个参数可以没有，不同的url接口会有不同的默认值，有的是30，有的是100，具体靠阅读文档</li><li>并不是所有的url接口都接受这个参数，有些url接口不接受，具体靠阅读文档</li></ul></li><li><code>page</code>参数指定了需要拿哪一页的资源</li></ul><h3 id="提供分页信息"><a href="#提供分页信息" class="headerlink" title="提供分页信息"></a>提供分页信息</h3><p>在HTTP响应中，Github接口加入一个响应头<code>Link</code>，这个响应头的样式大概是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 注意这个请求没有加上page参数，也能获得Link响应头</span><br><span class="line">GET https://api.github.com/search/code?q=addClass+user%3Amozilla</span><br><span class="line"></span><br><span class="line"># HTTP响应的响应头</span><br><span class="line">Link: &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=15&gt;; rel=&quot;next&quot;,</span><br><span class="line">  &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=34&gt;; rel=&quot;last&quot;,</span><br><span class="line">  &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=1&gt;; rel=&quot;first&quot;,</span><br><span class="line">  &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=13&gt;; rel=&quot;prev&quot;</span><br></pre></td></tr></table></figure><p>其中<code>rel</code>表示的是url和当前url的关系:</p><ul><li><code>prev</code>，前一页的url</li><li><code>next</code>，下一页的url</li><li><code>last</code>，最后一页的url，也就是总页数</li><li><code>first</code>，第一页的url</li></ul><h3 id="疑问的解答"><a href="#疑问的解答" class="headerlink" title="疑问的解答"></a>疑问的解答</h3><p>所以我们之前的数个疑问就可以得到解答</p><ul><li>如何知道一个url的资源被分成了多少页？<ul><li>首先不带<code>page</code>参数进行请求，而后通过响应头，提取出<code>last</code>对应的url中的<code>page</code>参数即可</li></ul></li><li>如何知道目前是哪一页？<ul><li>当前url的<code>page</code>参数就是当前页数</li><li>响应头中的<code>next</code>对应的url中的<code>page</code>参数是下一页</li></ul></li><li>如何知道一个url的资源在一页上有多少个？<ul><li>查看文档，会有默认值</li><li>查看文档，如果url接口接受<code>per_page</code>参数，就可以自行设置(注意可能会有最大值限制)</li></ul></li><li>如何获取一个url任意一页的资源？<ul><li>加入<code>page</code>参数</li></ul></li></ul><h2 id="获取star历史的思路"><a href="#获取star历史的思路" class="headerlink" title="获取star历史的思路"></a>获取star历史的思路</h2><p>了解了Github的stargazers接口及分页策略，我们就可以来分析一下获取star历史的方法:</p><ol><li>调用stargazers接口，要带star日期的</li><li>根据star日期进行排序</li><li>统计出star发生改变的时间(也就是某个用户star了仓库的时间)和当时的star数目(就是排序后的索引值)</li><li>以改变的时间作为横轴，改变当时的star数目作为纵轴，绘制图像</li></ol><p>这样来看，基本上是没错的，但是还要考虑一点</p><blockquote><p>如果一个仓库有数千数万数十万star，我们就要绘制数千数万数十万的点吗？</p></blockquote><p>可以当然是可以的，但是这么做，对于高star的项目，内存和网络消耗过大，处理时间过长，项目初期，不利于我们开发和调试</p><p>所以我们可以利用分页机制进行<strong>取样</strong></p><p>比如，我们选定取样点数为20，那么，</p><ul><li>对于star数目不足20的项目，<ul><li>我们获取所有的信息，并绘制出所有的点</li></ul></li><li>对于star数目高于20的项目(假设star数为N)，<ul><li>我们获取0, N/20, 2N/20, 3N/20, …, N时的时间</li><li>然后以这二十个时间点和star数，绘制20个点即可</li></ul></li></ul><p>上面描述的是如何取样，那么<strong>取样</strong>与<strong>分页</strong>有什么关系呢？</p><p>那就是——我们不需要获取<em>总star数目</em>，我们只需要获取<em>总页数</em></p><ul><li>对于一个stargazers接口页数为N的项目<ul><li>我们获取0, N/20, 2N/20, 3N/20, …, N页上最早的时间</li><li>然后以这二十个时间点和star数(页编号 * 每页资源数目)，绘制20个点即可</li></ul></li></ul><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>事实上，项目代码中也是这么操作的(事实上刚才的思路是我从代码中倒推出来的，尬笑)</p><p><code>generateUrls.js</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getConfig = &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    Accept: <span class="string">'application/vnd.github.v3.star+json'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">repo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> initUrl = <span class="string">`https://api.github.com/repos/<span class="subst">$&#123;repo&#125;</span>/stargazers`</span>;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> axios.get(initUrl, getConfig).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表明我们使用的是stargazers的带时间的接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> link = res.headers.link;</span><br><span class="line"><span class="keyword">if</span> (!link) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> pageNumArray = <span class="regexp">/next.*?page=(\d*).*?last/</span>.exec(link);</span><br><span class="line">  <span class="keyword">const</span> pageNum = pageNumArray[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> samplePageUrls = [];</span><br><span class="line">  <span class="keyword">let</span> pageIndexes = [];</span><br><span class="line">  <span class="keyword">if</span> (pageNum &lt;= sampleNum) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= pageNum; i++) &#123;</span><br><span class="line">      pageIndexes.push(i);</span><br><span class="line">      samplePageUrls.push(initUrl + <span class="string">'?page='</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; sampleNum; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> pageIndex = <span class="built_in">Math</span>.round(i / sampleNum * pageNum);</span><br><span class="line">      pageIndexes.push(pageIndex);</span><br><span class="line">      samplePageUrls.push(initUrl + <span class="string">'?page='</span> + pageIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    samplePageUrls, pageIndexes,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这一段代码是通过响应头<code>Link</code>，使用正则表达式提取出总页数，然后取样<code>sampleNum</code>个点</p><p><code>getStarHistory.js</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">repo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    samplePageUrls, pageIndexes</span><br><span class="line">  &#125; = <span class="keyword">await</span> generateUrls(repo).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">// throw don't work</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getArray = samplePageUrls.map(<span class="function"><span class="params">url</span> =&gt;</span> axios.get(url, getConfig));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> resArray = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(getArray).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">// throw don't work</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> starHistory = pageIndexes.map(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      date: resArray[i].data[<span class="number">0</span>].starred_at.slice(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">      starNum: <span class="number">30</span> * (p - <span class="number">1</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(starHistory);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> starHistory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段代码，</p><ol><li>通过<code>generateUrls.js</code>的接口获取所有采样的url接口，而后进行请求</li><li>请求后获得每一页最小的时间，并把最小的时间和当页代表的star数组合起来返回</li></ol><p>这样，就得到了一个项目的star历史</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是&lt;a href=&quot;https://github.com/timqian/star-history&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;star-history项目&lt;/a&gt;源码阅读的第一篇文章，会包含:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作者对项目的介绍，这个系列博文的目的&lt;/li&gt;
&lt;li&gt;Github的stargazers接口&lt;/li&gt;
&lt;li&gt;Github接口的分页策略&lt;/li&gt;
&lt;li&gt;获取star历史的思路&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次对代码的分析基于Commit - &lt;a href=&quot;https://github.com/timqian/star-history/tree/deecd92097809f39cd0ccd521b85ad54ac8fad24&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;first commit deecd92 timqian&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
      <category term="star-history源码阅读笔记" scheme="https://rivers-shall.github.io/categories/star-history%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Github" scheme="https://rivers-shall.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>goland提取方法与...interface{}类型的注意点</title>
    <link href="https://rivers-shall.github.io/2020/06/08/goland%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E4%B8%8E-interface-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>https://rivers-shall.github.io/2020/06/08/goland提取方法与-interface-类型的注意点/</id>
    <published>2020-06-08T09:15:04.000Z</published>
    <updated>2020-06-08T11:50:33.943Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用goland提供的提取方法(Extract Method)功能时，由于<code>...interface{}</code>的类型问题而遭遇到的bug和一点感悟，简单来说:</p><ul><li>可变长的参数会被goland的Extract Method转化为切片(slice)，比如<code>...interface{}</code>会被转化为<code>[]interface{}</code></li><li>由于<code>interface{}</code>的特殊性，需要额外注意</li></ul><a id="more"></a><h2 id="bug的产生"><a href="#bug的产生" class="headerlink" title="bug的产生"></a>bug的产生</h2><p>在代码中有如下片段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在想要将循环提取出来，作为一个方法，在goland中可以直接选中文本然后Extract Method，但是结果是这样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ExtractedMethod(payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtractedMethod</span><span class="params">(payload []<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>期望中的函数签名是<code>ExtractedMethod(payload ...interface{})</code>，不符合预期，所以要进行修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG!!!!!!!!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ExtractedMethod(payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtractedMethod</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码不会有编译错误，但是是完全不符合预期的，为什么呢？</p><h2 id="bug的原因"><a href="#bug的原因" class="headerlink" title="bug的原因"></a>bug的原因</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG!!!!!!!!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// we need to unpack payload</span></span><br><span class="line">    ExtractedMethod(payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtractedMethod</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述注释所说，我们需要对<code>f</code>中传递给<code>ExtractedMethod</code>的参数<code>payload</code>做一个解包工作，因为</p><ul><li>我们<code>f</code>函数的本意是要用<code>ExtractedMehtod</code>对<code>payload</code>中的每一个元素做处理</li><li>现在不解包，<code>payload</code>原本一个<code>[]interface{}</code>又被<strong>额外自动包装了一层</strong>，成为了<code>interface{}</code>传递给了<code>ExtractedMethod</code>，只会对整个<code>payload</code>做一次处理</li></ul><h2 id="bug的解决与思考"><a href="#bug的解决与思考" class="headerlink" title="bug的解决与思考"></a>bug的解决与思考</h2><p>将代码修改为如下后正确</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ExtractedMethod(payload...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtractedMethod</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后可以采取的方法是，先将传参的地方<code>payload</code>改为<code>payload...</code>，这样的话如果忘记修改参数<code>[]interface{}</code>为<code>...interface{}</code>，是会有编译器报错的</p><p>这个修改顺序可以让编译器为我们保驾</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用goland提供的提取方法(Extract Method)功能时，由于&lt;code&gt;...interface{}&lt;/code&gt;的类型问题而遭遇到的bug和一点感悟，简单来说:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可变长的参数会被goland的Extract Method转化为切片(slice)，比如&lt;code&gt;...interface{}&lt;/code&gt;会被转化为&lt;code&gt;[]interface{}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;interface{}&lt;/code&gt;的特殊性，需要额外注意&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="goland" scheme="https://rivers-shall.github.io/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>常见的git工作流</title>
    <link href="https://rivers-shall.github.io/2020/06/07/%E5%B8%B8%E8%A7%81%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>https://rivers-shall.github.io/2020/06/07/常见的git工作流/</id>
    <published>2020-06-07T03:58:16.000Z</published>
    <updated>2020-06-07T05:18:53.805Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了作者了解到的三种常见的<em>单仓库</em>的git工作流，它们是:</p><ol><li>Centralized工作流<ul><li>仅使用master一个分支</li></ul></li><li>Feature Branch工作流<ul><li>使用一个master分支管理稳定版本</li><li>使用多个feature分支管理需求开发</li></ul></li><li>Gitflow工作流<ul><li>使用一个master分支管理发布版本历史</li><li>使用一个develop分支管理开发流程</li><li>使用多个feature分支管理需求开发</li><li>使用多个release分支管理版本发布</li><li>使用多个hotfix分支修复紧急bug</li></ul></li></ol><a id="more"></a><h2 id="Centralized工作流"><a href="#Centralized工作流" class="headerlink" title="Centralized工作流"></a>Centralized工作流</h2><p><img src="centralized-rebase.svg" alt="centralized"></p><p>这种工作流只使用唯一的master分支</p><h3 id="Centralized需求开发的过程"><a href="#Centralized需求开发的过程" class="headerlink" title="Centralized需求开发的过程"></a>Centralized需求开发的过程</h3><ul><li>拉取远端分支(pull/clone)</li><li>开发(add, commit)<ul><li>上图中的白色master</li></ul></li><li>再次拉取远端分支(fetch)<ul><li>上图中的紫色origin/master</li></ul></li><li>合入，处理冲突(rebase)<ul><li>上图中的蓝色master</li><li>注意这里不使用merge，merge会导致master分支出现类似新branch的分叉行为, 丢失了单分支的简洁性</li></ul></li><li>提交修改(push)</li></ul><h3 id="Centralized工作流优点"><a href="#Centralized工作流优点" class="headerlink" title="Centralized工作流优点"></a>Centralized工作流优点</h3><ul><li>简单，对于单人小项目，没有必要考虑太多管理的情况下直接使用，没有问题</li><li>和SVN的工作流非常相似，方便从SVN迁移到Git的团队做一段时间的缓冲</li></ul><h3 id="Centralized工作流缺点"><a href="#Centralized工作流缺点" class="headerlink" title="Centralized工作流缺点"></a>Centralized工作流缺点</h3><ul><li>太过简单，没有利用好Git的分支特性</li></ul><h2 id="Feature-Branch工作流"><a href="#Feature-Branch工作流" class="headerlink" title="Feature Branch工作流"></a>Feature Branch工作流</h2><p><img src="feature-branch.svg" alt="feature-branch"></p><p>对于这种工作流，开发者需要使用:</p><ul><li>一个master分支管理稳定版本</li><li>多个feature分支管理需求开发</li></ul><h3 id="Feature-Branch需求开发的过程"><a href="#Feature-Branch需求开发的过程" class="headerlink" title="Feature Branch需求开发的过程"></a>Feature Branch需求开发的过程</h3><ul><li>拉取远端分支(pull/clone)</li><li>从master新建feature分支(checkout -b feature/XXX)</li><li>开发(add, commit)</li><li>再次拉取远端分支(fetch)</li><li>合入，处理冲突(merge)<ul><li>注意这里需要的合入处理冲突是指将feature/XXX合入master，而不是将master合入feature/XXX</li><li>另外，merge的时候建议使用<code>--no-ff</code>，保证只产生一个merge commit，原因下面会讲</li></ul></li><li>提交修改(push)</li></ul><h3 id="Feature-Branch工作流优点"><a href="#Feature-Branch工作流优点" class="headerlink" title="Feature Branch工作流优点"></a>Feature Branch工作流优点</h3><p>该工作流相比于Centralized工作流，更加复杂，利用了Git分支的特性，相比之下，优点有:</p><ul><li>需求开发的管理更加清晰，有单独的分支</li><li>由于使用的是不同的分支，可以开启pull request和merge review，通过强制code review提高代码质量</li><li>需求分支合入master时，只会产生唯一的merge commit(如果merge的时候使用了<code>--no-ff</code>的话)，这样如果想要把一个feature revert掉，只需要revert唯一的一个commit，而不需要选出有关的commit一个个地revert</li></ul><h3 id="Feature-Branch工作流缺点"><a href="#Feature-Branch工作流缺点" class="headerlink" title="Feature Branch工作流缺点"></a>Feature Branch工作流缺点</h3><p>缺点/不足:</p><ul><li>没有专门用于版本发布的机制<ul><li>版本发布可能涉及到很多非开发的杂事(比如文档编写与生成，项目打包等等)，这些不适合作为feature来开发</li><li>在该工作流中，没有办法清晰看出哪些commit是发布的版本</li></ul></li><li>没有用于紧急修复bug的机制<ul><li>紧急bug修复，也不适合作为feature来开发</li></ul></li></ul><h2 id="Gitflow工作流"><a href="#Gitflow工作流" class="headerlink" title="Gitflow工作流"></a>Gitflow工作流</h2><p><img src="gitflow.svg" alt="gitflow"></p><p>这个工作流需要开发者:</p><ul><li>使用一个master分支管理发布版本历史</li><li>使用一个develop分支管理开发流程</li><li>使用多个feature分支管理需求开发</li><li>使用多个release分支管理版本发布</li><li>使用多个hotfix分支修复紧急bug</li></ul><h3 id="Gitflow需求开发流程-feature分支"><a href="#Gitflow需求开发流程-feature分支" class="headerlink" title="Gitflow需求开发流程(feature分支)"></a>Gitflow需求开发流程(feature分支)</h3><ul><li>拉取远端分支(pull/clone)</li><li>从develop分支开启新的feature分支(checkout -b feature/XXX)</li><li>开发(add, commit)</li><li>再次拉取远端分支(fetch)</li><li>合入，解决冲突(merge)</li><li>提交修改(push)</li></ul><p>这个流程和feature branch是一致的，只不过把base分支从master改为了develop</p><p>注意所有的feature分支都:</p><ul><li>从<strong>develop</strong>分支新建而来</li><li>合入到develop分支而去</li></ul><h3 id="Gitflow版本发布流程-release分支"><a href="#Gitflow版本发布流程-release分支" class="headerlink" title="Gitflow版本发布流程(release分支)"></a>Gitflow版本发布流程(release分支)</h3><ul><li>拉取远端分支(pull/clone)</li><li>从develop分支开启新的release分支(checkout -b release/XXX)</li><li>版本发布开发(add, commit)<ul><li>包括文档生成，打包等杂事</li><li>也可以修复小bug</li><li>但是大的改动必须使用需求开发流程，去新feature分支进行处理，并移动到下个版本上</li></ul></li><li>再次拉取远端分支(fetch)</li><li>合入，解决冲突(merge)<ul><li>这里，需要将release分支同时合入master和develop分支</li><li>合入master，是为了保存版本发布记录</li><li>合入develop，是为了后续开发能够兼容该版本<ul><li>比如说在release上修复了小bug，或者添加了文档注释等，都要反映到后续开发上</li></ul></li></ul></li><li>提交(push)</li></ul><p>注意所有的release分支都:</p><ul><li>从<strong>develop</strong>分支新建而来</li><li>合入到master和develop分支而去</li></ul><h3 id="Gitflow紧急修复bug流程"><a href="#Gitflow紧急修复bug流程" class="headerlink" title="Gitflow紧急修复bug流程"></a>Gitflow紧急修复bug流程</h3><ul><li>拉取远端分支(pull/clone)</li><li>从master分支新建hotfix分支(checkout -b hotfix/XXX)</li><li>开发，修复bug(add, commit)</li><li>再次拉取远端分支(fetch)</li><li>合入，解决冲突(merge)<ul><li>这里的合入需要同时合入master和develop，理由同release分支</li><li>但是理论上合入master分支的时候不应该有冲突，只能在合入develop分支的时候才会有可能冲突</li></ul></li><li>提交(push)</li></ul><p>注意所有的release分支都:</p><ul><li>从<strong>master</strong>分支新建而来</li><li>合入到master和develop分支而去</li></ul><h3 id="Gitflow工作流评价"><a href="#Gitflow工作流评价" class="headerlink" title="Gitflow工作流评价"></a>Gitflow工作流评价</h3><p>这里就不放优缺点了，因为Gitflow是目前使用最广，最为流行的git工作流</p><p>或许会有一些小的出入，但是各大公司基本上内部都会遵守这样的规则</p><p>大小项目，大小团队，都适用gitflow工作流</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了作者了解到的三种常见的&lt;em&gt;单仓库&lt;/em&gt;的git工作流，它们是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Centralized工作流&lt;ul&gt;
&lt;li&gt;仅使用master一个分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Feature Branch工作流&lt;ul&gt;
&lt;li&gt;使用一个master分支管理稳定版本&lt;/li&gt;
&lt;li&gt;使用多个feature分支管理需求开发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Gitflow工作流&lt;ul&gt;
&lt;li&gt;使用一个master分支管理发布版本历史&lt;/li&gt;
&lt;li&gt;使用一个develop分支管理开发流程&lt;/li&gt;
&lt;li&gt;使用多个feature分支管理需求开发&lt;/li&gt;
&lt;li&gt;使用多个release分支管理版本发布&lt;/li&gt;
&lt;li&gt;使用多个hotfix分支修复紧急bug&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
    
      <category term="git" scheme="https://rivers-shall.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>defer+recover保护gin不panic</title>
    <link href="https://rivers-shall.github.io/2020/06/04/defer-recover%E4%BF%9D%E6%8A%A4gin%E4%B8%8Dpanic/"/>
    <id>https://rivers-shall.github.io/2020/06/04/defer-recover保护gin不panic/</id>
    <published>2020-06-04T10:33:59.000Z</published>
    <updated>2020-06-04T10:51:31.819Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者保护gin构建的web app不panic的方式，简单来说：</p><ol><li>主程中的panic本身是会被gin拦截的</li><li>协程中的panic需要使用<code>defer</code>和<code>recover</code>进行保护</li></ol><a id="more"></a><h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>在我们用gin构建，运行web app并上线了之后，或许有一些请求会经过业务，在特定的情况下出发会触发golang中的<code>panic</code></p><p>按照golang的设定，一旦<code>panic</code>，如果不在函数调用栈中存在<code>recover</code>，那么是一定会使得整个程序终止的</p><p>但是线上的服务是不能够因为一个两个的请求就直接终止了的，这样非常危险，所以我们需要手段来阻止web app在<code>panic</code>的情况下直接终止</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="主程序中的panic"><a href="#主程序中的panic" class="headerlink" title="主程序中的panic"></a>主程序中的<code>panic</code></h3><p>对于gin这个web框架来说，主程序中的<code>panic</code>是会被自动<code>recover</code>的，还会打印出非常详细的日志信息，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/panic"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后我们作如下HTTP请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl localhost:8080/panic</span><br></pre></td></tr></table></figure><p>会发现在gin的运行窗口出现如下信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">2020/06/04 18:42:12 [Recovery] 2020/06/04 - 18:42:12 panic recovered:</span><br><span class="line">GET /panic HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: curl/7.64.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">panic</span><br><span class="line">/Users/admin/go/src/gin-test/main.go:10 (0x1581418)</span><br><span class="line">        main.func1: panic(<span class="string">"panic"</span>)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/context.go:165 (0x156baca)</span><br><span class="line">        (*Context).Next: c.handlers[c.index](c)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/recovery.go:83 (0x157fb13)</span><br><span class="line">        RecoveryWithWriter.func1: c.Next()</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/context.go:165 (0x156baca)</span><br><span class="line">        (*Context).Next: c.handlers[c.index](c)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/logger.go:241 (0x157ec40)</span><br><span class="line">        LoggerWithConfig.func1: c.Next()</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/context.go:165 (0x156baca)</span><br><span class="line">        (*Context).Next: c.handlers[c.index](c)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/gin.go:420 (0x1575d20)</span><br><span class="line">        (*Engine).handleHTTPRequest: c.Next()</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/gin.go:376 (0x157548c)</span><br><span class="line">        (*Engine).ServeHTTP: engine.handleHTTPRequest(c)</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/go/1.13.8/libexec/src/net/http/server.go:2802 (0x12cb6d3)</span><br><span class="line">        serverHandler.ServeHTTP: handler.ServeHTTP(rw, req)</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/go/1.13.8/libexec/src/net/http/server.go:1890 (0x12c6f74)</span><br><span class="line">        (*conn).serve: serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/go/1.13.8/libexec/src/runtime/asm_amd64.s:1357 (0x105c030)</span><br><span class="line">        goexit: BYTE    <span class="variable">$0x90</span>   // NOP</span><br><span class="line"></span><br><span class="line">[GIN] 2020/06/04 - 18:42:12 | 500 |    1.238546ms |             ::1 | GET      <span class="string">"/panic"</span></span><br></pre></td></tr></table></figure><p>并且整个app还在正常运行，没有终止，这非常好</p><h3 id="协程中的panic"><a href="#协程中的panic" class="headerlink" title="协程中的panic"></a>协程中的<code>panic</code></h3><p>不过非常可惜的是，对于协程中的<code>panic</code>，gin并不能做到自动<code>recover</code>并打印日志信息，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/go-panic"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该app之后，我们作如下的HTTP请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl localhost:8080/go-panic</span><br></pre></td></tr></table></figure><p>会发现gin app退出了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">panic: panic</span><br><span class="line"></span><br><span class="line">goroutine 24 [running]:</span><br><span class="line">main.main.func1.1()</span><br><span class="line">        /Users/admin/go/src/gin-test/main.go:11 +0x39</span><br><span class="line">created by main.main.func1</span><br><span class="line">        /Users/admin/go/src/gin-test/main.go:10 +0x35</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure><h4 id="协程解决方案"><a href="#协程解决方案" class="headerlink" title="协程解决方案"></a>协程解决方案</h4><p>所以，对于协程，我们要手动进行<code>defer</code>和<code>recover</code>，来避免app的退出和打印日志信息，比如上面的代码应该修改为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/go-panic"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    fmt.Printf(<span class="string">"error: %v\n"</span>, err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;()</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后我们像刚才一样进行HTTP请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl localhost:8080/go-panic</span><br></pre></td></tr></table></figure><p>会得到如下打印</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: panic</span><br><span class="line">[GIN] 2020/06/04 - 18:50:20 | 200 |       2.951µs |             ::1 | GET      <span class="string">"/go-panic"</span></span><br></pre></td></tr></table></figure><p>可以看到app正常响应了请求，并且没有退出并打印了日志，想要更多定制操作可以修改<code>defer</code>的函数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者保护gin构建的web app不panic的方式，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主程中的panic本身是会被gin拦截的&lt;/li&gt;
&lt;li&gt;协程中的panic需要使用&lt;code&gt;defer&lt;/code&gt;和&lt;code&gt;recover&lt;/code&gt;进行保护&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="gin" scheme="https://rivers-shall.github.io/tags/gin/"/>
    
  </entry>
  
  <entry>
    <title>oop大作业总结与从中看到的未来计划</title>
    <link href="https://rivers-shall.github.io/2020/06/04/oop%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%8E%E4%B8%AD%E7%9C%8B%E5%88%B0%E7%9A%84%E6%9C%AA%E6%9D%A5%E8%AE%A1%E5%88%92/"/>
    <id>https://rivers-shall.github.io/2020/06/04/oop大作业总结与从中看到的未来计划/</id>
    <published>2020-06-04T03:12:09.000Z</published>
    <updated>2020-06-04T08:37:43.540Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是在我完成了oop大作业之后，重新审视自己的开发流程与系统设计的一点总结与展望，简单来说：</p><ol><li>这是个”154/“(一无是处)的项目</li><li>好在能够让我感受到一些努力的方向</li></ol><p>代码就不开源了，实在太差了，就在这里口嗨一下就好</p><a id="more"></a><h2 id="存在的问题与未来的计划"><a href="#存在的问题与未来的计划" class="headerlink" title="存在的问题与未来的计划"></a>存在的问题与未来的计划</h2><h3 id="前端问题"><a href="#前端问题" class="headerlink" title="前端问题"></a>前端问题</h3><ol><li>没有对界面做任何的优化</li><li>没有任何的自动化测试，没有任何的后端分离的测试</li><li>模块化做的很差</li></ol><h4 id="没有对界面做任何的优化"><a href="#没有对界面做任何的优化" class="headerlink" title="没有对界面做任何的优化"></a>没有对界面做任何的优化</h4><p>CSS，是前端三大件中，我认为最复杂的一件，重点在于，CSS并不能被称为一门”编程语言”，应该来说，它是一门”设计用语”，在大学计算机科学中接触到的训练，可以说对CSS的学习是没有任何帮助的，这就导致即便看了很多CSS相关的资料，到了要实现界面效果的时候，还是会出现无从下手的情况</p><p>这次的大作业中，我几乎没有涉及到任何的CSS，只有在数个<code>div</code>需要并列做出类似column的效果时，使用了<code>display: inline-block</code>这样的属性设置，其他的我也想不到什么了</p><p>虽然离提交还有两三个星期，这个时间拿来上手一下element-ui之类的高层库，也是可能优化界面的，但是我觉得简约也是一种特色吧，另外，布置大作业时，长度不到一页纸的需求文档，我也没有太大的兴趣做出一个炫酷的界面，简约的界面反而和这样简约的需求很配呢</p><h4 id="没有任何的自动化测试，没有任何的后端分离测试"><a href="#没有任何的自动化测试，没有任何的后端分离测试" class="headerlink" title="没有任何的自动化测试，没有任何的后端分离测试"></a>没有任何的自动化测试，没有任何的后端分离测试</h4><p>前端的开发流程中，当然会需要测试</p><p>而我这次开发，测试的手段就是把后端服务起来，然后把前端dev-server起来，在界面上点来点去</p><p>这样子的效率低到令人发指，还需要后端的配合：</p><ol><li>点来点去，人傻了都</li><li>如果几次操作之间记忆出现错误，很有可能上一回测到的路径，这次又没有测到</li><li>如果后端接口没有准备好，前端就没有办法测试</li></ol><h4 id="模块化做的很差"><a href="#模块化做的很差" class="headerlink" title="模块化做的很差"></a>模块化做的很差</h4><p>前端的模块化一直以来都是问题挺大的，说实在的设计类要做出非常好的模块化也有点尴尬，另外一方面没有使用高层框架，也会使得模块化更加困难</p><p>首先，vue中的各个模组就已经出现了类似的结构，但是我并没有很好地方法来模块化，做的也有点烦躁</p><p>其次，前端存储和请求发送没有能够很好的模块化，尤其是请求发送模块，完全耦合在了vue的代码里，前端存储模块由于使用的是vuex框架，模块性还好一些，但是由于使用上经验不足，在引入到vue中的时候，出现了一些可读性较差的冗余代码</p><h3 id="前端未来的计划"><a href="#前端未来的计划" class="headerlink" title="前端未来的计划"></a>前端未来的计划</h3><ol><li>basic knowledge + code snippet 学习界面设计</li><li>了解前端的测试方式方法</li><li>了解好的前端架构与模块化开发方式</li></ol><h4 id="basic-knowledge-code-snippet-学习界面设计"><a href="#basic-knowledge-code-snippet-学习界面设计" class="headerlink" title="basic knowledge + code snippet 学习界面设计"></a>basic knowledge + code snippet 学习界面设计</h4><p>如何学习界面的设计？如何用CSS+JS或者高层框架实现设计？这两个问题，每个人都有不同的答案</p><p>我的答案是: basic knowledge + code snippet</p><h5 id="basic-knowledge"><a href="#basic-knowledge" class="headerlink" title="basic knowledge"></a>basic knowledge</h5><p>这就是指对CSS+JS或者高层框架的基础知识要了解，不需要深入，只要能够做到，看到代码，不会感到一头雾水，而是明白，这个属性/样式作用在了哪里，至于效果如何，怎么配置，知道去那里可以查文档就行</p><h5 id="code-snippet"><a href="#code-snippet" class="headerlink" title="code snippet"></a>code snippet</h5><p>这个才是重头戏，毕竟设计类的，只要不是强要求，大部分都可以通过修改他人的设计，而后达到自己的目的</p><p>所以平时要多积累：</p><ol><li>页面经典的布局(导航栏，登录界面，展示界面等)与实现代码</li><li>特殊的交互逻辑(固定在顶部的导航栏，顶部页面滑动进度显示等)与实现代码</li></ol><p>到时候自己想要做炫酷的功能，就直接去code snippet库里找一找，改一改就好</p><h4 id="了解前端的测试方式与方法"><a href="#了解前端的测试方式与方法" class="headerlink" title="了解前端的测试方式与方法"></a>了解前端的测试方式与方法</h4><p>最重要的几个问题：</p><ol><li>如何自动化？<ul><li>如何模拟鼠标，键盘等的交互操作？</li><li>如何验证测试结果？</li><li>前端JS逻辑代码如何测试？如何单元测试？</li></ul></li><li>如何与后端分离？<ul><li>如何模拟(mock)后端接口？</li><li>怎样设计</li></ul></li></ol><h4 id="了解好的前端架构与模块化开发方式"><a href="#了解好的前端架构与模块化开发方式" class="headerlink" title="了解好的前端架构与模块化开发方式"></a>了解好的前端架构与模块化开发方式</h4><p>去看看好的开源项目，他们是</p><ol><li>如何联动使用vue，vuex，vue-router，axios的</li><li>如何将前端存储，请求发送包装成为独立的模块</li><li>如何包装前端框架中的各种模组</li><li>其他的优秀设计理念</li></ol><h3 id="后端的问题"><a href="#后端的问题" class="headerlink" title="后端的问题"></a>后端的问题</h3><ol><li>没有自动化测试</li><li>没有使用数据库事务</li><li>后端REST接口设计的不好</li></ol><h4 id="没有自动化测试"><a href="#没有自动化测试" class="headerlink" title="没有自动化测试"></a>没有自动化测试</h4><p>没有，真的没有，为了快速开发，测试代码为零</p><h4 id="没有使用数据库事务"><a href="#没有使用数据库事务" class="headerlink" title="没有使用数据库事务"></a>没有使用数据库事务</h4><p>这有需求文档的问题(其实大作业布置下来的要求根本没资格被称为需求文档，只能说是非常模糊的甲方需求，<del>啊！万恶的甲方</del>)</p><p>也有个人的问题，本身是有情景需要事务的，但是由于对技术栈不熟悉(JS的express.js+mongoose)，在尝试了几下之后，就放弃了，毕竟还要优先保证完成业务逻辑，现在想想实际上并不是很困难，完全可以做</p><h4 id="后端REST接口设计的不好"><a href="#后端REST接口设计的不好" class="headerlink" title="后端REST接口设计的不好"></a>后端REST接口设计的不好</h4><p>这个”不好”，指的是什么方面呢？</p><p>首先，后端接口在开发过程中还几经变迁，基本上是开发到哪算到哪，最终导致接口变来变去，同时REST的”面向资源的操作”特性不明显</p><p>特性不明显这一点倒感觉未必非常重要，但是几经变迁这件事槽点比较大</p><h3 id="后端未来的计划"><a href="#后端未来的计划" class="headerlink" title="后端未来的计划"></a>后端未来的计划</h3><ol><li>学会自动化测试</li><li>了解各类数据库的使用</li><li>学习各种后端接口的设计</li></ol><h4 id="学会自动化测试"><a href="#学会自动化测试" class="headerlink" title="学会自动化测试"></a>学会自动化测试</h4><ul><li>如何在框架内使用单元测试？</li><li>如何mock HTTP请求?(postman)</li><li>如何自动化mock HTTP请求并验证response？</li></ul><h4 id="了解各类数据库的使用"><a href="#了解各类数据库的使用" class="headerlink" title="了解各类数据库的使用"></a>了解各类数据库的使用</h4><ul><li>SQL与NoSQL</li><li>数据库事务</li><li>数据库底层的实现，各类锁</li></ul><h4 id="学习各种后端接口的设计"><a href="#学习各种后端接口的设计" class="headerlink" title="学习各种后端接口的设计"></a>学习各种后端接口的设计</h4><ul><li>REST风格</li><li>GraphQL接口设计</li><li>RPC调用接口设计</li></ul><h3 id="开发流程上的问题与计划"><a href="#开发流程上的问题与计划" class="headerlink" title="开发流程上的问题与计划"></a>开发流程上的问题与计划</h3><p>主要是文档和git的workflow</p><p>文档方面，要养成良好的习惯，多写点注释，使用文档，需求文档，接口文档，设计的优先级一定是要高于编码的</p><p>git的workflow，要采用master/dev/feature/hotfix的开发方式，保持主分支的干净</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的开发活动，需求不明确，开发者也缺少经验，同时缺少动力(既不能赚钱，也不是自己感兴趣的产品)，所以最终的成品是比较惨的</p><p>总的来说，需要多读，读开源项目的代码，多写，自己找到有兴趣的项目，做一些完整的，良好的开发活动</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是在我完成了oop大作业之后，重新审视自己的开发流程与系统设计的一点总结与展望，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这是个”154/“(一无是处)的项目&lt;/li&gt;
&lt;li&gt;好在能够让我感受到一些努力的方向&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码就不开源了，实在太差了，就在这里口嗨一下就好&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="https://rivers-shall.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>goland中Run与Debug里working-directory的含义</title>
    <link href="https://rivers-shall.github.io/2020/06/03/goland%E4%B8%ADRun%E4%B8%8EDebug%E9%87%8Cworking-directory%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>https://rivers-shall.github.io/2020/06/03/goland中Run与Debug里working-directory的含义/</id>
    <published>2020-06-03T12:15:43.000Z</published>
    <updated>2020-06-03T12:26:58.028Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者由于不了解goland中Run与Debug配置中working-directory含义而引起的bug，简单来说:</p><blockquote><p>working directory就是golang项目编译好后的二进制文件执行的文件夹路径</p></blockquote><h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>项目框架中存在<code>conf</code>这样的专门放置配置文件的文件夹，当使用项目框架自带的<code>build.sh</code>构建脚本时，会将编译好的二进制文件和<code>conf</code>中的配置文件分别拷贝到<code>output/bin</code>和<code>output/conf</code>这两个文件夹下，将<code>output</code>试做发布文件夹</p><p>但是，在goland中如果想要配置Run或者Debug，是不能使用<code>build.sh</code>脚本的，只能配置原始的go编译命令</p><p>在配置的同时，我将working-directory很随意地设置为了<code>output</code>文件夹</p><h2 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h2><p>当我修改了配置文件并进行Run或者Debug时，发现修改没有生效</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>没有生效是因为，working-directory被设置为<code>output</code>文件夹，那么goland在执行goland本身编译好的二进制文件时，会引用<code>output/conf</code>下的配置文件</p><p>但是，<code>conf</code>文件夹下的修改是不会自动同步到<code>output/conf</code>里的(对源代码的修改会同步到goland上，因为goland会重新编译)，必须执行<code>./build.sh</code>脚本才可以</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>可以每次修改配置文件是都先执行<code>./build.sh</code>，然后再goland使用Run或Debug</p><p>也可以将working-directory设置为<code>./</code>而不是设置为<code>./output</code>，这样以后goland编译执行引用的就是<code>./conf</code>中的配置文件，修改也就能直接同步了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文记录了作者由于不了解goland中Run与Debug配置中working-directory含义而引起的bug，简单来说:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;working directory就是golang项目编译好后的二进制文件执行的文件夹路径&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="goland" scheme="https://rivers-shall.github.io/tags/goland/"/>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>bash中的字符串处理操作</title>
    <link href="https://rivers-shall.github.io/2020/06/02/bash%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/"/>
    <id>https://rivers-shall.github.io/2020/06/02/bash中的字符串处理操作/</id>
    <published>2020-06-02T06:35:42.000Z</published>
    <updated>2020-06-02T06:54:41.375Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用bash过程中，为了解决去除前缀后缀的问题而了解到的bash的字符串操作，简单来说</p><ol><li><code>string:position</code>或者<code>string:position:length</code>进行子串提取</li><li><code>string#pattern</code>进行最短匹配前缀去除，<code>string##pattern</code>进行最长匹配前缀去除</li><li><code>string%pattern</code>进行最短匹配后缀去除，<code>string%%pattern</code>进行最长匹配后缀去除</li><li><code>string/pattern/string</code>进行首个<code>pattern</code>替换，<code>string//pattern/string</code>进行全部<code>pattern</code>替换</li><li>以上的<code>pattern</code>指的都是<em>wildcard</em>而不是<em>regular expression</em></li></ol><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有时在使用bash脚本的时候，希望对字符串做一些基本的操作，比如说去除前缀后缀（去除文件扩展名，统一前缀编号等），事实上，bash原生支持了许多字符串操作</p><h2 id="bash-中的字符串操作"><a href="#bash-中的字符串操作" class="headerlink" title="bash 中的字符串操作"></a>bash 中的字符串操作</h2><p><strong>下面所有的<code>pattern</code>指的都是bash wildcard而不是regular expression</strong></p><h3 id="子串提取"><a href="#子串提取" class="headerlink" title="子串提取"></a>子串提取</h3><p>使用<code>string:position</code>提取从<code>position</code>开始的子串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string:3&#125;</span></span><br><span class="line">t, dummy, text, dummy</span><br></pre></td></tr></table></figure><p>使用<code>string:position:length</code>提取从<code>position</code>开始，长度为<code>length</code>的子串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string:3:4&#125;</span></span><br><span class="line">t, d</span><br></pre></td></tr></table></figure><h3 id="前缀去除"><a href="#前缀去除" class="headerlink" title="前缀去除"></a>前缀去除</h3><p>使用<code>string#pattern</code>进行最短匹配前缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string#*text&#125;</span></span><br><span class="line">, dummy, text, dummy</span><br></pre></td></tr></table></figure><p>使用<code>string##pattern</code>进行最长匹配前缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string##*text&#125;</span></span><br><span class="line">, dummy</span><br></pre></td></tr></table></figure><h3 id="后缀去除"><a href="#后缀去除" class="headerlink" title="后缀去除"></a>后缀去除</h3><p>使用<code>string%pattern</code>进行最短匹配后缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string%dummy*&#125;</span></span><br><span class="line">text, dummy, text, y</span><br></pre></td></tr></table></figure><p>使用<code>string%%pattern</code>进行最长匹配后缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string%%dummy*&#125;</span></span><br><span class="line">text,</span><br></pre></td></tr></table></figure><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>使用<code>string/pattern/string</code>进行首个<code>pattern</code>的替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string/text/TEXT&#125;</span></span><br><span class="line">TEXT, dummy, text, dummy</span><br></pre></td></tr></table></figure><p>使用<code>string//pattern/string</code>进行全部<code>pattern</code>的替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string//text/TEXT&#125;</span></span><br><span class="line">TEXT, dummy, TEXT, dummy</span><br></pre></td></tr></table></figure><p>想要得到对正则表达式匹配替换的支持的话，可以使用<a href="https://man.linuxde.net/sed" target="_blank" rel="noopener">sed</a>命令</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用bash过程中，为了解决去除前缀后缀的问题而了解到的bash的字符串操作，简单来说&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;string:position&lt;/code&gt;或者&lt;code&gt;string:position:length&lt;/code&gt;进行子串提取&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string#pattern&lt;/code&gt;进行最短匹配前缀去除，&lt;code&gt;string##pattern&lt;/code&gt;进行最长匹配前缀去除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string%pattern&lt;/code&gt;进行最短匹配后缀去除，&lt;code&gt;string%%pattern&lt;/code&gt;进行最长匹配后缀去除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string/pattern/string&lt;/code&gt;进行首个&lt;code&gt;pattern&lt;/code&gt;替换，&lt;code&gt;string//pattern/string&lt;/code&gt;进行全部&lt;code&gt;pattern&lt;/code&gt;替换&lt;/li&gt;
&lt;li&gt;以上的&lt;code&gt;pattern&lt;/code&gt;指的都是&lt;em&gt;wildcard&lt;/em&gt;而不是&lt;em&gt;regular expression&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="bash" scheme="https://rivers-shall.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中箭头函数与普通函数</title>
    <link href="https://rivers-shall.github.io/2020/06/01/JavaScript%E4%B8%AD%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://rivers-shall.github.io/2020/06/01/JavaScript中箭头函数与普通函数/</id>
    <published>2020-06-01T12:26:38.000Z</published>
    <updated>2020-06-01T12:46:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用mongoose的过程中，因为箭头函数与普通函数的区别而引起的一个bug，以及因此而学会的有关箭头函数与普通函数的区别，简单来说：</p><ol><li>箭头函数不能使用<code>arguments</code>参数，普通函数可以</li><li>箭头函数的<code>this</code>关键字是lexically bound，也就是<code>this</code>是和<strong>最近的外层普通函数</strong>所具有的<code>this</code>一致(如果没有这样的函数，就和文件本身代表的对象绑定)；普通函数的<code>this</code>是dynamically bound，视运行时环境而确定</li></ol><p>其实还有什么<code>new</code>之类的，作者觉得不大重要，就算了</p><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在使用mongoose的过程中，需要对schema构造一个“虚字段”，参考实现中使用如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">itemSchema.virtual(<span class="string">"id"</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._id.toHexString();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我寻思着可以少写点东西，更精简一些，于是在我的实现里使用了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">itemSchema.virtual(<span class="string">"id"</span>).get(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._id.toHexString();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行时报错:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined 没有 toHexString 成员函数</span><br></pre></td></tr></table></figure><p>这才意识到，原来使用箭头函数的时候，<code>this</code>的绑定规则和普通函数不一致</p><h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f2(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这段代码<strong>在浏览器中</strong>，<code>f1</code>可以正常打印，<code>f2</code>会报<code>undefined</code>，当然，在node.js环境下，还会有些不同，可以自己试试</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">exports.mod = <span class="string">"mod"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    f1() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = &#123;</span><br><span class="line">    f1 : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.f1()</span><br><span class="line">user2.f1()</span><br></pre></td></tr></table></figure><p>这段代码在node.js下，打印出如下结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; node test2.js</span><br><span class="line">&#123; f1: [Function: f1] &#125;</span><br><span class="line">&#123; mod: <span class="string">'mod'</span> &#125;</span><br></pre></td></tr></table></figure><p>可见，普通函数绑定的是运行时的对象，箭头函数绑定的是静态的编译时的对象</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用mongoose的过程中，因为箭头函数与普通函数的区别而引起的一个bug，以及因此而学会的有关箭头函数与普通函数的区别，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;箭头函数不能使用&lt;code&gt;arguments&lt;/code&gt;参数，普通函数可以&lt;/li&gt;
&lt;li&gt;箭头函数的&lt;code&gt;this&lt;/code&gt;关键字是lexically bound，也就是&lt;code&gt;this&lt;/code&gt;是和&lt;strong&gt;最近的外层普通函数&lt;/strong&gt;所具有的&lt;code&gt;this&lt;/code&gt;一致(如果没有这样的函数，就和文件本身代表的对象绑定)；普通函数的&lt;code&gt;this&lt;/code&gt;是dynamically bound，视运行时环境而确定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实还有什么&lt;code&gt;new&lt;/code&gt;之类的，作者觉得不大重要，就算了&lt;/p&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
    
      <category term="JavaScript" scheme="https://rivers-shall.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>grep打印匹配行的未匹配内容</title>
    <link href="https://rivers-shall.github.io/2020/06/01/grep%E6%89%93%E5%8D%B0%E5%8C%B9%E9%85%8D%E8%A1%8C%E7%9A%84%E6%9C%AA%E5%8C%B9%E9%85%8D%E5%86%85%E5%AE%B9/"/>
    <id>https://rivers-shall.github.io/2020/06/01/grep打印匹配行的未匹配内容/</id>
    <published>2020-06-01T10:47:40.000Z</published>
    <updated>2020-06-01T12:06:53.634Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用<code>grep</code>和<code>sed</code>命令来实现，打印<code>grep</code>匹配行中的未匹配内容的功能的方法，简单来说：</p><ol><li>先使用<code>grep &lt;pattern&gt;</code>提取出匹配行</li><li>再使用<code>sed -e &#39;s/&lt;pattern&gt;//g&#39;</code>将匹配内容消除，即可得到未匹配内容</li></ol><a id="more"></a><h2 id="场景与方案"><a href="#场景与方案" class="headerlink" title="场景与方案"></a>场景与方案</h2><p>使用<code>grep</code>时，我们可以用<code>grep &lt;pattern&gt;</code>来打印出匹配行，可以使用<code>grep -o &lt;pattern&gt;</code>来打印出匹配行中的匹配内容，但是如果希望能够实现“反选”，也就是打印出匹配行中的费匹配内容，应该怎么做呢？</p><p>单纯的<code>grep</code>命令没有提供这种机制的支持，但是同时使用<code>grep</code>和<code>sed</code>命令就可以实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"matched not\nmat"</span> | grep <span class="string">"matched"</span> | sed <span class="string">"s/matched//g"</span></span><br><span class="line"> not</span><br></pre></td></tr></table></figure><p>首先，我们使用<code>grep &lt;pattern&gt;</code>打印出匹配行，而后，使用<code>sed &quot;s/&lt;pattern&gt;//g&quot;</code>将匹配行中的匹配内容替换为空字符串，就消除了匹配内容，留下了非匹配内容</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用&lt;code&gt;grep&lt;/code&gt;和&lt;code&gt;sed&lt;/code&gt;命令来实现，打印&lt;code&gt;grep&lt;/code&gt;匹配行中的未匹配内容的功能的方法，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先使用&lt;code&gt;grep &amp;lt;pattern&amp;gt;&lt;/code&gt;提取出匹配行&lt;/li&gt;
&lt;li&gt;再使用&lt;code&gt;sed -e &amp;#39;s/&amp;lt;pattern&amp;gt;//g&amp;#39;&lt;/code&gt;将匹配内容消除，即可得到未匹配内容&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://rivers-shall.github.io/tags/sed/"/>
    
      <category term="grep" scheme="https://rivers-shall.github.io/tags/grep/"/>
    
  </entry>
  
  <entry>
    <title>bash实现trim字符串</title>
    <link href="https://rivers-shall.github.io/2020/06/01/bash%E5%AE%9E%E7%8E%B0trim%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://rivers-shall.github.io/2020/06/01/bash实现trim字符串/</id>
    <published>2020-06-01T10:27:53.000Z</published>
    <updated>2020-06-01T10:43:55.574Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用<code>sed</code>命令对bash中的字符串进行去头尾空格的操作的方法，简单来说</p><ol><li>使用<code>echo &#39;  string  &#39; | sed -e &#39;s/^[[:space:]]*//&#39;</code>去除开头的空格</li><li>使用<code>echo &#39;  string  &#39; | sed -e &#39;s/[[:space:]]*$//&#39;</code>去除结尾的空格</li><li>将二者用管道结合，去除头尾空格<code>echo &#39;  string  &#39; | sed -e &#39;s/[[:space:]]*$//&#39; | sed -e &#39;s/^[[:space:]]*//&#39;</code></li></ol><a id="more"></a><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>去除头尾空格的字符串处理操作是非常常用的操作，在许多语言的标准库里都会以<code>trim</code>函数的方式提供出来</p><p>要在bash中实现这一功能，可以使用<code>sed</code>命令的替换子命令</p><p><code>sed -e &#39;s/^[[:space:]]*//&#39;</code>是指匹配所有行开头的空格并将其替换为空字符串</p><p><code>sed -e &#39;s/[[:space:]]*$//&#39;</code>是指匹配所有行结尾的空格并将其替换为空字符串</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用&lt;code&gt;sed&lt;/code&gt;命令对bash中的字符串进行去头尾空格的操作的方法，简单来说&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/^[[:space:]]*//&amp;#39;&lt;/code&gt;去除开头的空格&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/[[:space:]]*$//&amp;#39;&lt;/code&gt;去除结尾的空格&lt;/li&gt;
&lt;li&gt;将二者用管道结合，去除头尾空格&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/[[:space:]]*$//&amp;#39; | sed -e &amp;#39;s/^[[:space:]]*//&amp;#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://rivers-shall.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>转义sed替换模式字符串</title>
    <link href="https://rivers-shall.github.io/2020/06/01/%E8%BD%AC%E4%B9%89sed%E6%9B%BF%E6%8D%A2%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://rivers-shall.github.io/2020/06/01/转义sed替换模式字符串/</id>
    <published>2020-06-01T05:47:34.000Z</published>
    <updated>2020-06-01T10:43:41.406Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用<code>sed</code>命令进行文本替换时，对于使用到的替换模式进行转义处理使用到的<code>sed</code>命令，简单来说：</p><ul><li>使用<code>sed -e &#39;s/[]\/$*.^[]/\\&amp;/g&#39;</code>即可对输入字符串进行转义</li></ul><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><code>sed</code>命令常常被用来对文本做处理，其中一个最经常用到的处理就是替换，替换的语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$STRING</span> | sed -e <span class="string">'s/&lt;match_pattern&gt;/&lt;replace_pattern&gt;/g'</span></span><br></pre></td></tr></table></figure><p>当然也可以有其他的变化，不过这是作者使用的最多的方式。</p><p>在使用这些的时候，我们可能会在<code>match_pattern</code>和<code>replace_pattern</code>中引用变量，已达到分别管理和增强可读性的目的，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"ff"</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>但是，如果上面引用的<code>REPLACE</code>里面有特殊字符，我们就会遇到问题，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"/a"</span></span><br><span class="line"><span class="comment"># 有问题</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>我们的本意是将<code>a</code>替换为<code>/a</code>，但是，使用这几条命令，会得到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed: 1: <span class="string">"s/a//a/g</span></span><br><span class="line"><span class="string">"</span>: bad flag <span class="keyword">in</span> substitute <span class="built_in">command</span>: <span class="string">'a'</span></span><br></pre></td></tr></table></figure><p>这里的原因就是<code>/a</code>中的<code>/</code>是一个特殊字符，如果希望得到我们上述的效果，应该这么操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"\/a"</span></span><br><span class="line"><span class="comment"># 成功</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>我们通过<code>\/</code>进行转义，取得了成功，但是这种方式使得我们编写<code>replace_pattern</code>变得麻烦，而且很不直观，我们希望有一个函数来达到如下效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"/a"</span></span><br><span class="line">REPLACE=$(func <span class="variable">$REPLACE</span>)</span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>也就是说，编写<code>replace_pattern</code>时，可以直接编写，而后使用一个函数或者命令自动转义再使用</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><a href="https://stackoverflow.com/questions/407523/escape-a-string-for-a-sed-replace-pattern" target="_blank" rel="noopener">stackoverflow</a></p><p>使用<code>sed -e &#39;s/[]\/$*.^[]/\\&amp;/g&#39;</code>即可</p><h3 id="方案解析"><a href="#方案解析" class="headerlink" title="方案解析"></a>方案解析</h3><p>我们这次的方案就是对原生的<code>replace_pattern</code>做一次替换:</p><ul><li><code>match_pattern</code>为<code>[]\/$*.^[]</code><ul><li>这个正则表达式的结构很具有迷惑性，其实它是一个大的<em>bracket group</em></li><li>也就是说，实际上是<code>[</code> <code>]\/$*.^[</code> <code>]</code>的结构</li><li>意味着匹配<code>]\/$*.^[</code>中的任一字符</li></ul></li><li><code>replace_pattern</code>为<code>\\&amp;</code><ul><li>这个<code>replace_pattern</code>用到了一个转义字符和一个特殊字符</li><li>转义字符<code>\\</code>表示的就是<code>\</code></li><li>特殊字符<code>&amp;</code>表示的是<code>match_pattern</code>匹配到的内容</li></ul></li></ul><p>综合起来，这个替换语句就是把<code>]\/$*.^[</code>前面全部加上一个斜杠，进行转义</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用&lt;code&gt;sed&lt;/code&gt;命令进行文本替换时，对于使用到的替换模式进行转义处理使用到的&lt;code&gt;sed&lt;/code&gt;命令，简单来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;sed -e &amp;#39;s/[]\/$*.^[]/\\&amp;amp;/g&amp;#39;&lt;/code&gt;即可对输入字符串进行转义&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://rivers-shall.github.io/tags/sed/"/>
    
  </entry>
  
</feed>
