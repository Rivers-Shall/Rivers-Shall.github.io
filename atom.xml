<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>碧漾的自我</title>
  
  <subtitle>beyond myself</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rivers-shall.github.io/"/>
  <updated>2020-06-01T10:34:05.754Z</updated>
  <id>https://rivers-shall.github.io/</id>
  
  <author>
    <name>碧漾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>bash实现trim字符串</title>
    <link href="https://rivers-shall.github.io/2020/06/01/bash%E5%AE%9E%E7%8E%B0trim%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://rivers-shall.github.io/2020/06/01/bash实现trim字符串/</id>
    <published>2020-06-01T10:27:53.000Z</published>
    <updated>2020-06-01T10:34:05.754Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用<code>sed</code>命令对bash中的字符串进行去头尾空格的操作的方法，简单来说</p><ol><li>使用<code>echo &#39;  string  &#39; | sed -e &#39;s/^[[:space:]]*//&#39;</code>去除开头的空格</li><li>使用<code>echo &#39;  string  &#39; | sed -e &#39;s/[[:space:]]*$//&#39;</code>去除结尾的空格</li><li>将二者用管道结合，去除头尾空格<code>echo &#39;  string  &#39; | sed -e &#39;s/[[:space:]]*$//&#39; | sed -e &#39;s/^[[:space:]]*//&#39;</code></li></ol><a id="more"></a><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>去除头尾空格的字符串处理操作是非常常用的操作，在许多语言的标准库里都会以<code>trim</code>函数的方式提供出来</p><p>要在bash中实现这一功能，可以使用<code>sed</code>命令的替换子命令</p><p><code>sed -e &#39;s/^[[:space:]]*//&#39;</code>是指匹配所有行开头的空格并将其替换为空字符串</p><p><code>sed -e &#39;s/[[:space:]]*$//&#39;</code>是指匹配所有行结尾的空格并将其替换为空字符串</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用&lt;code&gt;sed&lt;/code&gt;命令对bash中的字符串进行去头尾空格的操作的方法，简单来说&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/^[[:space:]]*//&amp;#39;&lt;/code&gt;去除开头的空格&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/[[:space:]]*$//&amp;#39;&lt;/code&gt;去除结尾的空格&lt;/li&gt;
&lt;li&gt;将二者用管道结合，去除头尾空格&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/[[:space:]]*$//&amp;#39; | sed -e &amp;#39;s/^[[:space:]]*//&amp;#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://rivers-shall.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>转义sed替换模式字符串</title>
    <link href="https://rivers-shall.github.io/2020/06/01/%E8%BD%AC%E4%B9%89sed%E6%9B%BF%E6%8D%A2%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://rivers-shall.github.io/2020/06/01/转义sed替换模式字符串/</id>
    <published>2020-06-01T05:47:34.000Z</published>
    <updated>2020-06-01T06:36:13.397Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用<code>sed</code>命令进行文本替换时，对于使用到的替换模式进行转义处理使用到的<code>sed</code>命令，简单来说：</p><ul><li>使用<code>sed -e &#39;s/[]\/$*.^[]/\\&amp;/g&#39;</code>即可对输入字符串进行转义</li></ul><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><code>sed</code>命令常常被用来对文本做处理，其中一个最经常用到的处理就是替换，替换的语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$STRING</span> | sed -e <span class="string">'s/&lt;match_pattern&gt;/&lt;replace_pattern&gt;/g'</span></span><br></pre></td></tr></table></figure><p>当然也可以有其他的变化，不过这是作者使用的最多的方式。</p><p>在使用这些的时候，我们可能会在<code>match_pattern</code>和<code>replace_pattern</code>中引用变量，已达到分别管理和增强可读性的目的，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"ff"</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>但是，如果上面引用的<code>REPLACE</code>里面有特殊字符，我们就会遇到问题，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"/a"</span></span><br><span class="line"><span class="comment"># 有问题</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>我们的本意是将<code>a</code>替换为<code>/a</code>，但是，使用这几条命令，会得到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed: 1: <span class="string">"s/a//a/g</span></span><br><span class="line"><span class="string">"</span>: bad flag <span class="keyword">in</span> substitute <span class="built_in">command</span>: <span class="string">'a'</span></span><br></pre></td></tr></table></figure><p>这里的原因就是<code>/a</code>中的<code>/</code>是一个特殊字符，如果希望得到我们上述的效果，应该这么操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"\/a"</span></span><br><span class="line"><span class="comment"># 成功</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>我们通过<code>\/</code>进行转义，取得了成功，但是这种方式使得我们编写<code>replace_pattern</code>变得麻烦，而且很不直观，我们希望有一个函数来达到如下效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"/a"</span></span><br><span class="line">REPLACE=$(func <span class="variable">$REPLACE</span>)</span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>也就是说，编写<code>replace_pattern</code>时，可以直接编写，而后使用一个函数或者命令自动转义再使用</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><a href="https://stackoverflow.com/questions/407523/escape-a-string-for-a-sed-replace-pattern" target="_blank" rel="noopener">stackoverflow</a></p><p>使用<code>sed -e &#39;s/[]\/$*.^[]/\\&amp;/g&#39;</code>即可</p><h3 id="方案解析"><a href="#方案解析" class="headerlink" title="方案解析"></a>方案解析</h3><p>我们这次的方案就是对原生的<code>replace_pattern</code>做一次替换:</p><ul><li><code>match_pattern</code>为<code>[]\/$*.^[]</code><ul><li>这个正则表达式的结构很具有迷惑性，其实它是一个大的<em>bracket group</em></li><li>也就是说，实际上是<code>[</code> <code>]\/$*.^[</code> <code>]</code>的结构</li><li>意味着匹配<code>]\/$*.^[</code>中的任一字符</li></ul></li><li><code>replace_pattern</code>为<code>\\&amp;</code><ul><li>这个<code>replace_pattern</code>用到了一个转义字符和一个特殊字符</li><li>转义字符<code>\\</code>表示的就是<code>\</code></li><li>特殊字符<code>&amp;</code>表示的是<code>match_pattern</code>匹配到的内容</li></ul></li></ul><p>综合起来，这个替换语句就是把<code>]\/$*.^[</code>前面全部加上一个斜杠，进行转义</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用&lt;code&gt;sed&lt;/code&gt;命令进行文本替换时，对于使用到的替换模式进行转义处理使用到的&lt;code&gt;sed&lt;/code&gt;命令，简单来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;sed -e &amp;#39;s/[]\/$*.^[]/\\&amp;amp;/g&amp;#39;&lt;/code&gt;即可对输入字符串进行转义&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://rivers-shall.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>date命令的两种常用法</title>
    <link href="https://rivers-shall.github.io/2020/06/01/date%E5%91%BD%E4%BB%A4%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%B3%95/"/>
    <id>https://rivers-shall.github.io/2020/06/01/date命令的两种常用法/</id>
    <published>2020-06-01T03:17:25.000Z</published>
    <updated>2020-06-01T03:31:11.381Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在平时工作中经常用到的Linux命令<code>date</code>的两种常见使用方式，简单来说：</p><ol><li>打印当前时间，<code>date &quot;+&lt;output_format&gt;&quot;</code></li><li>将Unix时间戳转化为可读的日期+时间<code>date -r &lt;unix-timestamp&gt; &quot;+&lt;output_format&gt;&quot;</code></li></ol><a id="more"></a><h2 id="打印当前时间"><a href="#打印当前时间" class="headerlink" title="打印当前时间"></a>打印当前时间</h2><p>只需要使用<code>date &quot;+&lt;output_format&gt;&quot;</code>就可以打印当前时间，其中，<code>output_format</code>由正常字符和转义字符组成，转义字符用来打印当前的年，月，日等等</p><table><thead><tr><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td>%Y</td><td>年</td></tr><tr><td>%m</td><td>月</td></tr><tr><td>%d</td><td>日</td></tr><tr><td>%H</td><td>小时</td></tr><tr><td>%M</td><td>分钟</td></tr><tr><td>%S</td><td>秒</td></tr><tr><td>%s</td><td>时间戳</td></tr></tbody></table><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date <span class="string">"+%Y-%m-%d-%H-%M-%S"</span></span><br><span class="line">2020-06-01-11-24-39</span><br></pre></td></tr></table></figure><h2 id="将Unix时间戳转化为可读的日期-时间"><a href="#将Unix时间戳转化为可读的日期-时间" class="headerlink" title="将Unix时间戳转化为可读的日期+时间"></a>将Unix时间戳转化为可读的日期+时间</h2><p>使用<code>date -r &lt;unix-timestamp&gt; &quot;+&lt;output_format&gt;&quot;</code>即可完成转化，其中的<code>output_format</code>和上文中介绍的一样，<code>&lt;unix-timestamp</code>就是一个数字</p><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date -r 0 <span class="string">"+%Y-%m-%d-%H-%M-%S"</span></span><br><span class="line">1970-01-01-08-00-00</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在平时工作中经常用到的Linux命令&lt;code&gt;date&lt;/code&gt;的两种常见使用方式，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打印当前时间，&lt;code&gt;date &amp;quot;+&amp;lt;output_format&amp;gt;&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将Unix时间戳转化为可读的日期+时间&lt;code&gt;date -r &amp;lt;unix-timestamp&amp;gt; &amp;quot;+&amp;lt;output_format&amp;gt;&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>git-status中文乱码问题</title>
    <link href="https://rivers-shall.github.io/2020/05/29/git-status%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://rivers-shall.github.io/2020/05/29/git-status中文乱码问题/</id>
    <published>2020-05-29T10:21:28.000Z</published>
    <updated>2020-05-29T10:26:35.469Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者解决<code>git status</code>命令中出现中文名乱码问题的方法，简单来说</p><blockquote><p>配置 core.quotepath 为 false 即可</p></blockquote><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>当我们的修改文件中出现中文文件名时，<code>git status</code>就会出现乱码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  project git:(master) ✗ git status -s</span><br><span class="line">?? <span class="string">"\344\270\255\346\226\207\346\226\207\344\273\266"</span></span><br></pre></td></tr></table></figure><p>这是由于Git默认会对ASCII以外的编码进行转义，只要将这个转义关掉，就可以恢复正常了，关掉的方式就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  project git:(master) ✗ git config core.quotepath <span class="literal">false</span></span><br><span class="line">➜  project git:(master) ✗ git status -s</span><br><span class="line">?? 中文文件</span><br></pre></td></tr></table></figure><p>当然，如果希望让这个设定在所有的Git本地仓库里都生效，可以加上<code>--global</code>选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  project git:(master) ✗ git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者解决&lt;code&gt;git status&lt;/code&gt;命令中出现中文名乱码问题的方法，简单来说&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置 core.quotepath 为 false 即可&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="git" scheme="https://rivers-shall.github.io/tags/git/"/>
    
      <category term="中文乱码" scheme="https://rivers-shall.github.io/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>golang抽取接口，依赖注入(依赖倒置)解决包引用关系</title>
    <link href="https://rivers-shall.github.io/2020/05/28/golang%E6%8A%BD%E5%8F%96%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE-%E8%A7%A3%E5%86%B3%E5%8C%85%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB/"/>
    <id>https://rivers-shall.github.io/2020/05/28/golang抽取接口，依赖注入-依赖倒置-解决包引用关系/</id>
    <published>2020-05-28T06:58:15.000Z</published>
    <updated>2020-05-28T07:33:33.841Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在golang开发中，通过抽取接口，依赖注入的方式，解决包与包之间的不合理引用关系。</p><p>总结来说：</p><blockquote><p>面向接口编程，并且golang中接口函数的参数最好是标准库的类型</p></blockquote><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>目前项目中有一个业务逻辑包<code>business_logic</code>，两个工具库包<code>pkg1</code>和<code>pkg2</code>，其中</p><ul><li><code>pkg1</code>是旧库，API不宜改动，<code>pkg2</code>是新库，尚未正式使用</li><li><code>business_logic</code>会使用<code>pkg1</code>和<code>pkg2</code></li><li><code>pkg1</code>内部要添加使用<code>pkg2</code>的逻辑</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg1/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"pkg2"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg2.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg2/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    param1 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">(s S)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// business_logic/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"pkg1"</span></span><br><span class="line">    <span class="string">"pkg2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg1.ExternalAPI()</span><br><span class="line">    pkg2.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就引起了一个问题：</p><blockquote><p><code>business_logic</code>其实引用了两次<code>pkg2</code>，一次是直接引用，一次是通过<code>pkg1</code>间接引用，将来在版本更迭中，很有可能会出现直接引用的版本和间接引用的版本不一致的情况，从而引起未知bug</p></blockquote><h2 id="解决尝试"><a href="#解决尝试" class="headerlink" title="解决尝试"></a>解决尝试</h2><p>如果不希望两次引用，那么最好的方式是消除<code>pkg1</code>对<code>pkg2</code>的引用，消除引用的方式是</p><ul><li><code>pkg1</code>抽象出一个接口，</li><li>让<code>pkg2</code>提供结构体，实现<code>pkg1</code>抽象出的接口</li></ul><p>这样，<code>pkg2</code>实际上就变成了<code>pkg1</code>的一个插件，只要在<code>business_logic</code>初始化的时候，将<code>pkg2</code>的插件注入到<code>pkg1</code>里去就行</p><p>但是这样的尝试失败了，我们先来看一下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg1/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"pkg2"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    ExternalAPI(s pkg2.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plugin Plugin</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> plugin != <span class="literal">nil</span> &#123;</span><br><span class="line">        plugin.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetPlugin</span><span class="params">(p Plugin)</span></span> &#123;</span><br><span class="line">    plugin = p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg2/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    param1 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Plugin)</span> <span class="title">ExternalAPI</span><span class="params">(s S)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">(s S)</span></span> &#123;</span><br><span class="line">    p := Plugin&#123;&#125;</span><br><span class="line">    p.ExternalAPI(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// business_logic/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"pkg1"</span></span><br><span class="line">    <span class="string">"pkg2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg1.SetPlugin(&amp;pkg2.Plugin&#123;&#125;)</span><br><span class="line">    pkg1.ExternalAPI()</span><br><span class="line">    pkg2.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，<code>pkg1</code>对<code>pkg2</code>的引用仍旧存在，其原因在于抽取出来的接口函数中的参数是属于<code>pkg2</code>的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    ExternalAPI(s pkg2.S)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终解决方案"><a href="#最终解决方案" class="headerlink" title="最终解决方案"></a>最终解决方案</h2><p>由于<code>pkg2</code>是新库，所以我们决定更改它的接口，最终的代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg1/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    ExternalAPI(param <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plugin Plugin</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> plugin != <span class="literal">nil</span> &#123;</span><br><span class="line">        plugin.ExternalAPI(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetPlugin</span><span class="params">(p Plugin)</span></span> &#123;</span><br><span class="line">    plugin = p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg2/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Plugin)</span> <span class="title">ExternalAPI</span><span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    p := Plugin&#123;&#125;</span><br><span class="line">    p.ExternalAPI(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// business_logic/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"pkg1"</span></span><br><span class="line">    <span class="string">"pkg2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg1.SetPlugin(&amp;pkg2.Plugin&#123;&#125;)</span><br><span class="line">    pkg1.ExternalAPI()</span><br><span class="line">    pkg2.ExternalAPI(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这回彻底解决了<code>pkg1</code>引用<code>pkg2</code>的问题，代价就是将<code>pkg2.S</code>这个结构体参数展开了</p><p>视具体业务情况而定，我们可以通过：</p><ol><li>展开结构体</li><li>将结构体换做<code>map[string]interface{}</code>（当然需要手动做字段的提取和塞入）</li><li>将结构体换做<code>string</code>，用JSON传参（手动Marshal和Unmarshal）</li><li>将参数类型放到新的第三方库<code>pkg3</code>中（这样就又要维护引用的<code>pkg3</code>版本一致）</li></ol><p>软件开发中没有silver-bullet，只有trade-off，这次的方案，也还算满意</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在golang开发中，通过抽取接口，依赖注入的方式，解决包与包之间的不合理引用关系。&lt;/p&gt;
&lt;p&gt;总结来说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;面向接口编程，并且golang中接口函数的参数最好是标准库的类型&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>一个golang的RPC框架设计中的坑点</title>
    <link href="https://rivers-shall.github.io/2020/05/27/%E4%B8%80%E4%B8%AAgolang%E7%9A%84RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%9D%91%E7%82%B9/"/>
    <id>https://rivers-shall.github.io/2020/05/27/一个golang的RPC框架设计中的坑点/</id>
    <published>2020-05-27T13:13:42.000Z</published>
    <updated>2020-05-28T06:56:19.817Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用公司的RPC框架时，由于RPC框架本身的设计以及程序员的投机取巧而遇到的一个坑点。</p><p>简单来说，RPC框架没有能够做足够好的封装，程序员（不是作者，是前人）也没有按照RPC框架约定的方式进行API调用。</p><a id="more"></a><h2 id="背景提要"><a href="#背景提要" class="headerlink" title="背景提要"></a>背景提要</h2><p>我们知道，RPC调用是不同主机间的进程通信的方式，如果想要额外传递消息，我们往往需要修改RPC调用的接口，通过新增参数的方式来新增传递信息。</p><p>但是这样修改参数，修改接口的方式侵入性太强，需要进行上下游调用接口的适配，很麻烦。</p><p>当我们面对一些遍布在各个RPC服务的需求（也就是很多人喜欢提及的编程”切面”Aspect），比如这回我接到的日志系统的需求，将所有的接口都修改一遍，显然是不现实的。</p><p>在这里，golang的RPC框架可以通过传递<code>context.Context</code>来实现，也就是说，这些额外的，遍布各个RPC服务的消息，通过<code>context.Context</code>来传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc 上游调用时，传递一个`context.Context`和本来必要的下游rpc接口参数</span></span><br><span class="line">rpcClient.remoteMethod(ctx, request)</span><br><span class="line"></span><br><span class="line"><span class="comment">// rpc 下游接受请求时，接受一个`context.Context`和本来必要的接口参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">methodHandler</span><span class="params">(ctx context.Context, request MethodRequest)</span></span></span><br></pre></td></tr></table></figure><h3 id="类比HTTP解释"><a href="#类比HTTP解释" class="headerlink" title="类比HTTP解释"></a>类比HTTP解释</h3><p>上面提及的RPC调用传递<code>context.Context</code>和本来的接口参数，其实可以类比HTTP协议：</p><ul><li><code>context.Context</code> -&gt; HTTP Request Headers</li><li>接口参数 -&gt; HTTP Request Body</li></ul><p>二者都是传递信息的手段，但是接口参数和Request Body往往是明面上的写出来的主要业务逻辑需要的消息，<code>context.Context</code>和Request Headers往往是一些元数据(metadata)。</p><h2 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h2><p>这次的日志系统，需要我记录RPC运行时的动态调用链，也就是说，如果有一条RPC调用链路是</p><blockquote><p>RPC1 -&gt; RPC2 -&gt; RPC3</p></blockquote><p>那么实时的日志里，会有如下条目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RPC1:</span><br><span class="line">stack : []</span><br><span class="line"></span><br><span class="line">RPC2:</span><br><span class="line">stack : [RPC1]</span><br><span class="line"></span><br><span class="line">RPC3:</span><br><span class="line">stack : [RPC1, RPC2]</span><br></pre></td></tr></table></figure><h2 id="解决过程中遇到的问题"><a href="#解决过程中遇到的问题" class="headerlink" title="解决过程中遇到的问题"></a>解决过程中遇到的问题</h2><p>对于这个功能，我们发现RPC框架提供了三个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向一个context.Context加入key-val键值对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInfo</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, val <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 获取上游通过<span class="title">AddInfo</span>传来的<span class="title">key</span>对应的<span class="title">val</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">GetUpstreamInfo</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 获取所有上游通过<span class="title">AddInfo</span>传来的键值对，组织成一个<span class="title">map</span>[<span class="title">string</span>][<span class="title">string</span>]</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">GetAllUpstreamInfo</span><span class="params">(ctx context.Context)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>为此，我们的解决方案是，将<code>stack</code>做成<code>[]RPC</code>，其中<code>struct RPC</code>记录RPC的信息，通过JSON将<code>[]RPC</code>转化成<code>string</code>，而后用<code>context.Context</code>里的<code>&quot;stack&quot; - JSON([]RPC)</code>的键值对进行传递。</p><p>在我之前编码的程序员，没有遵守API调用规则，不使用<code>AddInfo</code>，而是使用的是如下方式进行<code>stack</code>的传递的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有的键值对</span></span><br><span class="line">m := util.GetAllUpstreamInfo(ctx)</span><br><span class="line"><span class="comment">// 取出stack并使用JSON解析</span></span><br><span class="line">stack, err := json.Unmarshal(m[<span class="string">"stack"</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加现有RPC调用</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, currentRPC)</span><br><span class="line"><span class="comment">// JOSN编码，更新ctx内的map</span></span><br><span class="line">m[<span class="string">"stack"</span>], err = json.Marshal(stack)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于golang中的map是引用传值，所以看上去这个代码已经成功更新了ctx内部的map，使用Goland-Debug查看ctx也会发现map已经修改了</p><p>但事实上程序并没有按照预期的方式进行工作</p><h3 id="排查原因"><a href="#排查原因" class="headerlink" title="排查原因"></a>排查原因</h3><p>仔细观察<code>AddInfo</code>函数的签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInfo</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, val <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br></pre></td></tr></table></figure><p>该函数返回了一个全新的Context，事实上<code>AddInfo</code>的逻辑是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">newCtx := AddInfo(ctx, <span class="string">"key"</span>, <span class="string">"val"</span>)</span><br><span class="line"></span><br><span class="line">+------------------------------+</span><br><span class="line">|          newCtx              |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |        ctx             | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|    K_KV -&gt;                   |</span><br><span class="line">| <span class="keyword">struct</span>&#123;key:<span class="string">"key"</span>,val:<span class="string">"val"</span>&#125;  |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><p>也就是说，新的Context在原来的Context上多加了一层，这一层的结构是</p><p><code>K_KV(RPC框架定义的一个字符串) -&gt; struct{key: &quot;key&quot;, val: &quot;val&quot;}</code></p><p>我们通过<code>newCtx.Value(&quot;key&quot;)</code>是拿不到任何东西的，只能通过<code>newCtx.Value(K_KV)</code>才能拿到完整的键值对</p><h4 id="这时，RPC框架有了一个骚操作"><a href="#这时，RPC框架有了一个骚操作" class="headerlink" title="这时，RPC框架有了一个骚操作"></a>这时，RPC框架有了一个骚操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPC1 ctx -------中间对ctx做了转化----------&gt; RPC2</span><br></pre></td></tr></table></figure><p>假设我们上游RPC1使用了如下<code>AddInfo</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">newCtx := AddInfo(ctx, <span class="string">"key"</span>, <span class="string">"val"</span>)</span><br><span class="line">newCtx2 := AddInfo(newCtx, <span class="string">"key2"</span>, <span class="string">"val2"</span>)</span><br><span class="line"></span><br><span class="line">+------------------------------+</span><br><span class="line">|          newCtx2             |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|   |      newCtx            | |</span><br><span class="line">|   |   +-------------+      | |</span><br><span class="line">|   |   |    ctx      |      | |</span><br><span class="line">|   |   +-------------+      | |</span><br><span class="line">|   | K_KV -&gt; <span class="keyword">struct</span>&#123;        | |</span><br><span class="line">|   |          key:<span class="string">"key"</span>     | |</span><br><span class="line">|   |          val:<span class="string">"val"</span>&#125;    | |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|  K_KV -&gt; <span class="keyword">struct</span>&#123;key:<span class="string">"key2"</span>,  |</span><br><span class="line">|                 val:<span class="string">"val2"</span>&#125;  |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><p>那么<code>newCtx2</code>就该如图示的那样，但是下游RPC2拿到的是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------+</span><br><span class="line">|          newCtx              |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |        ctx             | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|    K_UPSTREAM -&gt;             |</span><br><span class="line">|     <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;       |</span><br><span class="line">|           <span class="string">"key"</span> : <span class="string">"val"</span>,     |</span><br><span class="line">|           <span class="string">"key2"</span> : <span class="string">"val2"</span>    |</span><br><span class="line">|     &#125;                        |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><p>所以，用于从Context取出键值对的索引从<code>K_KV</code>变为了<code>K_UPSTREAM</code>!!!</p><p>这意味着上游传来的消息最多只能保留一个RPC路径，所以我们必须使用<code>AddInfo</code>而不是直接写入map的方式来更新数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有的键值对</span></span><br><span class="line">m := util.GetAllUpstreamInfo(ctx)</span><br><span class="line"><span class="comment">// 取出stack并使用JSON解析</span></span><br><span class="line">stack, err := json.Unmarshal(m[<span class="string">"stack"</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加现有RPC调用</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, currentRPC)</span><br><span class="line"><span class="comment">// JOSN编码，更新ctx内的map</span></span><br><span class="line">jsonStack, err := json.Marshal(stack)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">ctx = util.AddInfo(ctx, <span class="string">"stack"</span>, jsonStack)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>框架底层的逻辑并不是很易懂，解释比较麻烦，一篇博文难以说明清楚，但是需要记住的是：</p><ol><li>使用框架，尽量使用框架的标准接口</li><li>框架封装的时候，如果有map这类可能会让人有hack欲望的，写明文档</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用公司的RPC框架时，由于RPC框架本身的设计以及程序员的投机取巧而遇到的一个坑点。&lt;/p&gt;
&lt;p&gt;简单来说，RPC框架没有能够做足够好的封装，程序员（不是作者，是前人）也没有按照RPC框架约定的方式进行API调用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="RPC" scheme="https://rivers-shall.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>编写自定义启动脚本时的注意项</title>
    <link href="https://rivers-shall.github.io/2020/05/27/%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E9%A1%B9/"/>
    <id>https://rivers-shall.github.io/2020/05/27/编写自定义启动脚本时的注意项/</id>
    <published>2020-05-27T13:12:04.000Z</published>
    <updated>2020-05-28T06:56:19.817Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章介绍了作者在使用和编写自定义启动脚本时感受到的一个需要注意的点，简单来说，就是：</p><blockquote><p>一定要打印出事实上的最终启动命令</p></blockquote><a id="more"></a><h2 id="自定义启动脚本的使用场景"><a href="#自定义启动脚本的使用场景" class="headerlink" title="自定义启动脚本的使用场景"></a>自定义启动脚本的使用场景</h2><p>我们知道，启动一个程序需要固定的命令，比如说</p><ul><li>C/C++/Go可以编译出一个可执行文件，<code>./app</code>来启动</li><li>Java通过JDK<code>java</code>命令启动，<code>java APP</code></li></ul><p>但是，管理大型项目时，未必会是简单的<code>./app</code>这样就可以启动的，我们有可能会需要传入许多选项和参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./<span class="built_in">exec</span> -option1 -option2 arg1</span><br><span class="line"></span><br><span class="line">./app -debug -entryPoint 3000</span><br></pre></td></tr></table></figure><p>而这些选项和参数又有可能依赖于更高级的输入，比如说配置文件，环境变量等等</p><p>这时，就是自动化启动脚本登场的时候了，通过从高层输入（比如文件，环境变量）抽取出选项和参数，最终自动形成启动命令</p><h2 id="自动化启动脚本导致的问题"><a href="#自动化启动脚本导致的问题" class="headerlink" title="自动化启动脚本导致的问题"></a>自动化启动脚本导致的问题</h2><p>在各大IDE中，想要使用Debug功能，需要提供的正是<strong>最终启动命令</strong>，也就是上文的<code>./app -debug -entryPoint 3000</code>这种</p><p>否则IDE无法调用调试器连接调试端口，也就无法实现单步调试，变量检查等功能了</p><p>但是要想从自动化脚本和当下的高层输入一起来推算出最终启动命令，可能是一件比较困难或者至少是麻烦的事情（复杂的自动化启动脚本可能本身就有上百行）</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在自动化脚本启动最终命令之前，将最终命令打印出来。</p><p>这样，我们就只需要执行一次自动化脚本，而后将打印出来的最终命令提供给IDE，就可以开启Debug模式了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章介绍了作者在使用和编写自定义启动脚本时感受到的一个需要注意的点，简单来说，就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一定要打印出事实上的最终启动命令&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue中为对象添加字段</title>
    <link href="https://rivers-shall.github.io/2020/05/27/Vue%E4%B8%AD%E4%B8%BA%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5/"/>
    <id>https://rivers-shall.github.io/2020/05/27/Vue中为对象添加字段/</id>
    <published>2020-05-27T13:09:18.000Z</published>
    <updated>2020-05-28T06:56:19.816Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用Vue.js，并且在前端中为对象添加字段时遇到的坑点。</p><a id="more"></a><h2 id="场景与问题"><a href="#场景与问题" class="headerlink" title="场景与问题"></a>场景与问题</h2><p>从后端拿到数据之后，可能为了渲染时的方便，想要在对象里添加一些字段，而后直接在渲染时引用</p><p>直观上实现这种功能可以直接使用原生的js语法，抽象出来，可以用如下的代码段表示(为了复制就可以演示，没有组件化)</p><p>但是如下代码是有问题的，<code>obj.newField</code>不能被渲染出来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            &#123;&#123; obj.newField &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        let app = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">            el: "#app",</span></span><br><span class="line"><span class="undefined">            data : &#123;</span></span><br><span class="line"><span class="undefined">                obj : &#123;&#125;,</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            created() &#123;</span></span><br><span class="line"><span class="undefined">                obj.newField = "newData"</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正确的做法是使用<code>Vue.set</code>，因为在<a href="https://cn.vuejs.org/v2/api/#Vue-set" target="_blank" rel="noopener">Vue的官方文档</a>里有如下的表述</p><blockquote><p>因为 Vue 无法探测普通的新增 property (比如 this.myObject.newProperty = ‘hi’)</p></blockquote><p>所以上述代码应该改成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            &#123;&#123; obj.newField &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        let app = new Vue(&#123;</span></span><br><span class="line"><span class="undefined">            el: "#app",</span></span><br><span class="line"><span class="undefined">            data : &#123;</span></span><br><span class="line"><span class="undefined">                obj : &#123;&#125;,</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            created() &#123;</span></span><br><span class="line"><span class="undefined">                Vue.set(obj, "newField", "newData")</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用Vue.js，并且在前端中为对象添加字段时遇到的坑点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://rivers-shall.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>golang获取执行函数名，执行文件名与所在行数</title>
    <link href="https://rivers-shall.github.io/2020/05/27/golang%E8%8E%B7%E5%8F%96%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E5%90%8D%EF%BC%8C%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%8E%E6%89%80%E5%9C%A8%E8%A1%8C%E6%95%B0/"/>
    <id>https://rivers-shall.github.io/2020/05/27/golang获取执行函数名，执行文件名与所在行数/</id>
    <published>2020-05-27T01:19:50.000Z</published>
    <updated>2020-05-28T06:56:19.816Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章介绍了作者在参与一个golang日志系统的开发的时候，解决需要打印出执行<strong>日志打印操作</strong>时的<strong>业务函数名，业务文件名与所在行数</strong>的需求过程中，遇到的问题和解决方案</p><a id="more"></a><h2 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h2><p>在平日里使用日志的时候，一个好的日志系统，往往会打印出类似如下的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;log_level&gt;:&lt;log_message&gt;:&lt;package_path&gt;/&lt;filename&gt;:&lt;line_no&gt;:&lt;function_name&gt;</span><br><span class="line">比如</span><br><span class="line">INFO:connect to sql:/users/admin/home/go/src/io/rivers/demoProject/main.go:45:io.rivers.demoProject.testFunction</span><br></pre></td></tr></table></figure><p>这样子在打印出日志等级，日志消息的同时，输出业务逻辑所在的文件，行数，函数，对后期的bug排查，性能分析都有很大的帮助</p><p>那么，如何在golang中实现这一功能呢？</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>golang的runtime包提供了与之相应的函数接口，主要是<code>runtime.Caller</code>和<code>runtime.FuncForPC</code></p><p>先看一下二者的函数签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Caller</span><span class="params">(skip <span class="keyword">int</span>)</span> <span class="params">(pc <span class="keyword">uintptr</span>, file <span class="keyword">string</span>, line <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FuncForPC</span><span class="params">(pc <span class="keyword">uintptr</span>)</span> *<span class="title">Func</span></span></span><br></pre></td></tr></table></figure><p>单看函数签名就比较容易了解到:</p><ul><li><code>runtime.Caller</code>能够返回在函数栈中的PC(指令寄存器，可以认为存储了当前执行到了哪里)，所在的文件，所在文件的具体哪一行</li><li><code>runtime.FuncForPC</code>能够根据给定的指令寄存器给出其所在的行数</li></ul><p>其中<code>runtime.FuncForPC</code>的参数比较容易理解，就是指指令寄存器，但是<code>runtime.Caller</code>的参数需要解释一下</p><p>这里的<code>skip</code>指的是跳过多少个函数栈：</p><ul><li><code>skip == 0</code>，不跳过函数栈，返回当前函数PC，文件名，所在行</li><li><code>skip == 1</code>，跳过当前函数栈，返回上层调用者<strong>调用当前函数时的PC</strong>，文件名，所在行</li><li><code>skip == 2</code>，以此类推</li></ul><p>一般情况下这两个函数都是连在一起使用，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取上层调用者PC，文件名，所在行</span></span><br><span class="line">pc, codePath, codeLine, ok := runtime.Caller(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> !ok&#123;</span><br><span class="line">    <span class="comment">// 不ok，函数栈用尽了</span></span><br><span class="line">    code = <span class="string">"-"</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> = "-"</span></span><br><span class="line"><span class="function">&#125; <span class="title">else</span></span> &#123;</span><br><span class="line">    <span class="comment">// 拼接文件名与所在行</span></span><br><span class="line">    code = fmt.Sprintf(<span class="string">"%s:%d"</span>, codePath, codeLine)</span><br><span class="line">    <span class="comment">// 根据PC获取函数名</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> = <span class="title">runtime</span>.<span class="title">FuncForPC</span><span class="params">(pc)</span>.<span class="title">Name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="实现重点与自动获取的优化"><a href="#实现重点与自动获取的优化" class="headerlink" title="实现重点与自动获取的优化"></a>实现重点与自动获取的优化</h2><p>可以看到，在我们使用<code>runtime.Caller</code>和<code>runtime.FuncForPC</code>这一组合击的时候，实际上的输入参数只有一个，那就是<code>runtime.Caller</code>的<code>skip</code>。</p><p>如何确定<code>skip</code>呢？在实践中，我一般使用两种方式：</p><ol><li>写死</li><li>尝试自动获取</li></ol><p>听起来第二种方法要比第一种方法好，但是事实上并不是这样的，在看完实现之后，大家就会明白了</p><h3 id="将skip写死"><a href="#将skip写死" class="headerlink" title="将skip写死"></a>将<code>skip</code>写死</h3><p>这种方式是比较常见的，通常适用于设计时确定了调用层数的情况，以日志系统为例，我们现在要提供一个接口<code>log</code>，那么我知道外界肯定是要直接调用<code>log</code>的，我最终要打印的就是调用<code>log</code>的函数的文件名，所在行，函数名</p><p>那么如果我是在<code>log</code>里使用<code>runtime.Caller</code>，那么我的<code>skip</code>就应该是<code>1</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(logLevel <span class="keyword">int</span>, logMessage <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    pc, file, line, ok := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我还做了封装，那么就要根据编写代码时的封装层数调整<code>skip</code>，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(logLevel <span class="keyword">int</span>, logMessage <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    logHelper(logLevel, logMessage)</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logHelper</span><span class="params">(logLevel <span class="keyword">int</span>, logMessage <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    logReal(logLevel, logMessage)</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logReal</span><span class="params">(logLevel <span class="keyword">int</span>, logMessage <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    pc, file, line, ok := runtime.Caller(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例中，由于多了两层封装，所以要把<code>skip</code>更改为3</p><h3 id="尝试自动获取"><a href="#尝试自动获取" class="headerlink" title="尝试自动获取"></a>尝试自动获取</h3><p>这次的尝试自动获取是我在编写日志系统时遇到的一个比较特殊的情况</p><p>在上面说的<a href="#将skip写死">#将skip写死</a>中，其实我们有一个重要的前提，那就是</p><blockquote><p>业务函数<strong>全部</strong>直接调用日志接口<code>log</code></p></blockquote><p>但是这次在开发日志系统时，遇到了这样的场景:</p><blockquote><p>日志拥有接口<code>log1</code>和<code>log2</code>，<code>log2</code>调用<code>log1</code>，业务代码既可能调用<code>log2</code>，也可能直接调用<code>log1</code><br><code>log1</code>下层调用<code>runtime.Caller</code>和<code>runtime.FuncForPC</code>组合</p></blockquote><p>这种情况下，<code>skip</code>是不可能写死在源代码里的，于是采取的解决方案如下</p><blockquote><p>由于日志系统在一个独立的包里，所以在<code>FuncForPC</code>将函数名取出来以后，判断是否是日志包中的函数，如果是，就增加<code>skip</code>的值</p></blockquote><p>实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> skip := <span class="number">1</span>; <span class="literal">true</span>; skip++ &#123;</span><br><span class="line">    pc, codePath, codeLine, ok := runtime.Caller(skip)</span><br><span class="line">    <span class="keyword">if</span> !ok&#123;</span><br><span class="line">        <span class="comment">// 不ok，函数栈用尽了</span></span><br><span class="line">        auto.Code = prevCode</span><br><span class="line">        auto.Func = prevFunc</span><br><span class="line">        <span class="keyword">return</span> auto</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        prevCode = fmt.Sprintf(<span class="string">"%s:%d"</span>, codePath, codeLine)</span><br><span class="line">        prevFunc = runtime.FuncForPC(pc).Name()</span><br><span class="line">        auto.Code = prevCode</span><br><span class="line">        auto.Func = prevFunc</span><br><span class="line">        <span class="keyword">if</span> !strings.Contains(prevFunc, <span class="string">"&lt;package_name&gt;"</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到包外的函数了</span></span><br><span class="line">            <span class="keyword">return</span> auto</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就算是一个能够解决问题的方案了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章介绍了作者在参与一个golang日志系统的开发的时候，解决需要打印出执行&lt;strong&gt;日志打印操作&lt;/strong&gt;时的&lt;strong&gt;业务函数名，业务文件名与所在行数&lt;/strong&gt;的需求过程中，遇到的问题和解决方案&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Vue+Axios自动更新</title>
    <link href="https://rivers-shall.github.io/2020/05/25/Vue-Axios%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"/>
    <id>https://rivers-shall.github.io/2020/05/25/Vue-Axios自动更新/</id>
    <published>2020-05-25T14:29:58.000Z</published>
    <updated>2020-05-28T06:56:19.816Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章记录了作者在使用Vue+Axios实现前端自动刷新数据时，遇到的一个坑点。</p><a id="more"></a><h2 id="场景需求"><a href="#场景需求" class="headerlink" title="场景需求"></a>场景需求</h2><p>在一个Vue单页应用中，使用VueRouter实现了App组件中点击链接后呈现Component组件的功能</p><p>App.Vue -&gt; Component.Vue</p><p>现在需要：在Component加载出来之后，每间隔1s的时间，自动通过Axios向后端接口获取数据并更新。</p><h2 id="有问题的实现方式"><a href="#有问题的实现方式" class="headerlink" title="有问题的实现方式"></a>有问题的实现方式</h2><p>App.Vue，内置router-link，可以跳转呈现Component</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// App.Vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;router-link :to=&quot;/Component&quot;&gt;Component&lt;/router-link&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>Component.Vue，在创建时，使用<code>setInterval</code>创建1s中的循环动作，在动作中使用Axios获取后端数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Component.Vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        // 设置一个间隔1s就进行的动作</span><br><span class="line">        setInterval(() =&gt; &#123;</span><br><span class="line">            Axios.get(&quot;/data&quot;).then((res) =&gt; &#123;</span><br><span class="line">                // 业务逻辑</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>出现问题的原因在于：</p><p><strong>只有<code>setInterval</code>，没有<code>clearInterval</code></strong></p><p>一个循环任务一旦被创建，就没有被销毁的可能，但是每次用户点击<code>Component</code>链接，都会创建<code>Component</code>实例，产生循环任务。</p><p>如果用户多次点击了<code>App.Vue</code>中的<code>Component</code>链接，那么就会在前端浏览器里产生多个循环任务，不断发送请求，最终导致前后端都不堪重负。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过<code>data</code>记录<code>created</code>中产生的循环任务，并在<code>beforeDestroy</code>里加入<code>clearInterval</code>清除它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Component.Vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            timer : &#123;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        // 设置一个间隔1s就进行的动作</span><br><span class="line">        this.timer = setInterval(() =&gt; &#123;</span><br><span class="line">            Axios.get(&quot;/data&quot;).then((res) =&gt; &#123;</span><br><span class="line">                // 业务逻辑</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy() &#123;</span><br><span class="line">        clearInterval(this.timer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章记录了作者在使用Vue+Axios实现前端自动刷新数据时，遇到的一个坑点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://rivers-shall.github.io/tags/Vue/"/>
    
      <category term="Axios" scheme="https://rivers-shall.github.io/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>golang中使用elasticsearch</title>
    <link href="https://rivers-shall.github.io/2020/05/24/golang%E4%B8%AD%E4%BD%BF%E7%94%A8elasticsearch/"/>
    <id>https://rivers-shall.github.io/2020/05/24/golang中使用elasticsearch/</id>
    <published>2020-05-24T13:47:20.000Z</published>
    <updated>2020-05-28T06:56:19.816Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇介绍如何利用golang第三方库<a href="https://github.com/olivere/elastic" target="_blank" rel="noopener">https://github.com/olivere/elastic</a>进行elasticsearch的操作的文章。<br>文章中并不会介绍非常详细的API，更侧重于作者在工作中的使用经验和查文档经验。文章中主要包括以下内容：</p><ol><li>作者认为比较重要的API设计理念以及文档查阅方式</li><li>作者在工作中使用到的elasticsearch的实例，包括从接到需求，查阅文档，并实现的过程</li></ol><a id="more"></a><h2 id="API设计理念思考"><a href="#API设计理念思考" class="headerlink" title="API设计理念思考"></a>API设计理念思考</h2><h3 id="API的分类"><a href="#API的分类" class="headerlink" title="API的分类"></a>API的分类</h3><p>在使用elasticsearch的golang Client过程中，我觉得可以将olivere/elastic的常用API分作三类：</p><ol><li>面向elasticsearch的metadata的Service</li><li>面向elasticsearch的data的Service</li><li>面向Query</li></ol><p>而这三类分别对应了对elasticsearch的不同类别的操作：</p><ol><li>面向elasticsearch的metadata的Service，主要是对elasticsearch的metadata进行查询和操作，比如<ul><li>配置elasticsearch</li><li>查询elasticsearch的状态，比如集群状态，节点数目等</li></ul></li><li>面向elasticsearch的data的Service，住哟是对elasticsearch内的数据和数据格式进行操作<ol><li>elasticsearch中的index的metadata进行操作，比如<ol><li>查询是否存在某个index</li><li>创建并配置index</li></ol></li><li>elasticsearch中的index下的document的增删改操作</li></ol></li><li>面向Query，主要是对index下的document的查询操作</li></ol><h3 id="分类在代码中的体现"><a href="#分类在代码中的体现" class="headerlink" title="分类在代码中的体现"></a>分类在代码中的体现</h3><p>首先需要说明，在olivere/elastic的所有操作都是依靠生成一个<code>XXXService</code>对象然后<code>XXXService.Do(ctx)</code>来实现的，这里将他们分成面向Service和面向Query只是表示后者我们的主要精力都会集中在构造Query上</p><h4 id="面向elasticsearch的metadata的Service"><a href="#面向elasticsearch的metadata的Service" class="headerlink" title="面向elasticsearch的metadata的Service"></a>面向elasticsearch的metadata的Service</h4><p>面向elasticsearch的metadata的Service，一般是通过建立连接的ESClient，新建出查询或者操作所需的Service，而后进行操作的模式</p><p>比如如下，查询集群内es节点数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立连接的Client</span></span><br><span class="line">esClient, _ := elastic.NewClient()</span><br><span class="line"><span class="comment">// 新建出用于操作的Service</span></span><br><span class="line">clusterHealthClient := elastic.NewClusterHealthService(esClient)</span><br><span class="line"><span class="comment">// 查询，拿到结果</span></span><br><span class="line">result, _:= clusterHealthClient.Do(context.Background())</span><br><span class="line">fmt.Println(result.NumberOfNodes)</span><br></pre></td></tr></table></figure><h4 id="面向elasticsearch的data的Service"><a href="#面向elasticsearch的data的Service" class="headerlink" title="面向elasticsearch的data的Service"></a>面向elasticsearch的data的Service</h4><p>面向elasticsearch的data的Service，一般是通过建立连接的ESClient的成员函数直接取得Service，而后进行操作</p><p>比如如下，新建索引</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new index.</span></span><br><span class="line">mapping := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">    "settings":&#123;</span></span><br><span class="line"><span class="string">        "number_of_shards":1,</span></span><br><span class="line"><span class="string">        "number_of_replicas":0</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "mappings":&#123;</span></span><br><span class="line"><span class="string">        "properties":&#123;</span></span><br><span class="line"><span class="string">            "tags":&#123;</span></span><br><span class="line"><span class="string">                "type":"keyword"</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            "location":&#123;</span></span><br><span class="line"><span class="string">                "type":"geo_point"</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            "suggest_field":&#123;</span></span><br><span class="line"><span class="string">                "type":"completion"</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">ctx := context.Background()</span><br><span class="line">createIndex, _ := esClient.CreateIndex(<span class="string">"twitter"</span>).BodyString(mapping).Do(ctx)</span><br><span class="line">fmt.Println(createIndex.Index)</span><br></pre></td></tr></table></figure><h4 id="面向Query"><a href="#面向Query" class="headerlink" title="面向Query"></a>面向Query</h4><p>面向Query，一般是先新建出Query，而后通过<code>client.Search().Index(index).Query(query).Do(ctx)</code>的方式执行查询操作</p><p>比如如下，查询上一个构造的索引中，<code>tags</code>字段含有<code>test</code>的document</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query := elastic.NewBoolQuery()</span><br><span class="line">query = query.Must(elastic.NewTermQuery(<span class="string">"tags"</span>, <span class="string">"test"</span>))</span><br><span class="line">result, _ := esClient.Search().Index(<span class="string">"twitter"</span>).Query(query).Do(context.Background())</span><br></pre></td></tr></table></figure><h2 id="API文档的查询方法"><a href="#API文档的查询方法" class="headerlink" title="API文档的查询方法"></a>API文档的查询方法</h2><p>查询olivere/elastic的文档，主要有三个来源：</p><ol><li>项目Wiki <a href="https://github.com/olivere/elastic/wiki" target="_blank" rel="noopener">https://github.com/olivere/elastic/wiki</a></li><li>源代码 <a href="https://github.com/olivere/elastic" target="_blank" rel="noopener">https://github.com/olivere/elastic</a></li><li>elasticsearch官方文档 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></li></ol><p>这三者各有特点：</p><ol><li>项目Wiki<ul><li>优点：简单直接，并且会给出相应的操作的示例代码，上手很快</li><li>缺点：示例较简单，且不全面，面对复杂逻辑/特定逻辑很可能缺乏指导性，或者找不到相关文档</li></ul></li><li>源代码<ul><li>优点：全面而且本质的东西，掌握了源代码就掌握了一切</li><li>缺点：复杂，费力，考虑投入产出比，几乎绝无必要源码级掌握(除非想成为库的开发者)</li></ul></li><li>elasticsearch官方文档<ul><li>优点：比较齐全的同时仍然是可读性较高的文档，难度在项目Wiki和源代码之间</li><li>缺点：没有直接对应到olivere/elastic的API上，找到elasticsearch的API之后，要回头再找olivere/elastic的API</li></ul></li></ol><p>一般的查询方式如下：</p><ol><li>首先明确需求，即到底需要获得elasticsearch的什么信息或者对其进行什么操作</li><li>明确需求后先查阅Wiki，如果有相应的条目，可用的就可以直接用了</li><li>Wiki中找不到，那就按照<a href="#api设计理念思考">api设计理念思考</a>中描述的进行分类</li><li>分类后有两条路径<ol><li>源代码中寻找对应的Service或者Query接口，找到后去elasticsearch文档验证</li><li>elasticsearch文档中寻找对应的查询接口，找到后去olivere/elastic中找对应的接口</li></ol></li></ol><p>当然，合理利用其他资源作为文档入口也是有必要的(或许这才是很多人的首选)：</p><ol><li>Stack Overflow，启动！</li><li>输入关键字查询，能找到合适的问答，就直接采用，不能就返回上述的一般查询方式</li></ol><h2 id="使用实例与解决过程"><a href="#使用实例与解决过程" class="headerlink" title="使用实例与解决过程"></a>使用实例与解决过程</h2><h3 id="查询集群的健康状态"><a href="#查询集群的健康状态" class="headerlink" title="查询集群的健康状态"></a>查询集群的健康状态</h3><p>过程：</p><ol><li>查阅Wiki，没有</li><li>查阅源代码，cluster为关键字查找，找到cluster_health.go，前往注释中指定的elasticsearch文档<a href="http://www.elastic.co/guide/en/elasticsearch/reference/7.0/cluster-health.html" target="_blank" rel="noopener">http://www.elastic.co/guide/en/elasticsearch/reference/7.0/cluster-health.html</a>验证想法</li><li>想法验证成功，编程</li></ol><h3 id="实现text类型的字段的模糊查找"><a href="#实现text类型的字段的模糊查找" class="headerlink" title="实现text类型的字段的模糊查找"></a>实现text类型的字段的模糊查找</h3><p>过程：</p><ol><li>查找Wiki，没有</li><li>源代码，elasticsearch文档没有“模糊查找”相关的部分</li><li>stack overflow 搜索 match part of text，找到使用正则表达式查询RegexQuery的方法</li><li>返回elasticsearch文档验证，验证成功</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇介绍如何利用golang第三方库&lt;a href=&quot;https://github.com/olivere/elastic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/olivere/elastic&lt;/a&gt;进行elasticsearch的操作的文章。&lt;br&gt;文章中并不会介绍非常详细的API，更侧重于作者在工作中的使用经验和查文档经验。文章中主要包括以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作者认为比较重要的API设计理念以及文档查阅方式&lt;/li&gt;
&lt;li&gt;作者在工作中使用到的elasticsearch的实例，包括从接到需求，查阅文档，并实现的过程&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="elasticsearch" scheme="https://rivers-shall.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>看不清的答案</title>
    <link href="https://rivers-shall.github.io/2020/03/10/%E7%9C%8B%E4%B8%8D%E6%B8%85%E7%9A%84%E7%AD%94%E6%A1%88/"/>
    <id>https://rivers-shall.github.io/2020/03/10/看不清的答案/</id>
    <published>2020-03-10T11:41:47.000Z</published>
    <updated>2020-05-28T06:56:19.816Z</updated>
    
    <content type="html"><![CDATA[<p>莫非你在故作冷傲？<br>为何心为你如此牵动<br>从来如此 不知不觉<br>我一直在追寻你</p><p>要怎样才能将你<br>镌刻在事实的巨岩上</p><p>当我第一次绞尽脑汁<br>当你第一次映在心间<br>你的内容 竟如此模糊<br>让我茫然四顾 徘徊踌躇</p><p>要怎样才能将你<br>从梦的迷雾中取出</p><p>即使是一份终成过往的答案<br>是否也有镌刻在事实上的一天<br>在能够看见隐约的曙光之前<br>这份答案 依旧如雾中花 水中月</p><hr><p>我究竟喜爱着什么，痛恨着什么，努力追寻着什么，回忆的过往仿佛空无一物，展望的未来确实迷雾一片，我到底，该怎么办呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;莫非你在故作冷傲？&lt;br&gt;为何心为你如此牵动&lt;br&gt;从来如此 不知不觉&lt;br&gt;我一直在追寻你&lt;/p&gt;
&lt;p&gt;要怎样才能将你&lt;br&gt;镌刻在事实的巨岩上&lt;/p&gt;
&lt;p&gt;当我第一次绞尽脑汁&lt;br&gt;当你第一次映在心间&lt;br&gt;你的内容 竟如此模糊&lt;br&gt;让我茫然四顾 徘徊踌躇&lt;/p&gt;
      
    
    </summary>
    
      <category term="程序人生" scheme="https://rivers-shall.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络复习-第五章</title>
    <link href="https://rivers-shall.github.io/2019/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <id>https://rivers-shall.github.io/2019/12/31/计算机网络复习-第五章/</id>
    <published>2019-12-31T12:00:00.000Z</published>
    <updated>2020-05-28T06:56:19.816Z</updated>
    
    <content type="html"><![CDATA[<p>《Computer Networking - A Top-Down Approach》第五章复习知识点总结</p><a id="more"></a><p>第五章主要介绍如何配置和管理网络，以及这其中使用到的各种协议如OSPF，BFP，ICMP，SNMP</p><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><p>转发和路由之间的桥梁就是转发表：</p><ul><li>转发功能使用转发表进行包的转发</li><li>路由功能配置，更新，维护转发表以便转发使用</li></ul><p>而路由功能可以通过两种方式来实现：</p><ol><li>分布式的各路由器处理(Per-router control)<ol><li>每个路由器上都有一个路由处理单元，他们通过和邻居路由器的路由处理单元的通信，计算出路由表</li></ol></li><li>集中式的中央处理(Logically centralized control)<ol><li>存在一个中央处理单元负责计算所有的路由器上的路由表并将其分发到各个路由器上</li><li>每个路由器上又一个Control Agent负责接收中央处理单元的命令，更新路由表</li></ol></li></ol><h2 id="5-2-路由算法"><a href="#5-2-路由算法" class="headerlink" title="5.2 路由算法"></a>5.2 路由算法</h2><p>对于一个网络，可以将其抽象为一个图，路由器和链路分别对应图中的节点和边。</p><p>路由算法的任务，就是找出图上点对之间的最小距离及最小距离对应的路径。</p><p>路由算法的分类：</p><ul><li>中心化的或去中心化的<ul><li>中心化的路由算法是基于对整个网络有着完整的认识基础上进行最短路径计算的<ul><li>中心化路由算法可以由中央处理单元进行，也可以在每个路由器上分别进行</li><li>这需要在计算路由之前首先获得整个网络的链路信息</li><li>中心化路由算法又被称为LS(link-state)算法</li></ul></li><li>去中心化的路由算法是仅基于各个路由器知道邻居路由器之间的链路和链路代价进行最短路径计算的<ul><li>去中心化的路由算法是分布式的，分散在各个路由器上进行计算</li><li>去中心化的路由算法又被称为DV(distance-vector)算法</li></ul></li></ul></li><li>动态路由算法或静态路由算法<ul><li>动态路由算法改变比较迅速，随着链路负载和网络拓扑结构的改变而改变路径</li><li>静态路由算法相对来说改变比较少，一般需要认为改变链路代价才会改变路径</li></ul></li><li>负载敏感或负载不敏感<ul><li>负载敏感的路由算法随着链路拥塞情况的改变会改变路径</li><li>负载不敏感的路由算法于链路拥塞情况无关</li><li>负载敏感的路由算法实现起来困难重重，现实中使用的都是负载不敏感的算法</li></ul></li></ul><h3 id="5-2-1-LS-Link-State-算法"><a href="#5-2-1-LS-Link-State-算法" class="headerlink" title="5.2.1 LS(Link-State) 算法"></a>5.2.1 LS(Link-State) 算法</h3><p>LS算法需要提前知道网络中的链路结构和链路代价，一般来讲，这是通过各个路由节点广播自身周围的链路与链路代价完成的。</p><p>而后所有的节点都会对整个网络有了了解，每个节点都可以运行LS算法，计算最短路径。</p><p>Dijkstra‘s Algorithm是一个常用于LS算法的图论最短路算法。在运行了Dijkstra‘s Algorithm后，路由器上就只需要存储&lt;目的地，下一跳链路&gt;对就可以了。</p><p>但是如果希望满足负载敏感的话，就会出现路由震荡的情况，解决的办法是让路由器在不同的时间点上进行路径计算，但是因特网路由器被发现是自同步的，也就是说即便一开始设置了不同的时间点，后来也会变成同一时间点计算，最后的办法就是随机时间发送路由控制包。</p><h3 id="5-2-2-DV-Distance-Vector-算法"><a href="#5-2-2-DV-Distance-Vector-算法" class="headerlink" title="5.2.2 DV(Distance-Vector) 算法"></a>5.2.2 DV(Distance-Vector) 算法</h3><p>在DV算法中，每个路由器接收来自邻居路由器的消息，计算路径，而后将结果再交给邻居路由器。常此往复，知道没有消息传递为止。</p><ul><li>DV算法是去中心化的算法，不需要知道所有链路结构和代价</li><li>DV算法是异步算法，不需要同步，只需要接受消息并计算</li><li>DV算法是自终止算法，不需要特定的消息提醒终止，当链路上没有消息传递时，自动终止</li></ul><p>Bellman-Ford等式是DV算法的重要基础：</p><p>$d(x,y)=\min_v{c(x,v) + d(v, y)}$</p><p>其中$v$是$x$的邻居，$d(x,y)$代表$x,y$之间的最短路径，$c(x,v)$代表$x,v$之间的路径代价。</p><p>这个等式对于$x$的取值揭示了从$x$到$y$所需要的下一跳目标$v$。而且所需要用到的信息只有$x$本身和邻居的信息。</p><p>所以路由器x上存储了：</p><ul><li>x到周围邻居的链路代价</li><li>x的距离矢量，也即x到所有节点的最小路径长度</li><li>x的邻居的距离矢量</li></ul><p>在DV算法中，每个路由器会将自己的距离矢量发送给邻居，邻居接收到后根据Bellman-Ford等式修改自己的距离矢量，如果修改成功，就将更新后的自己的距离矢量发送给邻居，最终距离矢量收敛到真正的最小距离。</p><h4 id="count-to-infinity问题和poisoned-reverse"><a href="#count-to-infinity问题和poisoned-reverse" class="headerlink" title="count-to-infinity问题和poisoned reverse"></a>count-to-infinity问题和poisoned reverse</h4><p>count-to-infinity 是指由于链路代价的变化，使得某个节点x选择前往y的最短路下一跳时选择了z，但同时z前往y的最短路下一跳是x。这时在转发表中就形成了一个环。</p><p>解决这个问题的办法是，如果z前往y的最短路下一跳是x，那么在向x发送距离矢量的时候，告知z前往y的代价是无穷大，避免x选择前往y的下一跳时选择z，这就是poisoned reverse。</p><p>但是poisoned reverse也不能完全解决count-to-infinity问题。</p><h4 id="LS-和-DV-算法比较"><a href="#LS-和-DV-算法比较" class="headerlink" title="LS 和 DV 算法比较"></a>LS 和 DV 算法比较</h4><p>从消息复杂度，时间复杂度和鲁棒性来看，两个算法都不相上下。</p><p>其中LS需要$O(|V||E|)$的消息复杂度，$O(n^2)$的时间复杂度，由于计算是每个路由器独立计算，提供了一定的鲁棒性，但是一个路由器的错误消息也会被传递到所有路由器上进行计算。</p><p>DV的消息复杂度和时间复杂度都很难确定，鲁棒性上来看，一个错误的距离矢量也可能被传播到许多路由器上。</p><h2 id="5-3-intra-AS-Routing-in-the-Internet-OSPF"><a href="#5-3-intra-AS-Routing-in-the-Internet-OSPF" class="headerlink" title="5.3 intra-AS Routing in the Internet: OSPF"></a>5.3 intra-AS Routing in the Internet: OSPF</h2><p>在之前的讨论中，我们一直对路由网络做了简化，其中只有路由器和链路，但事实上，我们忽略了以下两个重要因素：</p><ul><li>规模。大规模的网络不可以向上述讨论一样简单使用普通的路由协议。因为即便只是存储下一跳的目标，都需要极大的内存。</li><li>管理自治。不同的网络一般需要进行独立的管理，但是将所有的路由器纳入一个路由协议下，显然不能满足这个需求。</li></ul><p>于是自治系统应运而生，也就是说，一个自治系统内，使用统一的路由协议进行管理，对外暴露网关进行通信，这样既能够通过控制自治系统的大小来控制路由协议作用的规模，也能实现自治系统内部的管理自治。</p><h3 id="OSPF-Open-Shortest-Path-First"><a href="#OSPF-Open-Shortest-Path-First" class="headerlink" title="OSPF(Open Shortest Path First)"></a>OSPF(Open Shortest Path First)</h3><p>OSPF协议就是自治系统内部的路由协议。Open的意思是开源的，他的各种细则声明都可以在网上查到。</p><p>OSPF是一个LS算法的协议。所有的路由器首先以广播洪泛的方式将整个网络的链路结构和链路代价存储下来，而后使用Dijkstra‘s Algorithm进行最短路径和下一跳的计算。</p><p>同时OSPF并不涉及链路代价的配置，这个配置是有人为决定的。</p><p>所有的OSPF消息都由IP包携带，通过将IP包头中的上层协议域设置为89表明这是OSPF消息包。</p><p>OSPF支持以下的特性：</p><ul><li>安全。OSPF消息可以进行验证，验证方式有两种 — 简单验证和MD5验证。<ul><li>简单验证<ul><li>每个路由器上存放有明文密码</li><li>传输消息时将明文密码放在消息里。</li></ul></li><li>MD5验证<ul><li>每个路由器上存放有MD5密钥</li><li>传输消息时将消息内容和MD5密钥结合算法产出一段哈希值，放在内容后面</li><li>收到消息的路由器使用密钥再度哈希内容并和传来的哈希值比较，如果一致，验证就通过。</li><li>MD5验证时还会有序列号，防备replay攻击。</li></ul></li></ul></li><li>多个同代价的路径。<ul><li>在选择最短路径时，可能会有多条路径，OSPF并不要求一定要选择一条，可以多条一起使用，降低负载压力。</li></ul></li><li>单播和多播的整合支持</li><li>自治系统内部的再度结构化<ul><li>自治系统内部可以在被分成不同的区域</li><li>有一个特殊区域为backbone area</li><li>一个区域内部自由通信</li><li>一个区域边界会有一个border router，用于和别的区域通信</li><li>不同区域通信需要先经过border router，进入backbone area，再从border router出去到目标区域的border router，再进入区域，到达终点</li></ul></li></ul><h2 id="5-4-Routing-Around-the-ISPs-BGP"><a href="#5-4-Routing-Around-the-ISPs-BGP" class="headerlink" title="5.4 Routing Around the ISPs: BGP"></a>5.4 Routing Around the ISPs: BGP</h2><p>当我们需要在不同的自治系统之间进行通信时，OSPF就不能满足我们的需要了，同时，在不同的自治系统之间进行通信必须使用统一的协议，而实际上在因特网里就是全部使用的边际网关协议(Border Gateway Protocol)进行自治系统之间的通信。</p><p>对于一个自治系统内的主机，我们是使用IP地址进行的定位，但是对于一整个自治系统，我们是使用IP地址前缀进行定位。</p><h3 id="5-4-1-The-Role-of-BGP"><a href="#5-4-1-The-Role-of-BGP" class="headerlink" title="5.4.1 The Role of BGP"></a>5.4.1 The Role of BGP</h3><p>对于一个自治系统间的通信协议，BGP需要提供一下两个基本的功能：</p><ol><li>获取可到达的子网前缀。对于一个自治系统，他需要知道自己能够和哪些自治系统通信，以及这些自治系统的IP地址前缀是什么。</li><li>获取自治系统间的最好路径。</li></ol><p>这两个功能是通过在路由器中存储&lt;子网前缀，输出端口&gt;的表来实现的</p><h3 id="5-4-2-Advertising-BGP-Route-Information"><a href="#5-4-2-Advertising-BGP-Route-Information" class="headerlink" title="5.4.2 Advertising BGP Route Information"></a>5.4.2 Advertising BGP Route Information</h3><p>BGP协议是通过TCP连接来获取路由信息的：</p><ul><li>不同自治系统之间的BGP连接称为eBGP连接</li><li>自治系统内部的BGP连接称为iBGP连接</li></ul><p>注：BGP连接是逻辑连接，BGP连接的两端之间可能有多条链路</p><p>想要告知其他自治系统关于子网前缀的信息，就必须使用BGP消息：</p><ol><li>源节点首先发出BGP消息</li><li>在路径上的自治系统网关通过eBGP连接收到消息</li><li>网关通过iBGP将消息广播到自治系统内的所有节点</li><li>网关继续通过eBGP将消息传递到其他的自治系统</li></ol><h3 id="5-4-3-Determining-the-Best-Routes"><a href="#5-4-3-Determining-the-Best-Routes" class="headerlink" title="5.4.3 Determining the Best Routes"></a>5.4.3 Determining the Best Routes</h3><p>当一个子网前缀通过BGP消息在自治系统间进行传输时，还会带上额外的属性：</p><ul><li>AS-PATH，记录传播这个消息所经过的自治系统路径，同时可以作为环路检测–如果一个自治系统发现AS-PATH上有自己的名称，就说明出现环路，可以直接丢弃BGP消息</li><li>NEXT-HOP，AS-PATH的起始节点的IP地址</li></ul><p>这两个属性是众多属性中对于选路最重要的两个属性。</p><p>也就是说，我们现在有的是多个(子网前缀，AS-PATH，NEXT-HOP)元组，这被称为一条路径，BGP需要决定最优路径</p><h4 id="烫手山芋路由-Hot-Potato-Routing"><a href="#烫手山芋路由-Hot-Potato-Routing" class="headerlink" title="烫手山芋路由 (Hot Potato Routing)"></a>烫手山芋路由 (Hot Potato Routing)</h4><p>烫手山芋路由的主要原则是：</p><blockquote><p>尽量使得包在本自治系统内的时间短</p></blockquote><p>所以烫手山芋路由采用的策略是：</p><blockquote><p>选取从当前节点到NEXT-HOP最短的路径</p></blockquote><p>我们可以看到，在这个过程中，起作用的最主要不是BGP，而是自治系统内部的路由协议(比如OSPF)，因为从当前自治系统的网关到达NEXT-HOP只有一条链路(这就是NEXT-HOP的定义)，剩余的代价是由当前节点到网关的代价决定的。</p><h4 id="Route-Selection-Algorithm"><a href="#Route-Selection-Algorithm" class="headerlink" title="Route Selection Algorithm"></a>Route Selection Algorithm</h4><p>实际上，BGP使用更加复杂的策略进行选路：</p><ol><li>每条路径有一个本地偏好，选择本地偏好最优的。本地偏好由路由器自己设置或者由邻居路由学习而来，但是产生本地偏好的策略是由路由管理者人为设置的。</li><li>在剩余的路径中，选择AS-PATH最短的。</li><li>在剩余的路径中，采用烫手山芋路由策略。</li><li>如果还有多条路径，使用BGP identifier选路</li></ol><h3 id="5-4-4-IP任播"><a href="#5-4-4-IP任播" class="headerlink" title="5.4.4 IP任播"></a>5.4.4 IP任播</h3><p>IP任播的意思是给出一组服务器，向其播送IP包，但是最终只能有一个服务器收到IP包。</p><p>IP任播可以用于DNS服务，因为所有的DNS服务最终返回的结果都是一样的(域名对应的IP地址)，但是需要选择一个最近的DNS服务器以便更快地获得结果。也就是要对一组DNS服务器发送请求，但是最终只需要一个DNS服务器回复就可以。</p><p>使用BGP实现IP任播的原理是：</p><ol><li>给所有服务器赋予相同的IP地址(虽然说不同的主机需要唯一IP地址，但是由于这里的服务器提供的服务是一摸一样的，所以这么做没问题)</li><li>当使用BGP进行路由注册时，BGP自动使用选路策略完成了到当前最近的服务器的选路</li><li>接下来向该IP地址发送包，就已经是最近的服务器了</li></ol><h3 id="5-4-5-Routing-Policy"><a href="#5-4-5-Routing-Policy" class="headerlink" title="5.4.5 Routing Policy"></a>5.4.5 Routing Policy</h3><p>对于选路，最终其实还是靠策略来决定选择的路径。</p><p>树上描述了一个情境，比如希望B不要选择通过X发包到C，避免这样的做法就是在策略中是的X不告知B从X可以发到C。</p><h3 id="5-4-6-Putting-the-Pieces-Together-Obtaining-Internet-Presence"><a href="#5-4-6-Putting-the-Pieces-Together-Obtaining-Internet-Presence" class="headerlink" title="5.4.6 Putting the Pieces Together: Obtaining Internet Presence"></a>5.4.6 Putting the Pieces Together: Obtaining Internet Presence</h3><p>假设你开了一家公司，架设了几台服务器，那么，想要全世界访问你的网站，需要如下操作：</p><ol><li>获得物理连接，接到一个ISP上</li><li>获得IP地址分配，在这一步，获得了子网的IP地址前缀，并且通过BGP注册到了各个路由器上</li><li>将具体的IP地址分配给每一台主机</li><li>购买域名，提供你的DNS服务器IP地址，顶层域名上会注册你的域名和DNS服务器地址</li><li>用户访问，首先通过顶级域名DNS服务器获得你的DNS服务器地址，通过你的DNS服务器获得你的其他服务器地址，而后建立TCP连接</li></ol><h2 id="5-6-ICMP-Internet-Control-Message-Protocol"><a href="#5-6-ICMP-Internet-Control-Message-Protocol" class="headerlink" title="5.6 ICMP(Internet Control Message Protocol)"></a>5.6 ICMP(Internet Control Message Protocol)</h2><p>ICMP在结构上是传输层协议，ICMP消息通过IP包的负载传递。</p><p>但是在作用上，ICMP是用于传递IP协议的信息的，尤其是报错信息。</p><p>ICMP消息有三个部分，类型，消息码和产生ICMP消息的IP包的前8个字节。</p><p>ping命令原理：ping向目标服务器发送类型8消息码0的ICMP消息，服务器返回类型0消息码0的回应。</p><p>traceroute命令原理：</p><ul><li>traceroute向目标服务器传递UDP消息</li><li>但是将外层的IP协议包头的TTL设置为1，2，3，…一直下去</li><li>每次当TTL到0，IP包被丢弃的时候，路由器都会发送特定的ICMP消息告知traceroute</li><li>最终到达目标时，由于traceroute传出的UDP包端口号是无效的，目标服务器也会发ICMP消息告知traceroute</li><li>此时的ICMP和之前的不同，所以traceroute也停止了UDP包的继续发送</li><li>通过这些消息到达计时，traceroute算出每一跳的时间</li></ul><h2 id="5-7-Network-Management-and-SNMP"><a href="#5-7-Network-Management-and-SNMP" class="headerlink" title="5.7 Network Management and SNMP"></a>5.7 Network Management and SNMP</h2><p>网络管理其实类似于网络配置，使用一定的协议进行通讯并对网络中各个组件的参数进行监控和配置。</p><h3 id="5-7-1-网络管理框架"><a href="#5-7-1-网络管理框架" class="headerlink" title="5.7.1 网络管理框架"></a>5.7.1 网络管理框架</h3><p>网络管理有如下部分组成：</p><ol><li>网络管理服务器，一般有人在服务器上进行操控</li><li>被管理设备，一个软硬都包含的设备，设备上有一个或者多个被管理对象</li><li>每个被管理对象都有一个MIB(Management Information Base)，用于存储对象相关的参数</li><li>每个被管理设备上都有一个管理用户程序，用于和网络管理服务器通信和修改MIB</li><li>网络管理协议</li></ol><h3 id="5-7-2-SNMP-Simple-Network-Manangement-Protocol"><a href="#5-7-2-SNMP-Simple-Network-Manangement-Protocol" class="headerlink" title="5.7.2 SNMP (Simple Network Manangement Protocol)"></a>5.7.2 SNMP (Simple Network Manangement Protocol)</h3><p>一个网络管理协议是用来在网络管理服务器和管理用户程序之间传递消息的，SNMP就是一个网络管理服务器，SNMP消息有如下类型：</p><ol><li>服务器主动联系用户程序，发送消息，用户程序接收消息，采取行动，并返回结果消息</li><li>被管理设备出现意外状况，MIB改变，用户程序主动联系服务器。通知服务其MIB改变</li></ol><p>SNMP的具体消息类型有如下几类：</p><ol><li>Get*Request用于获取被管理设备MIB的信息</li><li>SetRequest用于设置被管理设备的MIB</li><li>InformRequest用于通知别的管理服务器一些接收不到的MIB信息</li><li>Response用于用户程序回复管理服务器</li><li>Trap用于用户程序通知服务器特定的事件发生了</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Computer Networking - A Top-Down Approach》第五章复习知识点总结&lt;/p&gt;
    
    </summary>
    
      <category term="NJU-Class" scheme="https://rivers-shall.github.io/categories/NJU-Class/"/>
    
      <category term="计算机网络" scheme="https://rivers-shall.github.io/categories/NJU-Class/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络复习-第四章</title>
    <link href="https://rivers-shall.github.io/2019/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <id>https://rivers-shall.github.io/2019/12/31/计算机网络复习-第四章/</id>
    <published>2019-12-31T02:11:35.000Z</published>
    <updated>2020-05-28T06:56:19.816Z</updated>
    
    <content type="html"><![CDATA[<p>《Computer Networking - A Top-Down Approach》第四章4.1-4.3复习知识点总结</p><a id="more"></a><p>第四章主要是讲网络层，也就是IP协议。</p><h2 id="4-1-网络层概览"><a href="#4-1-网络层概览" class="headerlink" title="4.1 网络层概览"></a>4.1 网络层概览</h2><h3 id="4-1-1-转发和路由"><a href="#4-1-1-转发和路由" class="headerlink" title="4.1.1 转发和路由"></a>4.1.1 转发和路由</h3><p>转发和路由很相近，但是是两个不同的服务，都由网络层进行支持。</p><ul><li>转发。转发是指，一个IP包到达路由器，路由器决定要将这个包从哪一个接口再度发出去，以便该接口到达目的IP地址。这是一个路由器本地的操作。</li><li>路由。路由是指，在整个网络范围内，决定好从一个源地址到目的地址的路线。这是一个全网的操作，通常耗时更长。</li></ul><p>对于路由器来说，<strong>转发表</strong>是最重要的数据结构。</p><p>转发就是靠从IP包中找出几个域，而后从转发表中索引出目的IP地址对应的发出接口。</p><p>路由则是用来决定转发表中的值的。</p><h3 id="4-1-2-网络层服务模型"><a href="#4-1-2-网络层服务模型" class="headerlink" title="4.1.2 网络层服务模型"></a>4.1.2 网络层服务模型</h3><p>网络层服务模型为：最大努力模型，也就是没有任何保证的模型。</p><h2 id="4-2-路由器里有什么"><a href="#4-2-路由器里有什么" class="headerlink" title="4.2 路由器里有什么"></a>4.2 路由器里有什么</h2><p>路由器里有四个重要的组成部分：</p><ol><li>输入端口。输入端口有如下作用：<ol><li>终止物理连接，使得物理链路上传输的bit流进入路由器</li><li>进行链路层包解析，提取出网络层包</li><li>根据网络层的包结构进行转发，如果是控制消息包，比如路由协议的包，就转发给路由处理器，如果是数据包，就查询转发表并发到对应的输出端口上</li></ol></li><li>输出端口，向外传输数据</li><li>Switching Fabric 连接输入端口和输出端口/路由处理器</li><li>路由处理器，使用相应的路由协议，路由算法，维护转发表，接受路由协议消息或向外发送路由协议消息。</li></ol><p>其中，前三个部分一般以硬件实现(因为软件处理速度跟不上链路上包到达的速度，纳秒级的到达速度)，路由处理器一般由软件实现，对处理速度要求不高，因为路由协议的处理一般是毫秒或秒级的。</p><p>由于需要转发，转发之前就一定要根据到达的IP包中的信息进行处理，决定输出端口，而一般情况下有这两种决定方式：</p><ol><li>基于目的地的转发。通过检查IP包的目的IP地址，决定对应的输出端口。</li><li>一般化转发。一般化转发的思想是检查IP包的任意的信息，而后决定对应的输出端口。当然，对于每个IP包检查的信息是一致的，只不过不局限于目的IP地址而已。</li></ol><h3 id="4-2-1-输入端口处理和基于目的地的转发"><a href="#4-2-1-输入端口处理和基于目的地的转发" class="headerlink" title="4.2.1 输入端口处理和基于目的地的转发"></a>4.2.1 输入端口处理和基于目的地的转发</h3><p>输入端口有如下作用：</p><ol><li>终止物理连接，使得物理链路上传输的bit流进入路由器</li><li>进行链路层包解析，提取出网络层包</li><li>根据网络层的包结构进行转发，如果是控制消息包，比如路由协议的包，就转发给路由处理器，如果是数据包，就查询转发表并发到对应的输出端口上</li></ol><p>而对于基于目的地的转发，查询转发表的方式就是<strong>最长前缀匹配</strong>：</p><blockquote><p>对于一个目的IP地址A，转发表中有许多&lt;字符串,端口号&gt;对，将A与这些字符串进行匹配，匹配时仅仅使用A的前缀进行匹配，在所有匹配的字符串中，寻找最长的字符串，其对应的端口号就是输出端口号。</p></blockquote><h3 id="4-2-2-交换-Switching"><a href="#4-2-2-交换-Switching" class="headerlink" title="4.2.2 交换(Switching)"></a>4.2.2 交换(Switching)</h3><p>交换是指Switching Fabric将来自输入端口的IP包转交给输出端口的过程。</p><p>常见的交换方式有如下几种：</p><ul><li>基于主存的交换<ul><li>输入端口将到达的IP包写入主存，而后再从主存中读到输出端口上完成转发</li></ul></li><li>基于总线的交换<ul><li>输入端口给到达的IP包打上标签，发送到总线上，只有对应标签的输出端口会接受这个IP包</li></ul></li><li>基于交叉网络的交换<ul><li>多个端口对应多个总线的交叉网络</li></ul></li></ul><h3 id="4-2-3-输出端口处理"><a href="#4-2-3-输出端口处理" class="headerlink" title="4.2.3 输出端口处理"></a>4.2.3 输出端口处理</h3><p>输出端口需要取出从输入端口转发来的IP包，进行链路层封装后，转发出去。</p><h3 id="4-2-4-排队情境会在哪里出现"><a href="#4-2-4-排队情境会在哪里出现" class="headerlink" title="4.2.4 排队情境会在哪里出现"></a>4.2.4 排队情境会在哪里出现</h3><p>输入排队：如果Switching Fabric转发的速度比<strong>所有</strong>输入端口的IP包到达的速度要慢的话，就会在输入端口出现排队现象。</p><p>同时，排队时会出现行首阻塞(head of line blocking)的现象，也就是说对于一个输入端口上的队列，如果队首的包被阻塞，那么根据先进先出原则，即便后面的包所对应的输出端口没有被占用，也必须等待队首先被取出才行。这会极大降低转发效率。</p><hr><p>输出排队：如果Switching Fabric转发的速度比输出端口的处理速度还要快的话，就会在输出端口出现排队现象。</p><h3 id="4-2-5-Packet-Scheduling-包调度"><a href="#4-2-5-Packet-Scheduling-包调度" class="headerlink" title="4.2.5 Packet Scheduling 包调度"></a>4.2.5 Packet Scheduling 包调度</h3><p>包调度是指在一个输出端口的缓冲区上决定下面转发哪一个包。</p><hr><p>先进先出调度：简单，就是先到达的包先调度处理</p><hr><p>优先级调度排队：在包到达时，会先将包分类，不同的类有不同的优先级，也有自己的队列，取包时先从高优先级的队列中取。相同队列中的包一般以先进先出的方式处理。</p><p>优先级调度通常用在比如：</p><ul><li>网络控制包(比如路由协议包) 优先于 用户数据包</li><li>实时性数据包(比如实时视频会议数据) 优先于 普通数据(比如电子邮件)</li></ul><hr><p>轮询和权值轮询：在包到达时，先将包分类，不同的类有自己的队列，每次取包时，轮流从不同的队列中取。我们也可以为每个队列加上权值，权值高的每次多取几个包再转移到下一个队列中去取包。</p><h2 id="4-3-IP协议，IP地址，IPv4，IPv6"><a href="#4-3-IP协议，IP地址，IPv4，IPv6" class="headerlink" title="4.3 IP协议，IP地址，IPv4，IPv6"></a>4.3 IP协议，IP地址，IPv4，IPv6</h2><h3 id="4-3-1-IPv4包格式"><a href="#4-3-1-IPv4包格式" class="headerlink" title="4.3.1 IPv4包格式"></a>4.3.1 IPv4包格式</h3><p>IPv4包头有如下的域：</p><ul><li>版本号。IPv4或者IPv6</li><li>包头长度。由于IPv4包头有可选的域，于是需要说明一下包头长度</li><li>服务类型(Type of Service)。可以将比如实时性数据包和非实时性数据包区分开来。如何设置由路由器管理者决定。</li><li>包长度。</li><li>Identifier, flags, fragmentation offset.这三者用来处理IP包的分段</li><li>Time-to-live. 这个域用于确保IP包不会在网络中永久循环传播，每次经过一跳，就会减一，直到成为0，路由器就会直接丢弃该IP包。</li><li>上层协议。一般IP包到达目的地，才会通过这个域决定IP包中的数据交给哪个上层协议。类似于传输层的端口号决定传给哪个应用进程。</li><li>包头校验和。用于错误检查。注意，每一跳上，由于Time-to-live会改变，所以校验和也必须重新计算。</li><li>源IP地址，目的IP地址</li><li>可选项</li></ul><h3 id="4-3-2-IPv4包分段"><a href="#4-3-2-IPv4包分段" class="headerlink" title="4.3.2 IPv4包分段"></a>4.3.2 IPv4包分段</h3><p>由于链路层对于最大可传送的链路层包大小有限制，所以一个IP包未必能完整的组成一个整包进行发送，就需要用到IPv4包分段。</p><p>包分段主要涉及到包头Identifier, flags, fragmentation offset三个域：</p><ul><li>identifier 用于标示所在的原始包，也就是说，拥有相同identifier的片段是属于相同的原始IP包的</li><li>flags 包括两个flag<ul><li>一个用于标示是否允许IP协议进行分段</li><li>另一个用于标示该分段是否是最后一段，0表示最后一段，1表示不是最后一段</li></ul></li><li>fragmentation offset用于表示该分段的数据在原数据中的偏移，以八字节为单位<ul><li>比如fragmentation offset是20，就说明这个片段里的第一个字节的数据已经是原数据里第161字节的数据了，前面有160个字节的数据在别的分段里</li></ul></li></ul><h3 id="4-3-3-IPv4地址"><a href="#4-3-3-IPv4地址" class="headerlink" title="4.3.3 IPv4地址"></a>4.3.3 IPv4地址</h3><p>IPv4地址为32位的二进制数。</p><p>一般情况下，IPv4被表示为a.b.c.d的形式，其中，a,b,c,d是IPv4地址中第1,2,3,4个字节的十进制表示。</p><p>由于因特网被分成了各个不同的子网，所以对于每一个IPv4地址，都可以将它分为两部分，第一部分是网络地址部分，代表了该IP地址所在的网络，第二部分是主机地址部分，代表了IP地址在网络中的标识符。</p><p>现在的网络-主机地址划分方法为CIDR(Classless Interdomain Routing)，也就是以32位地址的前x位作为网络地址，剩下的32-x位是主机地址，记作a.b.c.d/x。</p><p>特殊的IP地址：255.255.255.255，该地址为特定的广播地址，只要向该地址发送IP包，路由器会自动将包发送到当前子网下的所有主机上，甚至有可能发送到子网外的主机上。</p><h4 id="获取子网IP地址"><a href="#获取子网IP地址" class="headerlink" title="获取子网IP地址"></a>获取子网IP地址</h4><p>想要获取子网的IP地址，必须向上一级的IP地址管理者发出申请并由上一级进行分配。</p><h4 id="获取主机IP地址"><a href="#获取主机IP地址" class="headerlink" title="获取主机IP地址"></a>获取主机IP地址</h4><p>主机的IP地址可以手动分配，也可以使用DHCP(Dynamic Host Configuration Protocol)进行分配。</p><h5 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h5><p>想要DHCP正常工作，子网内必须有一个DHCP服务器，当一个新到来的主机想要获得IP地址时，过程如下：</p><ol><li>主机尝试发现DHCP服务器。<ol><li>由于新来的主机既不清楚自己的IP地址，也不清楚DHCP服务器的IP地址，所以主机以0.0.0.0的源IP地址向广播端口255.255.255.255发送一条探测消息，固定端口号为67</li><li>在这条消息里会包含一个事务ID</li></ol></li><li>DHCP服务器给出IP地址。<ol><li>同样，由于DHCP服务器暂时无法确定主机的IP地址，它需要向255.255.255.255发送消息。</li><li>这条消息里包含了提供的IP地址，该地址的有效时间，自身DHCP服务器的IP地址，主机传来的事务ID。</li></ol></li><li>DHCP Request。<ol><li>新来的主机可能会从多个DHCP服务器中获得提供的IP地址，它需要选择一个，然后发送DHCP Request Message，此时还不确定能不能真的拿到该IP，所以仍然需要0.0.0.0到255.255.255.255发送Request</li><li>这个Request消息里会包含被选中的IP地址，那么对应的服务器就知道新来的主机选择了自己提供的IP</li></ol></li><li>DHCP ACK。<ol><li>DHCP服务器接收到新来主机的Request Message之后，发出DHCP ACK，确认已经配置好了。此时仍然需要向255.255.255.255发送ACK。</li></ol></li></ol><h3 id="4-3-4-Network-Address-Translation-NAT"><a href="#4-3-4-Network-Address-Translation-NAT" class="headerlink" title="4.3.4 Network Address Translation(NAT)"></a>4.3.4 Network Address Translation(NAT)</h3><p>在IP地址中，有一类地址被保留下来作为私有地址，10.0.0.0/8就是其中一类。</p><p>所谓私有地址就是指该地址只在当前所在的子网中有意义，一旦考虑外部网络，该地址就没有意义。</p><p>那么当私有地址的主机尝试和外界通讯时，需要将私有地址转化为公开地址，这就是NAT的作用。</p><p>NAT通过如下几点来进行私有地址到公开地址的转化：</p><ol><li>NAT由一个路由器来进行操作</li><li>NAT路由器拥有一个公开的IP地址，假设为X</li><li>NAT路由器中维护了一张&lt;端口号, &lt;私有IP，端口号&gt;&gt;的表，也就是说子网中的&lt;私有IP地址, 端口号&gt;对应到了&lt;统一的公开IP地址, 端口号&gt;上</li><li>当子网内的主机尝试向外发送包，源地址就从&lt;私有IP地址, 端口号&gt;被NAT转化为&lt;统一的公开IP地址, 端口号&gt;，同样，当外部网络发送包到NAT时，NAT将目的地址转化为&lt;私有IP地址, 端口号&gt;而后发给对应主机。</li></ol><p>NAT的使用备受争议：</p><ol><li>NAT打破了因特网中的分层原则，同时使用传输层和网络层来修改地址和端口号。</li><li>NAT将许多主机隐藏在了一个路由器后面，将原本用于定位应用进程的端口号用于定位主机，那么有一些专用的端口号比如服务器的80端口就会受到影响(事实上很少将服务器放置在NAT后面)</li></ol><h3 id="4-3-5-IPv6"><a href="#4-3-5-IPv6" class="headerlink" title="4.3.5 IPv6"></a>4.3.5 IPv6</h3><p>由于32位IPv4地址会被用尽，所以新的IPv6进入了开发阶段，虽然距离IPv4地址真正用尽还有一定的时间，但是想要部署IPv6，也同样需要大量的时间。</p><p>相比于IPv4，IPv6有如下特性：</p><ol><li>扩展的地址空间。<ol><li>IPv6地址为128位地址</li><li>IPv6地址除了支持IPv4中的单播，广播，还支持组播(即向固定的一组IP地址进行发包)</li></ol></li><li>定长的40字节包头<ol><li>除去了IPv4包头里的可选项</li><li>定长包头更加易于处理，路由更快</li></ol></li><li>流标签<ol><li>类似于IPv4中的Type of Service，IPv6使用流来区别不同的包</li><li>流标签用来区别不同的流</li></ol></li></ol><h4 id="IPv6-包头格式"><a href="#IPv6-包头格式" class="headerlink" title="IPv6 包头格式"></a>IPv6 包头格式</h4><p>IPv6包头中包含了：</p><ul><li>版本(IPv4 or IPv6)</li><li>等级(Traffic Class)，用于给包赋予优先级，可以是根据流来赋予，也可以根据源应用来赋予</li><li>流标签(Flow Label)，用于标示一个流</li><li>负载长度(Payload Length)，由于包头定长，所以只记录了携带数据的长度</li><li>下一包头(Next Header)，也就是类似于IPv4中的协议，用于标示上一层使用的协议(TCP,UDP, etc.)，或者指向可选项</li><li>跳限制(Hop Limit)，类似于IPv4中的Time-to-live，减小到零，直接丢弃</li><li>源地址和目的地址</li></ul><p>可以从IPv6的包头中看到，有一部分功能被删除了：</p><ul><li>分片/重组<ul><li>IPv6的IP包如果由于过大不能在链路层上传输，路由器会返回一个<em>Packet too big</em>的ICMP消息，而不是像IPv4一样进行分片</li><li>如果要分片，就是在收到ICMP消息后在终端主机上进行分片</li><li>加快了路由的速度</li></ul></li><li>校验和<ul><li>由于传输层和链路层都有校验机制，所以在网络层就不再设置校验机制</li><li>加快了路由速度</li></ul></li><li>可选项<ul><li>使用Next Header进行指向而不是放在包头内</li><li>定长的包头，更易处理</li></ul></li></ul><h4 id="IPv4到IPv6"><a href="#IPv4到IPv6" class="headerlink" title="IPv4到IPv6"></a>IPv4到IPv6</h4><p>如果想要从IPv4转变到IPv6，我们新建的IPv6路由器可以兼容IPv4的IP包路由，但是以往的IPv4路由器想要兼容IPv6就会比较困难。</p><p>我们可以使用隧道(tunneling)的方式解决这个问题。</p><p>也就是说，将两个IPv6的路由/主机之间的IPv4路由视作链路层协议而不是同等的网络层协议，当需要发送IPv6包时，将其包裹在一个IPv4包中发出，到达终点后解开IPv4包，提取出IPv6包。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Computer Networking - A Top-Down Approach》第四章4.1-4.3复习知识点总结&lt;/p&gt;
    
    </summary>
    
      <category term="NJU-Class" scheme="https://rivers-shall.github.io/categories/NJU-Class/"/>
    
      <category term="计算机网络" scheme="https://rivers-shall.github.io/categories/NJU-Class/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络复习--第三章</title>
    <link href="https://rivers-shall.github.io/2019/12/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <id>https://rivers-shall.github.io/2019/12/28/计算机网络复习-第三章/</id>
    <published>2019-12-28T07:01:09.000Z</published>
    <updated>2020-05-28T06:56:19.811Z</updated>
    
    <content type="html"><![CDATA[<p>《Computer Networking - A Top-Down Approach》第三章(除3.4)复习知识点总结<br><a id="more"></a></p><h2 id="3-1-传输层服务介绍"><a href="#3-1-传输层服务介绍" class="headerlink" title="3.1 传输层服务介绍"></a>3.1 传输层服务介绍</h2><p>术语：</p><ul><li>传输层 Transport Layer</li><li>传输层包 segment</li></ul><p>传输层的意义：实现两个不同主机上的进程之间的逻辑通信(在这里，逻辑通信的意义是，即便两个主机之间需要多个路由器转发，从传输层的角度来看，就好像是点对点的直接传输一样)</p><h3 id="3-1-1-传输层与网络层的关系"><a href="#3-1-1-传输层与网络层的关系" class="headerlink" title="3.1.1 传输层与网络层的关系"></a>3.1.1 传输层与网络层的关系</h3><ul><li>传输层服务构建于网络层服务之上</li><li>网络层服务遍布全网，传输层服务只存在于终端主机</li><li>一个网络层上，可以有多个传输层服务</li><li>传输层服务部分受限于网络层服务<ul><li>例如，如果网络层不对带宽，传输时间做任何保证，传输层也无法提供保证</li><li>但是，虽然网络层(IP协议)不提供可靠传输，传输层(TCP协议)仍然可以提供可靠传输服务</li></ul></li></ul><h3 id="3-1-2-传输层协议概览"><a href="#3-1-2-传输层协议概览" class="headerlink" title="3.1.2 传输层协议概览"></a>3.1.2 传输层协议概览</h3><p>因特网提供了两种传输层协议</p><p>UDP (User Datagram Protocal)</p><ul><li>单纯的IP协议套壳</li><li>提供不同主机的进程到进程的通信服务</li><li>提供错误校验</li></ul><p>TCP(Transmission Control Protocal)</p><ul><li>复杂协议</li><li>提供不同主机的进程到进程的通信服务</li><li>提供错误校验</li><li>提供可靠传输服务</li><li>提供拥塞控制</li></ul><h2 id="3-2-多路复用和多路分解"><a href="#3-2-多路复用和多路分解" class="headerlink" title="3.2 多路复用和多路分解"></a>3.2 多路复用和多路分解</h2><p>多路复用：指的是源主机上的多个套接字发送的传输层包被整合到一起（不同的包还是不同的包，但是是由统一的传输层协议进行处理的），加传输层头部，而后交给网络层传输</p><p>多路分解：指的是目的主机上收到传输层包，将传输层的包发给对应的套接字</p><p>套接字的标识符：</p><p>套接字的标识符用于在多路分解中确定传输层包应该发送到哪一个套接字上</p><p>UDP套接字标识符：目的IP地址，目的端口号</p><p>TCP套接字标识符：源IP地址，源端口号，目的IP地址，目的端口号</p><p>也就是说，如果两个UDP包的源IP地址，源端口号不同，但是目的IP地址，目的端口号相同，它们就会被分配到同一个UDP套接字上，但是如果是TCP包，就会被分配到不同的套接字上。</p><p>这是因为UDP是无连接的，也就是说，在UDP的眼里，只有包包包，不在乎是谁发来的，但是TCP是面向连接的，和不同的源建立了不同的连接，所以这些包也就要放到不同的套接字上处理。</p><h2 id="3-3-无连接的传输层协议UDP"><a href="#3-3-无连接的传输层协议UDP" class="headerlink" title="3.3 无连接的传输层协议UDP"></a>3.3 无连接的传输层协议UDP</h2><p>UDP只完成了最基本的传输层协议工作，也就是多路复用和多路分解，错误校验。</p><p>仍然有应用使用UDP的原因：</p><ol><li>可以更好地控制包发出的时间，以及发包内容。由于没有拥塞控制，UDP接到应用层数据后立刻会发包，而无需通过重传进行可靠通信使得UDP不会传输除了应用数据以外的其他数据</li><li>没有连接建立的时延</li><li>无需维护连接状态，所以可以有更多的客户连接到同一个UDP服务器上</li><li>UDP包的额外域更少，开销低</li></ol><p>虽然很多时候说多媒体不在意少量的数据丢失，可以使用UDP，但是由于UDP缺少拥塞控制，多媒体文件体积庞大，所以使用UDP传输多媒体并不是一个好主意。</p><h3 id="3-3-1-UDP包格式"><a href="#3-3-1-UDP包格式" class="headerlink" title="3.3.1 UDP包格式"></a>3.3.1 UDP包格式</h3><p>包含了（顺序未必正确）：源端口，目的端口，包长度（包头+数据），校验和，应用数据</p><h3 id="3-3-2-UDP包校验和"><a href="#3-3-2-UDP包校验和" class="headerlink" title="3.3.2 UDP包校验和"></a>3.3.2 UDP包校验和</h3><p>将所有16-bit的小段当作数加起来，当有溢出进位时，就抛弃溢出进位，额外加1，所得结果取反。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0110011001100000</span></span><br><span class="line"></span><br><span class="line"><span class="number">0101010101010101</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000111100001100</span></span><br><span class="line"></span><br><span class="line"><span class="number">0110011001100000</span>+</span><br><span class="line"><span class="number">0101010101010101</span>=</span><br><span class="line"><span class="number">1011101110110101</span></span><br><span class="line"></span><br><span class="line"><span class="number">1011101110110101</span>+</span><br><span class="line"><span class="number">1000111100001100</span>=</span><br><span class="line"><span class="number">0100101011000010</span></span><br></pre></td></tr></table></figure><p>最后一次加法有溢出，额外加了1</p><h2 id="3-5-面向链接的传输：TCP"><a href="#3-5-面向链接的传输：TCP" class="headerlink" title="3.5 面向链接的传输：TCP"></a>3.5 面向链接的传输：TCP</h2><h3 id="3-5-1-TCP-连接"><a href="#3-5-1-TCP-连接" class="headerlink" title="3.5.1 TCP 连接"></a>3.5.1 TCP 连接</h3><p>TCP连接的特点：</p><ul><li>逻辑连接。TCP连接是一个逻辑概念，不是一个类似于电路交换网络中的连接一样，有预先分配的资源的真实存在的连接。</li><li>终端的连接。TCP连接只在终端主机上有概念，网络之中的路由器，交换机等对TCP连接毫无感知，只知道收发包。</li><li>点对点的连接。只有单播，没有组播。</li><li>双工连接。TCP连接的双方可以同时读写。</li></ul><p>TCP连接建立简介（主动发起连接的是客户进程，被动监听接受的是服务器进程）：</p><ol><li>客户进程向服务器发送一个特殊的TCP包</li><li>服务器进程向客户进程回复一个特殊的TCP包</li><li>客户进程向服务器进程再回复一个特殊的TCP包</li><li>1和2中的TCP包没有负载，3中的可能有</li></ol><p>TCP连接上传输数据的方式（两端都有发送缓冲区和接收缓冲区）：</p><ol><li>应用进程拥有想要发送的数据，将数据传给套接字</li><li>套接字将数据传给TCP传输层</li><li>TCP将数据存放在发送缓冲区中，在适当的时候发送（标准没有规定什么时候是适当的时候）</li><li>另一端TCP接收到数据，将数据存放在接收缓冲区中</li><li>TCP将接受缓冲剧的数据传给对应的套接字，套接字传给应用</li></ol><h3 id="3-5-2-TCP包结构"><a href="#3-5-2-TCP包结构" class="headerlink" title="3.5.2 TCP包结构"></a>3.5.2 TCP包结构</h3><p>TCP包包含了如下域：</p><ul><li>源端口号，目的端口号</li><li>32-bit序列号和32-bit确认号</li><li>16-bit接受窗口</li><li>4-bit头部长度</li><li>可选域</li><li>标志域</li><li>数据</li><li>校验和</li></ul><p>其中：</p><ul><li>32-bit序列号是当前TCP包中的数据的第一个<strong>字节</strong>的标号（注意不是包的标号，如果没有数据，序列号也需要再前一个包的最后一个字节标号基础上+1）</li><li>32-bit确认号是期盼得到的下一个字节的标号</li></ul><h3 id="3-5-3-往返时间估计和超时计算"><a href="#3-5-3-往返时间估计和超时计算" class="headerlink" title="3.5.3 往返时间估计和超时计算"></a>3.5.3 往返时间估计和超时计算</h3><p>想要估计往返时间，首先要估计一个发出的包的往返时间，但是，因为TCP会存在发出了多个包，但是都没有确认的情况，这时，TCP不会对所有没有确认的包都记录往返时间，只会选择一个包记录。</p><p>同时，如果一个包被重传了，TCP也不会记录它的往返时间（因为可能该包并没有丢失，只是ACK到的晚了，那么再收到的ACK就不清楚是原来的包的ACK，还是重传的包的ACK了）</p><p>通过一个包取样的往返时间$SampleRTT$和之前估计的$EstimatedRTT_{n-1}$得到新的$EstimatedRTT_{n}$的公式是</p><p>$EstimatedRTT_{n}=(1-\alpha)EstimatedRTT_{n-1} + \alpha SampleRTT$</p><p>官方建议$\alpha$取$1/8$</p><p>同时，我们可以用如下公式来反映网络连接的抖动程度：</p><p>$DevRTT=(1-\beta)DevRTT+\beta(|SampleRTT-EstimatedRTT|)$</p><p>官方建议$\beta$取$1/4$</p><p>一般来说超时区间$TimeoutInterval$取：</p><p>$TimeoutInterval=EstimatedRTT+4DevRTT$</p><p>同时，一旦出现了超时重传，那么$TimeoutInterval$会立刻乘2（这是因为阻塞控制，如果超时，很可能是因为线路阻塞，如果一直以同一个时间段重传，可能会使得阻塞更严重，乘2可以传的越来越慢）</p><p>一旦下一个ACK到来，就会立刻以原来的公式更新$TimeoutInterval$</p><h3 id="3-5-4-可靠传输"><a href="#3-5-4-可靠传输" class="headerlink" title="3.5.4 可靠传输"></a>3.5.4 可靠传输</h3><h4 id="关于计时器"><a href="#关于计时器" class="headerlink" title="关于计时器"></a>关于计时器</h4><p>概念上来讲，如果认为每个包都有一个计时器，更加容易思考，但是由于这样做的开销太大，实际的TCP协议只会维护一个超时重传计时器。</p><h4 id="两步保障可靠传输"><a href="#两步保障可靠传输" class="headerlink" title="两步保障可靠传输"></a>两步保障可靠传输</h4><p>可以从两步来描述TCP提供的可靠传输机制</p><ol><li>超时重传</li><li>重复确认的迅速重传</li></ol><h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>假设TCP的流控制和阻塞控制都不起作用，应用层数据大小不超过TCP负载的大小，数据传输是单向的情况下，给出一个简易的超时重传发送方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">下一序列号初始化</span><br><span class="line">发送基础序号初始化</span><br><span class="line"></span><br><span class="line">死循环 &#123;</span><br><span class="line">    事件：</span><br><span class="line">        应用层传来数据：</span><br><span class="line">            用下一序列号生成TCP包</span><br><span class="line">            如果计时器不在工作：</span><br><span class="line">                开启计时器</span><br><span class="line">            TCP包传给IP层</span><br><span class="line">            下一序列号增加TCP包长度</span><br><span class="line">        计时器超时：</span><br><span class="line">            重传未确认的最小序号包</span><br><span class="line">            重开计时器</span><br><span class="line">        收到确认包，确认号Y:</span><br><span class="line">            如果Y&gt;发送基础序号 &#123;</span><br><span class="line">                发送基础序号 = Y</span><br><span class="line">                如果仍有未确认的包 &#123;</span><br><span class="line">                    开启计时器</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：TCP协议使用<em>累积确认</em>的方法，也就是说，如果确认号是Y，就意味着所有序列号<strong>小于</strong>Y的包都收到了。</p><h6 id="超时乘2"><a href="#超时乘2" class="headerlink" title="超时乘2"></a>超时乘2</h6><p>一旦出现了超时重传，那么$TimeoutInterval$会立刻乘2（这是因为阻塞控制，如果超时，很可能是因为线路阻塞，如果一直以同一个时间段重传，可能会使得阻塞更严重，乘2可以传的越来越慢）</p><p>一旦下一个ACK到来，就会立刻以原来的公式更新$TimeoutInterval$</p><h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>接收者的ACK生成机制</p><table><thead><tr><th>事件</th><th>TCP接收者行为</th></tr></thead><tbody><tr><td>按序到达的包</td><td>等待500ms，希望出现下一个序列号的包</td></tr><tr><td>按序到达的包，已经有一个包等待发出ACK</td><td>立刻发出累计ACK包</td></tr><tr><td>非按序到达的包，序列号高于期待序列号，孔雀产生</td><td>发出重复ACK包</td></tr><tr><td>非按序到达的包，部分或全部填补空缺</td><td>发出最低连续已收到包的序列号的ACK包</td></tr></tbody></table><p>所以我们可以修正一下之前的简易发送方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">收到确认包，确认号Y:</span><br><span class="line">    如果Y&gt;发送基础序号 &#123;</span><br><span class="line">        发送基础序号 = Y</span><br><span class="line">        如果仍有未确认的包 &#123;</span><br><span class="line">            开启计时器</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; 否则 &#123;</span><br><span class="line">        增加Y的重复ACK包计数</span><br><span class="line">        如果计数到达<span class="number">3</span></span><br><span class="line">            立刻重传序列号为Y的包</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="Go-Back-N-or-Selective-Repeat"><a href="#Go-Back-N-or-Selective-Repeat" class="headerlink" title="Go-Back-N or Selective-Repeat"></a>Go-Back-N or Selective-Repeat</h5><p>都是，组合起来的，保有N个未确认的包像是GBN，但是接收方累计确认并缓存失序到达的大序列号的包，最终导致重传包的数量较少像是SR</p><h3 id="3-5-5-流控制"><a href="#3-5-5-流控制" class="headerlink" title="3.5.5 流控制"></a>3.5.5 流控制</h3><p>TCP的流控制是通过<em>滑动窗口</em>来实现的。</p><p>TCP接收方维护如下几个变量：</p><ul><li>接收缓冲区大小RcvBuffer</li><li>最后一个被应用程序读取的字节的序列号LastByteRead</li><li>最后一个接收到的字节的序列号LastByteRcvd</li></ul><p>而接收方希望 $LastByteRcvd-LastByteRead\le RcvBuffer$，所以窗口的大小就是 $rwnd=RcvBuffer - [LastBYteRcvd-LastByteRead]$。接收方通过在TCP包头的window域告知发送方rwnd的数值。</p><p>TCP发送方维护如下几个变量：</p><ul><li>最后一个发送的字节序列号LastByteSent</li><li>最后一个被确认的字节序列号LastByteAcked</li><li>接收方窗口大小rwnd</li></ul><p>发送方需要保证$LastByteSent−LastByteAcked\le rwnd$.</p><h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p>如果接收方窗口大小暂时变为0，那么发送方会收到rwnd为0的消息，而后就不再通信，两边就有可能永久阻塞。</p><p>所以TCP规定即便接受窗口为0，发送方也要向接收方发送负载为一个字节的包。以便后续接受窗口大小变更时可以及时收到消息。</p><h3 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h3><p>TCP建立连接：</p><ol><li>SYN(w) a $\rightarrow$ b</li><li>SYN(u),ACK(w+1) b $\rightarrow$ a</li><li>ACK(u+1)，这个ACK包已经可以带应用层数据了 a $\rightarrow$ b</li></ol><p>TCP关闭连接：</p><ol><li>FIN a $\rightarrow$ b</li><li>ACK b $\rightarrow$ a</li><li>FIN b $\rightarrow$ a</li><li>ACK a $\rightarrow$ b</li></ol><p>当客户机向一个IP地址正确但是端口号不正确的地址发送SYN时，服务器会回复RST包。</p><h2 id="3-6-拥塞控制原理"><a href="#3-6-拥塞控制原理" class="headerlink" title="3.6 拥塞控制原理"></a>3.6 拥塞控制原理</h2><h3 id="3-6-1-拥塞的原因和代价"><a href="#3-6-1-拥塞的原因和代价" class="headerlink" title="3.6.1 拥塞的原因和代价"></a>3.6.1 拥塞的原因和代价</h3><h4 id="情境一"><a href="#情境一" class="headerlink" title="情境一"></a>情境一</h4><p>情境：两个终端主机，一个发一个收，一个无限缓存的路由器</p><p>如果发送方发送的速度超过了链路上能够传输的最大速率，那么在路由器上就会出现大量的缓存，缓存中的包越来越多，其排队等待的时间就越长。</p><p>代价：当发送速率接近链路传输速率时，排队延迟迅速变大。</p><h4 id="情境二"><a href="#情境二" class="headerlink" title="情境二"></a>情境二</h4><p>情境：两个终端主机，一个有限缓存的路由器</p><p>如果发送方的发送速度过快，路由器的缓存就会被充满，那么路由器就必须丢包，一旦丢包，发送方就必须重传。同时，如果有包延时过长，使得发送方以为该包丢失了，重传的工作就是完全的浪费。</p><p>代价：</p><ol><li>当发送速率变高，发送方必须重传来弥补线路上丢包的事实</li><li>同时还会因为延时过长的“伪丢包”情境而做无谓的重传</li></ol><h4 id="情境三"><a href="#情境三" class="headerlink" title="情境三"></a>情境三</h4><p>情境：四个终端主机，有限缓存的路由器，多跳线路</p><p>如果发送过快导致网络中出现拥塞，那么在一个多跳线路上，一旦某个包在第N跳被丢弃，那么前N-1跳上的路由器，交换机等做的工作就相当于全部白费了。</p><p>代价：上游的路由器为了将包传输到当前位置提供的传输能力由于包被丢弃而全部浪费</p><h3 id="3-6-2-拥塞控制的解决方案"><a href="#3-6-2-拥塞控制的解决方案" class="headerlink" title="3.6.2 拥塞控制的解决方案"></a>3.6.2 拥塞控制的解决方案</h3><ol><li>端到端的拥塞控制。端到端的拥塞控制不依赖中间层的线路，通过在终端上自己检测推断线路网络的拥塞状况，进行对应的控制。</li><li>网络辅助的拥塞控制。网络辅助的拥塞控制中，底层的网络线路会显式地通知终端线路网络的拥塞状况。</li></ol><h2 id="3-7-TCP-拥塞控制"><a href="#3-7-TCP-拥塞控制" class="headerlink" title="3.7 TCP 拥塞控制"></a>3.7 TCP 拥塞控制</h2><p>类似于流控制中的receive window，为了拥塞控制中控制发送方的发送速率，TCP维护一个congestion window(cwnd)。所以我们现在有如下的关系。</p><p>$LastByteSent−LastByteAcked\le \min{cwnd, rwnd}$</p><p>但是就讨论中，方便起见，我们先不考虑rwnd。</p><p>那么TCP现在需要回答如下几个问题：</p><ol><li>如何检测出拥塞或者不拥塞的情况？</li><li>在检测出情况后，如何调整congestion window的大小来控制传输速度？</li></ol><h3 id="TCP检测拥塞状况的方式"><a href="#TCP检测拥塞状况的方式" class="headerlink" title="TCP检测拥塞状况的方式"></a>TCP检测拥塞状况的方式</h3><p>由于线路拥塞的最重要结果就是丢包，而丢包又和可靠传输有着紧密的联系，所以TCP使用了实现可靠传输中的机制来检测拥塞状况。</p><table><thead><tr><th style="text-align:center">行为</th><th style="text-align:center">推断</th></tr></thead><tbody><tr><td style="text-align:center">超时</td><td style="text-align:center">拥塞严重</td></tr><tr><td style="text-align:center">重复ACK</td><td style="text-align:center">拥塞，不是很严重</td></tr><tr><td style="text-align:center">正常ACK</td><td style="text-align:center">无拥塞</td></tr></tbody></table><h3 id="TCP在检测到拥塞-正常后的行为"><a href="#TCP在检测到拥塞-正常后的行为" class="headerlink" title="TCP在检测到拥塞/正常后的行为"></a>TCP在检测到拥塞/正常后的行为</h3><p>TCP在检测到拥塞或者不拥塞后的行为遵守如下的指导原则：</p><ol><li>一旦检测到拥塞(丢包)，就有必要减少传输速率</li><li>一旦检测到无拥塞，就可以增加传输速率</li><li>带宽侦测，TCP需要找一种高效而比较安全的方法来侦测当前线路可以接受的传输速率是多少，既要快，否则线路利用率不高，也要适当慢一点，否则一下子就导致了拥塞</li></ol><p>针对这些，TCP有如下的模式：</p><ul><li>Slow Start</li><li>Congestion Avoidance</li><li>Fast Recovery</li></ul><p>他们之间的转换关系如下：</p><p><img src="Congestion-mode-switch.png" alt="mode-switch"></p><p>下面介绍一下这几个模式的设立目的和比较重要的转换条件</p><h4 id="Slow-Start-慢开始"><a href="#Slow-Start-慢开始" class="headerlink" title="Slow Start(慢开始)"></a>Slow Start(慢开始)</h4><p>在TCP连接建立的时候，cwnd被初始化为1MSS，随后一旦接受到一个ACK，就将cwnd增加1MSS，这就导致一个RTT内，cwnd会翻一倍。</p><p>这样的一个指数级增长的cwnd被用在建立TCP连接之后，迅速检测到当前线路能够接受的传输速率。</p><h4 id="Congestion-Avoidance-拥塞避免"><a href="#Congestion-Avoidance-拥塞避免" class="headerlink" title="Congestion Avoidance (拥塞避免)"></a>Congestion Avoidance (拥塞避免)</h4><p>进入Congestion Avoidance的时候，一般cwnd的大小是上一次检测到拥塞时的cwnd的一半。</p><p>这时在一个RTT内，如果收到了全部发出包的ACK，那么一个RTT，cwnd增加1MSS。</p><p>这种方式用在这个时候很合适，虽然线路仍然正常无拥塞，但是任何的cwnd的增长都有可能使得线路变为拥塞状态，所以采用一种较为缓慢谨慎的方式来侦测线路的带宽。</p><h4 id="Fast-Recovery-快速恢复"><a href="#Fast-Recovery-快速恢复" class="headerlink" title="Fast Recovery (快速恢复)"></a>Fast Recovery (快速恢复)</h4><p>Fast Recovery是在检测到3个重复的ACK包时进入的模式，该模式下，每收到一个重复的ACK包，cwnd的大小就增加1MSS，这点和Slow Start没有区别，因为收到重复的ACK包也表示有正常的包被正常接受到了。一旦接收到新的ACK包，就转换到Congestion Avoidance模式。</p><h3 id="两种不同的TCP"><a href="#两种不同的TCP" class="headerlink" title="两种不同的TCP"></a>两种不同的TCP</h3><p>早期的TCP，TCP Tahoe，没有Fast Recovery模式，无论受到什么样的拥塞信息，超时或者重复ACK，都直接将cwnd置为1且进入Slow Start模式。</p><p>后来TCP Reno加入了Fast Recovery的支持。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Computer Networking - A Top-Down Approach》第三章(除3.4)复习知识点总结&lt;br&gt;
    
    </summary>
    
      <category term="NJU-Class" scheme="https://rivers-shall.github.io/categories/NJU-Class/"/>
    
      <category term="计算机网络" scheme="https://rivers-shall.github.io/categories/NJU-Class/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年总结</title>
    <link href="https://rivers-shall.github.io/2019/12/19/2019%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://rivers-shall.github.io/2019/12/19/2019年总结/</id>
    <published>2019-12-18T16:59:54.000Z</published>
    <updated>2020-05-28T06:56:19.810Z</updated>
    
    <content type="html"><![CDATA[<p>很快就要元旦了，提前总结2019年</p><a id="more"></a><h2 id="2019重要事件简单复盘"><a href="#2019重要事件简单复盘" class="headerlink" title="2019重要事件简单复盘"></a>2019重要事件简单复盘</h2><p>2019.1 - 2019.2 寒假，开学前交换</p><p>2019.3 - 2019.6 二年级下，在校就读</p><ul><li>2019.4 N大程序设计校赛普及组冠军</li><li>2019.5 江苏省大学生程序设计大赛一等奖，感谢队友xnr和yzy实力carry</li></ul><p>2019.7 - 2019.8</p><ul><li>担任《汇编语言》课程助教</li><li>Alibaba Summer of Code 参与 Spring-Cloud-Alibaba 开源项目</li><li>2019.8.2X - 2019.8.31 字节跳动夏令营Byte Camp工程赛道一等奖，感谢四位队友和辛勤导师fcj</li></ul><p>2019.9 - 2019.12 三年级上，在校就读，同时忙于实习投简历，面试</p><h2 id="2019年思考与评价"><a href="#2019年思考与评价" class="headerlink" title="2019年思考与评价"></a>2019年思考与评价</h2><h3 id="2019年是幸运的一年"><a href="#2019年是幸运的一年" class="headerlink" title="2019年是幸运的一年"></a>2019年是幸运的一年</h3><p>两次程序设计大赛的获奖，Alibaba Summer of Code的参与，Byte Camp的参与和获奖使得我的简历不再过于单薄</p><p>Alibaba Summer of Code 成功走出了向开源社区的第一步(或许念念不忘，真的会有回响)，也是第一次接触工业级的代码，对Spring，开源文化理解更加深刻</p><p>Byte Camp 第一次真正意义上的多人合作开发，尝试着理解程序猿之间相爱相杀的故事</p><h3 id="2019是技术上的低产年，习性上的高产年"><a href="#2019是技术上的低产年，习性上的高产年" class="headerlink" title="2019是技术上的低产年，习性上的高产年"></a>2019是技术上的低产年，习性上的高产年</h3><p>大一时其实并未成功正视，只是选择性忽视，习性妥协极少，刚则易折，反馈到大二时面对突如其来的变化，将妥协作为主要手段，于是妥协井喷式增加，也可以认为是技术低产的主要诱因</p><p>好在经过一整年的打磨，渐渐的接受了心中的设定，同时正视设定和现实，妥协次数渐渐减少，习性上有明显的产出</p><h3 id="技术博客的写作比想象中的困难"><a href="#技术博客的写作比想象中的困难" class="headerlink" title="技术博客的写作比想象中的困难"></a>技术博客的写作比想象中的困难</h3><p>断断续续写过数篇博客，但是多个系列都处在僵尸状态，独立的博文数量也较少，总结思考了一下，写技术博客其实比我预想的困难，主要是因为：</p><ul><li>一个完整系列的博文，对于写作者对系列内容的掌握程度要求是较高的，否则很难理清一个脉络出来</li><li>我的开始，往往采取边学边写的状态<ul><li>本身心中的“完美的博文”设定很容易导致对之前的博文不满意</li><li>写到后几份容易出现突发情况，比如原先认定的系列目标突然消失</li></ul></li></ul><p>对此，我觉得应该现对系列内容进行学习，学习到一定阶段，或者学习彻底完成后，以博文写作的方式来进行复习和整理</p><p>同时对于博文，没有必要想太多，简单地作为一个学习笔记，分享知识就好，总想着完美地表达概念或者内涵是不现实的</p><h3 id="与2018的比较"><a href="#与2018的比较" class="headerlink" title="与2018的比较"></a>与2018的比较</h3><p><a href="/2019/02/05/戊戌年总结/" title="戊戌年总结">戊戌年总结</a>为农历年份的总结，从2019年开始，使用公历年份进行总结</p><p>相比于2018，总结中记录的琐事渐渐减少，心中的“设定”作用渐渐体现，将关注逐渐转移到所认为的重点上来了</p><p>2018年对在校生活的关注较多，2019年对个人活动的关注较多，或许到了该往外走走闯闯的时候了</p><h2 id="即将开启的故事"><a href="#即将开启的故事" class="headerlink" title="即将开启的故事"></a>即将开启的故事</h2><p>本想将2020的目标一并发上来，似乎并不合适，不如等待2020的年终总结更好，哈哈</p><p>对2020，还是要说一句 - A wind of change is blowing!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很快就要元旦了，提前总结2019年&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="https://rivers-shall.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="年终总结" scheme="https://rivers-shall.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>PL-Part-A-Section-1-Extra-Practice</title>
    <link href="https://rivers-shall.github.io/2019/10/15/PL-Part-A-Section-1-Extra-Practice/"/>
    <id>https://rivers-shall.github.io/2019/10/15/PL-Part-A-Section-1-Extra-Practice/</id>
    <published>2019-10-15T03:40:51.000Z</published>
    <updated>2020-05-28T06:56:19.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数式编程实现各类排序算法"><a href="#函数式编程实现各类排序算法" class="headerlink" title="函数式编程实现各类排序算法"></a>函数式编程实现各类排序算法</h2><p><a href="https://github.com/Rivers-Shall/PL-Extra-Practice" target="_blank" rel="noopener">Github仓库链接(长期更新)</a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在Coursera网站上的Programming Languages, Part A课程的第一节的额外练习中，有引导同学实现快速排序和归并排序的过程(事实上在正式作业的challenge部分也用到了排序进行去重，当然可以使用简单的$O(n^2)$算法进行去重，不过排序后去重能提升到$O(n\log n)$而已)，就我个人来看，这也是很有意思的一件事，所以写了博文记录下来。</p><h3 id="使用到的函数式编程介绍"><a href="#使用到的函数式编程介绍" class="headerlink" title="使用到的函数式编程介绍"></a>使用到的函数式编程介绍</h3><p>这次使用的语言是Programming Languages, Part A课程的Standard ML语言。</p><p>其实在传统的命令式编程中，我们应该已经比较熟悉各类排序算法的实现了，那么函数式编程有什么区别呢？</p><p>在这篇博文中中，我们暂时不使用函数式编程中比较高人气的<code>map</code>, <code>reduce</code>, <code>filter</code>等(第一节的课程也没有涉及，当然，日后可能回来更新也说不定)</p><p>我们主要使用的函数式编程功能如下：</p><ul><li>不可更改的列表(存储同一类型的数据)</li><li>对列表的操作 <code>hd</code>, <code>tl</code>(<code>hd</code>返回列表第一个元素，<code>tl</code>返回删除了列表第一个元素的新列表)</li><li>元组，可以使用 <code>#&lt;number&gt;</code>的方式进行索引的不可变数据(可存储不同类型的数据)</li><li>递归</li><li>少量pattern-matching(在<code>val binding</code>里)，类似于python中的<code>x, y = y, x</code></li></ul><a id="more"></a><h3 id="几类排序算法"><a href="#几类排序算法" class="headerlink" title="几类排序算法"></a>几类排序算法</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>说到排序算法，估计没有人不知道声名在外的快速排序，快速排序可以分为两个阶段:</p><ol><li>选定主元并根据主元进行分割</li><li>对分割后的子列表进行递归排序</li></ol><p>我们先不考虑随机选择主元的问题，直接将列表第一个元素作为主元，如此，我们得到以下代码</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> sort(numbers : <span class="built_in">int</span> <span class="built_in">list</span>) =</span><br><span class="line">    <span class="keyword">if</span> null numbers</span><br><span class="line">    <span class="keyword">then</span> <span class="literal">[]</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">let</span></span><br><span class="line">            <span class="keyword">fun</span> partition(numbers : <span class="built_in">int</span> <span class="built_in">list</span>, pivot : <span class="built_in">int</span>) =</span><br><span class="line">                <span class="keyword">if</span> null numbers</span><br><span class="line">                <span class="keyword">then</span> (<span class="literal">[]</span>, <span class="literal">[]</span>)</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">let</span></span><br><span class="line">                        <span class="keyword">val</span> current_number = hd numbers</span><br><span class="line">                        <span class="keyword">val</span> rest_of_numbers = tl numbers</span><br><span class="line">                        <span class="keyword">val</span> (less_than_or_equal_to_pivot, larger_than_pivot) = partition(rest_of_numbers, pivot)</span><br><span class="line">                    <span class="keyword">in</span></span><br><span class="line">                        <span class="keyword">if</span> current_number &gt; pivot</span><br><span class="line">                        <span class="keyword">then</span> (less_than_or_equal_to_pivot, current_number :: larger_than_pivot)</span><br><span class="line">                        <span class="keyword">else</span> (current_number :: less_than_or_equal_to_pivot, larger_than_pivot)</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">val</span> pivot = hd numbers</span><br><span class="line">            <span class="keyword">val</span> to_partition = tl numbers</span><br><span class="line">            <span class="keyword">val</span> (less_than_or_equal_to_pivot, larger_than_pivot) = partition(to_partition, pivot)</span><br><span class="line">        <span class="keyword">in</span></span><br><span class="line">            sort(less_than_or_equal_to_pivot) @ (pivot :: sort(larger_than_pivot))</span><br><span class="line">        <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其中函数<code>partition</code>是用来分割列表的，我们在调用的时候直接使用<code>hd numbers</code>，也就是列表的第一个元素作为主元。</p><h5 id="和命令式编程快排的区别"><a href="#和命令式编程快排的区别" class="headerlink" title="和命令式编程快排的区别"></a>和命令式编程快排的区别</h5><p>可以看到基本的逻辑非常清晰，只不过我们多了一个使用<code>@</code>操作符进行拼接的过程(由于函数式编程中的列表不能直接修改，我们必须重新构造两个子列表，排序后拼接)。</p><p>但是这仍然对我们的快排造成了影响:</p><ol><li>快排不再是in-place的了，也就是说排序过程中需要额外的存储空间</li><li>快排的渐进时间复杂度虽然没有受到影响($O(n\log n)$)，但是有常数级的减慢</li></ol><p>对于时间复杂度，我们可以对拼接操作做这样的分析，一般拼接我们可以认为是这样实现的</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> concat(alist : <span class="built_in">int</span> <span class="built_in">list</span>, blist : <span class="built_in">int</span> <span class="built_in">list</span>) =</span><br><span class="line">    <span class="keyword">if</span> null alist</span><br><span class="line">    <span class="keyword">then</span> blist</span><br><span class="line">    <span class="keyword">else</span> (hd alist) :: concat(tl alist, blist)</span><br></pre></td></tr></table></figure><p>所以其时间复杂度为$O(L_a)$，也就是第一个列表的长度。</p><p>在我们的快速排序中也就是$O(n)$，其中$n$为<code>numbers</code>的长度，故快排的渐进时间复杂度虽然没有受到影响($O(n\log n)$)，但是有常数级的减慢。</p><h5 id="随机选择主元的实现"><a href="#随机选择主元的实现" class="headerlink" title="随机选择主元的实现"></a>随机选择主元的实现</h5><p>我们知道，我们一直说的快排$O(n\log n)$时间复杂度其实是平均时间复杂度，想要达到这个目标，随机化必不可少，但我们上面实现的快排直接将第一个元素作为主元进行分割是不合适的，最简单的，面对一个已经排好序的列表，我们的快排将会达到$O(n^2)$的时间复杂度！</p><p>所以，我们有必要考虑一下随机选择主元应该怎么实现，一种比较直接的想法是，先随机产生一个下标，然后找到下标中的元素，并将其从原列表中剔除，然后将剩下的列表进行分割。</p><p>这样的话，我们需要三个函数，(寻找，剔除，分割(<code>partition</code>已实现))，这样当然是很好的，多个函数的合作也符合函数式编程的原则，但是事实上我们可以在一个函数中实现这个功能，这样可以减少遍历数组的次数，减少时间消耗。</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> extract_and_partition(nth : <span class="built_in">int</span>, numbers : <span class="built_in">int</span> <span class="built_in">list</span>) =</span><br><span class="line">    <span class="keyword">let</span></span><br><span class="line">        <span class="keyword">val</span> current_number = hd numbers</span><br><span class="line">        <span class="keyword">val</span> rest_numbers = tl numbers</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> nth = <span class="number">1</span></span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">let</span></span><br><span class="line">                <span class="keyword">val</span> (less_than_or_equal_to_pivot, larger_than_pivot) = partition(rest_numbers, current_number)</span><br><span class="line">            <span class="keyword">in</span></span><br><span class="line">                (current_number, less_than_or_equal_to_pivot, larger_than_pivot)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">let</span></span><br><span class="line">                <span class="keyword">val</span> (pivot, less_than_or_equal_to_pivot, larger_than_pivot) = extract_and_partition(nth - <span class="number">1</span>, rest_numbers)</span><br><span class="line">            <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> current_number &lt;= pivot</span><br><span class="line">                <span class="keyword">then</span> (pivot, (current_number :: less_than_or_equal_to_pivot), larger_than_pivot)</span><br><span class="line">                <span class="keyword">else</span> (pivot, less_than_or_equal_to_pivot, (current_number :: larger_than_pivot))</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>函数<code>extract_and_partition(nth, numbers)</code>将numbers中的第<code>nth</code>个元素提取出来作为主元并对剩下的所有元素进行分割，带着这个函数意义去阅读代码，逻辑其实比较明确，当然，该函数要求传入的<code>nth</code>必须是$[1, length]$中的索引。</p><p>所以我们的快排可以改为</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rand_seed = <span class="type">Random</span>.rand(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">fun</span> qsort(numbers : <span class="built_in">int</span> <span class="built_in">list</span>) =</span><br><span class="line">    <span class="keyword">if</span> null numbers</span><br><span class="line">    <span class="keyword">then</span> <span class="literal">[]</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">let</span></span><br><span class="line">            <span class="keyword">val</span> rand_index = <span class="type">Random</span>.randInt(rand_seed) mod (<span class="type">List</span>.length numbers) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> (pivot, less_than_or_equal_to_pivot , greater_than_pivot) = extract_and_partition(rand_index, numbers)</span><br><span class="line">        <span class="keyword">in</span></span><br><span class="line">            qsort(less_than_or_equal_to_pivot) @ (pivot :: qsort(greater_than_pivot))</span><br><span class="line">        <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这样，就实现了随机选取主元的快排了。但是我们在选取随机索引时使用了<code>List.length</code>函数，如果该函数需要遍历整个列表的话，我们的速度又在常数级上减缓了。</p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序与快排类似，也拥有递归的算法形式，主要是先排序子列表，然后合并，但是我们在函数式编程中不能直接在列表上操作，所以我们需要额外的子程序来将原列表分成两半。</p><p>一开始，我觉得需要先算出列表的长度，然后除以二后通过选取前<code>n</code>个的元素的方式将原列表分为前后两半，但是后来在完成练习的过程中，我发现了更好的办法。</p><p>受限于传统的命令式编程中的思维定势，想要将原列表分成<strong>前后两半</strong>是很正常的，但是这需要额外的数组遍历，消耗时间，我们事实上只需要将列表分成两部分就可以了，于是可以使用接下来的这个函数</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(*</span></span><br><span class="line"><span class="comment">20. Write a function divide : int list -&gt; int list * int list that takes a list of integers and produces two </span></span><br><span class="line"><span class="comment">lists by alternating elements between the two lists. For example: divide ([1,2,3,4,5,6,7]) = ([1,3,5,7], [2,4,6])</span></span><br><span class="line"><span class="comment">*)</span></span><br><span class="line"><span class="keyword">fun</span> divide(numbers : <span class="built_in">int</span> <span class="built_in">list</span>) =</span><br><span class="line">    <span class="keyword">let</span></span><br><span class="line">        <span class="keyword">fun</span> divide_first_put_to(numbers : <span class="built_in">int</span> <span class="built_in">list</span>, put_to_first : <span class="built_in">bool</span>) =</span><br><span class="line">            <span class="keyword">if</span> null numbers</span><br><span class="line">            <span class="keyword">then</span> (<span class="literal">[]</span>, <span class="literal">[]</span>)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">let</span></span><br><span class="line">                    <span class="keyword">val</span> rest_divided_pairs = divide_first_put_to(tl numbers, not put_to_first)</span><br><span class="line">                <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">if</span> put_to_first</span><br><span class="line">                    <span class="keyword">then</span> ((hd numbers) :: (#<span class="number">1</span> rest_divided_pairs), #<span class="number">2</span> rest_divided_pairs)</span><br><span class="line">                    <span class="keyword">else</span> (#<span class="number">1</span> rest_divided_pairs, (hd numbers) :: (#<span class="number">2</span> rest_divided_pairs))</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">        divide_first_put_to(numbers, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>而归并的子程序其实和命令式编程中差不多</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(*</span></span><br><span class="line"><span class="comment">18. Write a function sortedMerge : int list * int list -&gt; int list that takes two lists of integers that </span></span><br><span class="line"><span class="comment">are each sorted from smallest to largest, and merges them into one sorted list. For example: </span></span><br><span class="line"><span class="comment">sortedMerge ([1,4,7], [5,8,9]) = [1,4,5,7,8,9]</span></span><br><span class="line"><span class="comment">*)</span></span><br><span class="line"><span class="keyword">fun</span> sortedMerge(first_numbers : <span class="built_in">int</span> <span class="built_in">list</span>, second_numbers : <span class="built_in">int</span> <span class="built_in">list</span>) =</span><br><span class="line">    <span class="keyword">if</span> null first_numbers <span class="keyword">andalso</span> null second_numbers</span><br><span class="line">    <span class="keyword">then</span> <span class="literal">[]</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> null first_numbers</span><br><span class="line">        <span class="keyword">then</span> (hd second_numbers) :: sortedMerge(first_numbers, tl second_numbers)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> null second_numbers</span><br><span class="line">            <span class="keyword">then</span> (hd first_numbers) :: sortedMerge(tl first_numbers, second_numbers)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> (hd first_numbers) &gt; (hd second_numbers)</span><br><span class="line">                <span class="keyword">then</span> (hd second_numbers) :: sortedMerge(first_numbers, tl second_numbers)</span><br><span class="line">                <span class="keyword">else</span> (hd first_numbers) :: sortedMerge(tl first_numbers, second_numbers)</span><br></pre></td></tr></table></figure><p>所以我们的归并排序可以写作</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> merge_sort(numbers : <span class="built_in">int</span> <span class="built_in">list</span>) =</span><br><span class="line">    <span class="keyword">if</span> null numbers <span class="keyword">orelse</span> null (tl numbers)</span><br><span class="line">    <span class="keyword">then</span> numbers</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">let</span></span><br><span class="line">            <span class="keyword">val</span> divided_pairs = divide numbers</span><br><span class="line">        <span class="keyword">in</span></span><br><span class="line">            sortedMerge(merge_sort(#<span class="number">1</span> divided_pairs), merge_sort(#<span class="number">2</span> divided_pairs))</span><br><span class="line">        <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇博文就到这里，可以看出，由于这些经典的排序算法都具有明显的递归特征，所以函数式编程实现和命令式实现思路非常相似，但是由于函数式编程也有自己的特点，比如不可变数据，列表操作(<code>hd</code>, <code>tl</code>)等等，我们的实现细节事实上和命令式编程还是有很大的区别。</p><p>这次的代码对于递归式的，函数式的思考是一次不错的锻炼，非常有价值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数式编程实现各类排序算法&quot;&gt;&lt;a href=&quot;#函数式编程实现各类排序算法&quot; class=&quot;headerlink&quot; title=&quot;函数式编程实现各类排序算法&quot;&gt;&lt;/a&gt;函数式编程实现各类排序算法&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Rivers-Shall/PL-Extra-Practice&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github仓库链接(长期更新)&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;在Coursera网站上的Programming Languages, Part A课程的第一节的额外练习中，有引导同学实现快速排序和归并排序的过程(事实上在正式作业的challenge部分也用到了排序进行去重，当然可以使用简单的$O(n^2)$算法进行去重，不过排序后去重能提升到$O(n\log n)$而已)，就我个人来看，这也是很有意思的一件事，所以写了博文记录下来。&lt;/p&gt;
&lt;h3 id=&quot;使用到的函数式编程介绍&quot;&gt;&lt;a href=&quot;#使用到的函数式编程介绍&quot; class=&quot;headerlink&quot; title=&quot;使用到的函数式编程介绍&quot;&gt;&lt;/a&gt;使用到的函数式编程介绍&lt;/h3&gt;&lt;p&gt;这次使用的语言是Programming Languages, Part A课程的Standard ML语言。&lt;/p&gt;
&lt;p&gt;其实在传统的命令式编程中，我们应该已经比较熟悉各类排序算法的实现了，那么函数式编程有什么区别呢？&lt;/p&gt;
&lt;p&gt;在这篇博文中中，我们暂时不使用函数式编程中比较高人气的&lt;code&gt;map&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;等(第一节的课程也没有涉及，当然，日后可能回来更新也说不定)&lt;/p&gt;
&lt;p&gt;我们主要使用的函数式编程功能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可更改的列表(存储同一类型的数据)&lt;/li&gt;
&lt;li&gt;对列表的操作 &lt;code&gt;hd&lt;/code&gt;, &lt;code&gt;tl&lt;/code&gt;(&lt;code&gt;hd&lt;/code&gt;返回列表第一个元素，&lt;code&gt;tl&lt;/code&gt;返回删除了列表第一个元素的新列表)&lt;/li&gt;
&lt;li&gt;元组，可以使用 &lt;code&gt;#&amp;lt;number&amp;gt;&lt;/code&gt;的方式进行索引的不可变数据(可存储不同类型的数据)&lt;/li&gt;
&lt;li&gt;递归&lt;/li&gt;
&lt;li&gt;少量pattern-matching(在&lt;code&gt;val binding&lt;/code&gt;里)，类似于python中的&lt;code&gt;x, y = y, x&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Open Course" scheme="https://rivers-shall.github.io/categories/Open-Course/"/>
    
      <category term="Programming Language By Dan Grossman" scheme="https://rivers-shall.github.io/categories/Open-Course/Programming-Language-By-Dan-Grossman/"/>
    
    
      <category term="Programming Language" scheme="https://rivers-shall.github.io/tags/Programming-Language/"/>
    
  </entry>
  
  <entry>
    <title>Java开发编译器(1)-LexerDemo</title>
    <link href="https://rivers-shall.github.io/2019/10/07/Java%E5%BC%80%E5%8F%91%E7%BC%96%E8%AF%91%E5%99%A8-1-LexerDemo/"/>
    <id>https://rivers-shall.github.io/2019/10/07/Java开发编译器-1-LexerDemo/</id>
    <published>2019-10-07T12:27:12.000Z</published>
    <updated>2020-05-28T06:56:19.810Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Rivers-Shall/Compiler-Principle-Code/tree/master/LexerDemo" target="_blank" rel="noopener">Github链接</a></p><h3 id="编写目的"><a href="#编写目的" class="headerlink" title="编写目的"></a>编写目的</h3><p>在观看了几份视频后决定先开发一个<code>LexerDemo</code>类，用于展示词法分析的含义，也即<code>LexerDemo</code>类仅展示词法分析的输入和词法分析的输出，不展示其余任何东西，开放的接口仅有无参构造函数和用于返回词法分析结果的<code>lex</code>方法。<code>LexerDemo</code>用于对仅含非负整数，加减乘除的运算表达式做词法分析。</p><a id="more"></a><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><h4 id="确定需求"><a href="#确定需求" class="headerlink" title="确定需求"></a>确定需求</h4><p>第一天做主要是写文档，确定需求，本来打算按照视频中的完成一个可以基本和语法分析器一起工作的<code>Lexer</code>类，但是后来还是算了，原因是词法分析和语法分析的合作方式有两种</p><ol><li>词法分析和语法分析交替工作，也即语法分析需要Token时，向词法分析索要，词法分析再向前运作</li><li>词法分析首先完成工作，然后将所有的Token存放起来，以便语法分析使用</li></ol><p>两种方式各有优劣：</p><ol><li>第一种方式不需要在内存中存放一个Token List，节约空间，但是只能有常数级(通常是一个)的lookahead</li><li>第二种方式便于语法分析，可以在已完成的Token List上跑多遍的语法分析，获得更好的结果</li></ol><p>视频中的合作方式是第一种，我打算到时候再看能实现哪一种或者两种</p><h4 id="JavaDoc编写中的问题"><a href="#JavaDoc编写中的问题" class="headerlink" title="JavaDoc编写中的问题"></a>JavaDoc编写中的问题</h4><hr><p>Q: javadoc中如何加入 inline code？<br>A: &lt;code>.  最早发现这个问题是因为插入代码时都是用的&lt;pre>，但是这是用来插入代码块的，搜索之后发现应该使用&lt;code></p><hr><p>Q: javadoc中如何加入字符 &lt;, &gt;?<br>A: &amp; lt; &amp; gt; (分号不能忘记)由于javadoc实际上是html，所以这两个字符有特殊含义，需要这样转义。</p><hr><h4 id="如何引入JUnit"><a href="#如何引入JUnit" class="headerlink" title="如何引入JUnit"></a>如何引入JUnit</h4><p>在eclipse中，可以使用 Project &gt; Properties &gt; Java Build Path &gt; Libraries &gt; add library…</p><p>在IntelliJ IDEA中，可以直接 <code>@Test</code> 然后在报错后将鼠标移动到上面，会有引入Junit的选项出现</p><h3 id="编后感"><a href="#编后感" class="headerlink" title="编后感"></a>编后感</h3><p>其实也没啥，由于只是一个Demo，用来展示词法分析的大概含义的，没有考虑到和语法分析器合作的问题，<br>而且选定的对象也是包含加减乘除的四则算术表达式，本身词法规则就很简单，结果写下来只是个70来行的小程序(晕～)。</p><p>但是硬生生配了100+行的测试，测试实在是太方便了，只需要Run一下就可以一键测试，基本的测试策略是将输入分为几个维度:</p><ol><li>包含 +，-，*，/，数字，非法字符</li><li>单行或多行</li><li>单次输入分析和多次输入分析</li></ol><p>最终每个纬度的每个方面都至少有一个测试样例覆盖到了，代码覆盖率(分支覆盖率)也达到了百分之百。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Rivers-Shall/Compiler-Principle-Code/tree/master/LexerDemo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;编写目的&quot;&gt;&lt;a href=&quot;#编写目的&quot; class=&quot;headerlink&quot; title=&quot;编写目的&quot;&gt;&lt;/a&gt;编写目的&lt;/h3&gt;&lt;p&gt;在观看了几份视频后决定先开发一个&lt;code&gt;LexerDemo&lt;/code&gt;类，用于展示词法分析的含义，也即&lt;code&gt;LexerDemo&lt;/code&gt;类仅展示词法分析的输入和词法分析的输出，不展示其余任何东西，开放的接口仅有无参构造函数和用于返回词法分析结果的&lt;code&gt;lex&lt;/code&gt;方法。&lt;code&gt;LexerDemo&lt;/code&gt;用于对仅含非负整数，加减乘除的运算表达式做词法分析。&lt;/p&gt;
    
    </summary>
    
      <category term="Open Course" scheme="https://rivers-shall.github.io/categories/Open-Course/"/>
    
      <category term="163-自己动手用Java写编译器" scheme="https://rivers-shall.github.io/categories/Open-Course/163-%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E7%94%A8Java%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    
    
      <category term="Java" scheme="https://rivers-shall.github.io/tags/Java/"/>
    
      <category term="Compiler" scheme="https://rivers-shall.github.io/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 0034 一般二分搜索的重点</title>
    <link href="https://rivers-shall.github.io/2019/09/17/LeetCode-0034-%E4%B8%80%E8%88%AC%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%9A%84%E9%87%8D%E7%82%B9/"/>
    <id>https://rivers-shall.github.io/2019/09/17/LeetCode-0034-一般二分搜索的重点/</id>
    <published>2019-09-17T14:49:28.000Z</published>
    <updated>2020-05-28T06:56:19.810Z</updated>
    
    <content type="html"><![CDATA[<p>题解仓库，更新中 <a href="https://github.com/Rivers-Shall/LeetCode-Java" target="_blank" rel="noopener">GitHub LeetCode-Java</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个排好序的数组，内里元素可能有重复，给定一个目标值，找出目标值最左端和最右端的index。<a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/" target="_blank" rel="noopener">传送门</a></p><h2 id="典型的二分搜索"><a href="#典型的二分搜索" class="headerlink" title="典型的二分搜索"></a>典型的二分搜索</h2><p>二分搜索并不容易写，因为实际上的二分搜索也可以被分成很多类，但是当人们提起时，往往混为一谈，我觉得，基本的，典型的二分搜索有这两类：</p><ol><li>寻找一个特定值</li><li>寻找满足某个条件的连续区间的边界</li></ol><a id="more"></a><p>第一种是最经典的二分搜索，也是初学者最有可能接触到的二分搜索。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而第二种则是本题目中的要求，而且本题将上下界都涵盖了，非常经典。</p><h3 id="二分搜索的重点"><a href="#二分搜索的重点" class="headerlink" title="二分搜索的重点"></a>二分搜索的重点</h3><p>那么，二分搜索的重点有哪些呢？其实只有两点：</p><ol><li>保证每次循环后，如果我们的解存在，那么一定还在$[left, right]$区间里。</li><li>每次循环，区间$[left, right]$一定会缩小</li></ol><p>我们来看看本题的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftEdge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightEdge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔者是先完成了 <code>leftEdge</code> ，后完成 <code>rightEdge</code> 的。从其中的改变可以看出二分搜索三个重点。</p><h4 id="改变一"><a href="#改变一" class="headerlink" title="改变一"></a>改变一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">    right = mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">    left = mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么？因为只有这样改变，才能保证重点一的成立。</p><p>在 <code>leftEdge</code> 中，<code>right = mid</code> 而不是 <code>right = mid - 1</code> 是因为如果 <code>mid</code> 已经是所求解，即区间左端点，那么 <code>mid - 1</code> 会将解排除在外。<br>同理，<code>rightEdge</code> 中，<code>left = mid</code> 而不是 <code>left = mid + 1</code>。</p><h4 id="改变二"><a href="#改变二" class="headerlink" title="改变二"></a>改变二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br></pre></td></tr></table></figure><p>变为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这一改变其实是与改变一联动，其目的是保证重点二的成立。为什么？</p><p>因为如果在 <code>rightEdge</code> 中还使用经典的 <code>int mid = (right - left) / 2 + left;</code>，由于我们使用了 <code>left = mid</code> 来缩减区间，试想如果 <code>right = 2, left = 1</code> 且 <code>nums[mid] &lt;= target</code> 成立, 那么经过计算 <code>mid</code> 永远等于 <code>left</code>,也即区间其实不会缩小，程序进入死循环。</p><p>由于两个方法都是为了寻找区间端点，终归相似之处较多，也基本属于经典范畴。</p><p>但是 LeetCode 上还有另外一题 <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">0033 Search-in-Rotated-Sorted-Array</a> 是一道较为新颖的二分搜索题，乍一看由于没有了经典二分中的序关系，不像二分，但想懂后还是很舒畅的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题解仓库，更新中 &lt;a href=&quot;https://github.com/Rivers-Shall/LeetCode-Java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub LeetCode-Java&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;给定一个排好序的数组，内里元素可能有重复，给定一个目标值，找出目标值最左端和最右端的index。&lt;a href=&quot;https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;典型的二分搜索&quot;&gt;&lt;a href=&quot;#典型的二分搜索&quot; class=&quot;headerlink&quot; title=&quot;典型的二分搜索&quot;&gt;&lt;/a&gt;典型的二分搜索&lt;/h2&gt;&lt;p&gt;二分搜索并不容易写，因为实际上的二分搜索也可以被分成很多类，但是当人们提起时，往往混为一谈，我觉得，基本的，典型的二分搜索有这两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;寻找一个特定值&lt;/li&gt;
&lt;li&gt;寻找满足某个条件的连续区间的边界&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="https://rivers-shall.github.io/categories/LeetCode/"/>
    
    
      <category term="binary search" scheme="https://rivers-shall.github.io/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>UULP-Chapter02-2</title>
    <link href="https://rivers-shall.github.io/2019/05/25/UULP-Chapter02-2/"/>
    <id>https://rivers-shall.github.io/2019/05/25/UULP-Chapter02-2/</id>
    <published>2019-05-25T08:51:55.000Z</published>
    <updated>2020-05-28T06:56:19.809Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Books" scheme="https://rivers-shall.github.io/categories/Books/"/>
    
      <category term="Understanding-Unix/Linux-Programming" scheme="https://rivers-shall.github.io/categories/Books/Understanding-Unix-Linux-Programming/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
