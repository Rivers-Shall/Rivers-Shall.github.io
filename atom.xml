<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>碧漾的自我</title>
  
  <subtitle>beyond myself</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rivers-shall.github.io/"/>
  <updated>2020-06-04T10:51:31.819Z</updated>
  <id>https://rivers-shall.github.io/</id>
  
  <author>
    <name>碧漾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>defer+recover保护gin不panic</title>
    <link href="https://rivers-shall.github.io/2020/06/04/defer-recover%E4%BF%9D%E6%8A%A4gin%E4%B8%8Dpanic/"/>
    <id>https://rivers-shall.github.io/2020/06/04/defer-recover保护gin不panic/</id>
    <published>2020-06-04T10:33:59.000Z</published>
    <updated>2020-06-04T10:51:31.819Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者保护gin构建的web app不panic的方式，简单来说：</p><ol><li>主程中的panic本身是会被gin拦截的</li><li>协程中的panic需要使用<code>defer</code>和<code>recover</code>进行保护</li></ol><a id="more"></a><h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>在我们用gin构建，运行web app并上线了之后，或许有一些请求会经过业务，在特定的情况下出发会触发golang中的<code>panic</code></p><p>按照golang的设定，一旦<code>panic</code>，如果不在函数调用栈中存在<code>recover</code>，那么是一定会使得整个程序终止的</p><p>但是线上的服务是不能够因为一个两个的请求就直接终止了的，这样非常危险，所以我们需要手段来阻止web app在<code>panic</code>的情况下直接终止</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="主程序中的panic"><a href="#主程序中的panic" class="headerlink" title="主程序中的panic"></a>主程序中的<code>panic</code></h3><p>对于gin这个web框架来说，主程序中的<code>panic</code>是会被自动<code>recover</code>的，还会打印出非常详细的日志信息，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/panic"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后我们作如下HTTP请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl localhost:8080/panic</span><br></pre></td></tr></table></figure><p>会发现在gin的运行窗口出现如下信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">2020/06/04 18:42:12 [Recovery] 2020/06/04 - 18:42:12 panic recovered:</span><br><span class="line">GET /panic HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: curl/7.64.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">panic</span><br><span class="line">/Users/admin/go/src/gin-test/main.go:10 (0x1581418)</span><br><span class="line">        main.func1: panic(<span class="string">"panic"</span>)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/context.go:165 (0x156baca)</span><br><span class="line">        (*Context).Next: c.handlers[c.index](c)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/recovery.go:83 (0x157fb13)</span><br><span class="line">        RecoveryWithWriter.func1: c.Next()</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/context.go:165 (0x156baca)</span><br><span class="line">        (*Context).Next: c.handlers[c.index](c)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/logger.go:241 (0x157ec40)</span><br><span class="line">        LoggerWithConfig.func1: c.Next()</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/context.go:165 (0x156baca)</span><br><span class="line">        (*Context).Next: c.handlers[c.index](c)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/gin.go:420 (0x1575d20)</span><br><span class="line">        (*Engine).handleHTTPRequest: c.Next()</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/gin.go:376 (0x157548c)</span><br><span class="line">        (*Engine).ServeHTTP: engine.handleHTTPRequest(c)</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/go/1.13.8/libexec/src/net/http/server.go:2802 (0x12cb6d3)</span><br><span class="line">        serverHandler.ServeHTTP: handler.ServeHTTP(rw, req)</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/go/1.13.8/libexec/src/net/http/server.go:1890 (0x12c6f74)</span><br><span class="line">        (*conn).serve: serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/go/1.13.8/libexec/src/runtime/asm_amd64.s:1357 (0x105c030)</span><br><span class="line">        goexit: BYTE    <span class="variable">$0x90</span>   // NOP</span><br><span class="line"></span><br><span class="line">[GIN] 2020/06/04 - 18:42:12 | 500 |    1.238546ms |             ::1 | GET      <span class="string">"/panic"</span></span><br></pre></td></tr></table></figure><p>并且整个app还在正常运行，没有终止，这非常好</p><h3 id="协程中的panic"><a href="#协程中的panic" class="headerlink" title="协程中的panic"></a>协程中的<code>panic</code></h3><p>不过非常可惜的是，对于协程中的<code>panic</code>，gin并不能做到自动<code>recover</code>并打印日志信息，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/go-panic"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该app之后，我们作如下的HTTP请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl localhost:8080/go-panic</span><br></pre></td></tr></table></figure><p>会发现gin app退出了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">panic: panic</span><br><span class="line"></span><br><span class="line">goroutine 24 [running]:</span><br><span class="line">main.main.func1.1()</span><br><span class="line">        /Users/admin/go/src/gin-test/main.go:11 +0x39</span><br><span class="line">created by main.main.func1</span><br><span class="line">        /Users/admin/go/src/gin-test/main.go:10 +0x35</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure><h4 id="协程解决方案"><a href="#协程解决方案" class="headerlink" title="协程解决方案"></a>协程解决方案</h4><p>所以，对于协程，我们要手动进行<code>defer</code>和<code>recover</code>，来避免app的退出和打印日志信息，比如上面的代码应该修改为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/go-panic"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    fmt.Printf(<span class="string">"error: %v\n"</span>, err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;()</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后我们像刚才一样进行HTTP请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl localhost:8080/go-panic</span><br></pre></td></tr></table></figure><p>会得到如下打印</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: panic</span><br><span class="line">[GIN] 2020/06/04 - 18:50:20 | 200 |       2.951µs |             ::1 | GET      <span class="string">"/go-panic"</span></span><br></pre></td></tr></table></figure><p>可以看到app正常响应了请求，并且没有退出并打印了日志，想要更多定制操作可以修改<code>defer</code>的函数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者保护gin构建的web app不panic的方式，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主程中的panic本身是会被gin拦截的&lt;/li&gt;
&lt;li&gt;协程中的panic需要使用&lt;code&gt;defer&lt;/code&gt;和&lt;code&gt;recover&lt;/code&gt;进行保护&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="gin" scheme="https://rivers-shall.github.io/tags/gin/"/>
    
  </entry>
  
  <entry>
    <title>oop大作业总结与从中看到的未来计划</title>
    <link href="https://rivers-shall.github.io/2020/06/04/oop%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%8E%E4%B8%AD%E7%9C%8B%E5%88%B0%E7%9A%84%E6%9C%AA%E6%9D%A5%E8%AE%A1%E5%88%92/"/>
    <id>https://rivers-shall.github.io/2020/06/04/oop大作业总结与从中看到的未来计划/</id>
    <published>2020-06-04T03:12:09.000Z</published>
    <updated>2020-06-04T08:37:43.540Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是在我完成了oop大作业之后，重新审视自己的开发流程与系统设计的一点总结与展望，简单来说：</p><ol><li>这是个”154/“(一无是处)的项目</li><li>好在能够让我感受到一些努力的方向</li></ol><p>代码就不开源了，实在太差了，就在这里口嗨一下就好</p><a id="more"></a><h2 id="存在的问题与未来的计划"><a href="#存在的问题与未来的计划" class="headerlink" title="存在的问题与未来的计划"></a>存在的问题与未来的计划</h2><h3 id="前端问题"><a href="#前端问题" class="headerlink" title="前端问题"></a>前端问题</h3><ol><li>没有对界面做任何的优化</li><li>没有任何的自动化测试，没有任何的后端分离的测试</li><li>模块化做的很差</li></ol><h4 id="没有对界面做任何的优化"><a href="#没有对界面做任何的优化" class="headerlink" title="没有对界面做任何的优化"></a>没有对界面做任何的优化</h4><p>CSS，是前端三大件中，我认为最复杂的一件，重点在于，CSS并不能被称为一门”编程语言”，应该来说，它是一门”设计用语”，在大学计算机科学中接触到的训练，可以说对CSS的学习是没有任何帮助的，这就导致即便看了很多CSS相关的资料，到了要实现界面效果的时候，还是会出现无从下手的情况</p><p>这次的大作业中，我几乎没有涉及到任何的CSS，只有在数个<code>div</code>需要并列做出类似column的效果时，使用了<code>display: inline-block</code>这样的属性设置，其他的我也想不到什么了</p><p>虽然离提交还有两三个星期，这个时间拿来上手一下element-ui之类的高层库，也是可能优化界面的，但是我觉得简约也是一种特色吧，另外，布置大作业时，长度不到一页纸的需求文档，我也没有太大的兴趣做出一个炫酷的界面，简约的界面反而和这样简约的需求很配呢</p><h4 id="没有任何的自动化测试，没有任何的后端分离测试"><a href="#没有任何的自动化测试，没有任何的后端分离测试" class="headerlink" title="没有任何的自动化测试，没有任何的后端分离测试"></a>没有任何的自动化测试，没有任何的后端分离测试</h4><p>前端的开发流程中，当然会需要测试</p><p>而我这次开发，测试的手段就是把后端服务起来，然后把前端dev-server起来，在界面上点来点去</p><p>这样子的效率低到令人发指，还需要后端的配合：</p><ol><li>点来点去，人傻了都</li><li>如果几次操作之间记忆出现错误，很有可能上一回测到的路径，这次又没有测到</li><li>如果后端接口没有准备好，前端就没有办法测试</li></ol><h4 id="模块化做的很差"><a href="#模块化做的很差" class="headerlink" title="模块化做的很差"></a>模块化做的很差</h4><p>前端的模块化一直以来都是问题挺大的，说实在的设计类要做出非常好的模块化也有点尴尬，另外一方面没有使用高层框架，也会使得模块化更加困难</p><p>首先，vue中的各个模组就已经出现了类似的结构，但是我并没有很好地方法来模块化，做的也有点烦躁</p><p>其次，前端存储和请求发送没有能够很好的模块化，尤其是请求发送模块，完全耦合在了vue的代码里，前端存储模块由于使用的是vuex框架，模块性还好一些，但是由于使用上经验不足，在引入到vue中的时候，出现了一些可读性较差的冗余代码</p><h3 id="前端未来的计划"><a href="#前端未来的计划" class="headerlink" title="前端未来的计划"></a>前端未来的计划</h3><ol><li>basic knowledge + code snippet 学习界面设计</li><li>了解前端的测试方式方法</li><li>了解好的前端架构与模块化开发方式</li></ol><h4 id="basic-knowledge-code-snippet-学习界面设计"><a href="#basic-knowledge-code-snippet-学习界面设计" class="headerlink" title="basic knowledge + code snippet 学习界面设计"></a>basic knowledge + code snippet 学习界面设计</h4><p>如何学习界面的设计？如何用CSS+JS或者高层框架实现设计？这两个问题，每个人都有不同的答案</p><p>我的答案是: basic knowledge + code snippet</p><h5 id="basic-knowledge"><a href="#basic-knowledge" class="headerlink" title="basic knowledge"></a>basic knowledge</h5><p>这就是指对CSS+JS或者高层框架的基础知识要了解，不需要深入，只要能够做到，看到代码，不会感到一头雾水，而是明白，这个属性/样式作用在了哪里，至于效果如何，怎么配置，知道去那里可以查文档就行</p><h5 id="code-snippet"><a href="#code-snippet" class="headerlink" title="code snippet"></a>code snippet</h5><p>这个才是重头戏，毕竟设计类的，只要不是强要求，大部分都可以通过修改他人的设计，而后达到自己的目的</p><p>所以平时要多积累：</p><ol><li>页面经典的布局(导航栏，登录界面，展示界面等)与实现代码</li><li>特殊的交互逻辑(固定在顶部的导航栏，顶部页面滑动进度显示等)与实现代码</li></ol><p>到时候自己想要做炫酷的功能，就直接去code snippet库里找一找，改一改就好</p><h4 id="了解前端的测试方式与方法"><a href="#了解前端的测试方式与方法" class="headerlink" title="了解前端的测试方式与方法"></a>了解前端的测试方式与方法</h4><p>最重要的几个问题：</p><ol><li>如何自动化？<ul><li>如何模拟鼠标，键盘等的交互操作？</li><li>如何验证测试结果？</li><li>前端JS逻辑代码如何测试？如何单元测试？</li></ul></li><li>如何与后端分离？<ul><li>如何模拟(mock)后端接口？</li><li>怎样设计</li></ul></li></ol><h4 id="了解好的前端架构与模块化开发方式"><a href="#了解好的前端架构与模块化开发方式" class="headerlink" title="了解好的前端架构与模块化开发方式"></a>了解好的前端架构与模块化开发方式</h4><p>去看看好的开源项目，他们是</p><ol><li>如何联动使用vue，vuex，vue-router，axios的</li><li>如何将前端存储，请求发送包装成为独立的模块</li><li>如何包装前端框架中的各种模组</li><li>其他的优秀设计理念</li></ol><h3 id="后端的问题"><a href="#后端的问题" class="headerlink" title="后端的问题"></a>后端的问题</h3><ol><li>没有自动化测试</li><li>没有使用数据库事务</li><li>后端REST接口设计的不好</li></ol><h4 id="没有自动化测试"><a href="#没有自动化测试" class="headerlink" title="没有自动化测试"></a>没有自动化测试</h4><p>没有，真的没有，为了快速开发，测试代码为零</p><h4 id="没有使用数据库事务"><a href="#没有使用数据库事务" class="headerlink" title="没有使用数据库事务"></a>没有使用数据库事务</h4><p>这有需求文档的问题(其实大作业布置下来的要求根本没资格被称为需求文档，只能说是非常模糊的甲方需求，<del>啊！万恶的甲方</del>)</p><p>也有个人的问题，本身是有情景需要事务的，但是由于对技术栈不熟悉(JS的express.js+mongoose)，在尝试了几下之后，就放弃了，毕竟还要优先保证完成业务逻辑，现在想想实际上并不是很困难，完全可以做</p><h4 id="后端REST接口设计的不好"><a href="#后端REST接口设计的不好" class="headerlink" title="后端REST接口设计的不好"></a>后端REST接口设计的不好</h4><p>这个”不好”，指的是什么方面呢？</p><p>首先，后端接口在开发过程中还几经变迁，基本上是开发到哪算到哪，最终导致接口变来变去，同时REST的”面向资源的操作”特性不明显</p><p>特性不明显这一点倒感觉未必非常重要，但是几经变迁这件事槽点比较大</p><h3 id="后端未来的计划"><a href="#后端未来的计划" class="headerlink" title="后端未来的计划"></a>后端未来的计划</h3><ol><li>学会自动化测试</li><li>了解各类数据库的使用</li><li>学习各种后端接口的设计</li></ol><h4 id="学会自动化测试"><a href="#学会自动化测试" class="headerlink" title="学会自动化测试"></a>学会自动化测试</h4><ul><li>如何在框架内使用单元测试？</li><li>如何mock HTTP请求?(postman)</li><li>如何自动化mock HTTP请求并验证response？</li></ul><h4 id="了解各类数据库的使用"><a href="#了解各类数据库的使用" class="headerlink" title="了解各类数据库的使用"></a>了解各类数据库的使用</h4><ul><li>SQL与NoSQL</li><li>数据库事务</li><li>数据库底层的实现，各类锁</li></ul><h4 id="学习各种后端接口的设计"><a href="#学习各种后端接口的设计" class="headerlink" title="学习各种后端接口的设计"></a>学习各种后端接口的设计</h4><ul><li>REST风格</li><li>GraphQL接口设计</li><li>RPC调用接口设计</li></ul><h3 id="开发流程上的问题与计划"><a href="#开发流程上的问题与计划" class="headerlink" title="开发流程上的问题与计划"></a>开发流程上的问题与计划</h3><p>主要是文档和git的workflow</p><p>文档方面，要养成良好的习惯，多写点注释，使用文档，需求文档，接口文档，设计的优先级一定是要高于编码的</p><p>git的workflow，要采用master/dev/feature/hotfix的开发方式，保持主分支的干净</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的开发活动，需求不明确，开发者也缺少经验，同时缺少动力(既不能赚钱，也不是自己感兴趣的产品)，所以最终的成品是比较惨的</p><p>总的来说，需要多读，读开源项目的代码，多写，自己找到有兴趣的项目，做一些完整的，良好的开发活动</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是在我完成了oop大作业之后，重新审视自己的开发流程与系统设计的一点总结与展望，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这是个”154/“(一无是处)的项目&lt;/li&gt;
&lt;li&gt;好在能够让我感受到一些努力的方向&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码就不开源了，实在太差了，就在这里口嗨一下就好&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="https://rivers-shall.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>goland中Run与Debug里working-directory的含义</title>
    <link href="https://rivers-shall.github.io/2020/06/03/goland%E4%B8%ADRun%E4%B8%8EDebug%E9%87%8Cworking-directory%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>https://rivers-shall.github.io/2020/06/03/goland中Run与Debug里working-directory的含义/</id>
    <published>2020-06-03T12:15:43.000Z</published>
    <updated>2020-06-03T12:26:58.028Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者由于不了解goland中Run与Debug配置中working-directory含义而引起的bug，简单来说:</p><blockquote><p>working directory就是golang项目编译好后的二进制文件执行的文件夹路径</p></blockquote><h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>项目框架中存在<code>conf</code>这样的专门放置配置文件的文件夹，当使用项目框架自带的<code>build.sh</code>构建脚本时，会将编译好的二进制文件和<code>conf</code>中的配置文件分别拷贝到<code>output/bin</code>和<code>output/conf</code>这两个文件夹下，将<code>output</code>试做发布文件夹</p><p>但是，在goland中如果想要配置Run或者Debug，是不能使用<code>build.sh</code>脚本的，只能配置原始的go编译命令</p><p>在配置的同时，我将working-directory很随意地设置为了<code>output</code>文件夹</p><h2 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h2><p>当我修改了配置文件并进行Run或者Debug时，发现修改没有生效</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>没有生效是因为，working-directory被设置为<code>output</code>文件夹，那么goland在执行goland本身编译好的二进制文件时，会引用<code>output/conf</code>下的配置文件</p><p>但是，<code>conf</code>文件夹下的修改是不会自动同步到<code>output/conf</code>里的(对源代码的修改会同步到goland上，因为goland会重新编译)，必须执行<code>./build.sh</code>脚本才可以</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>可以每次修改配置文件是都先执行<code>./build.sh</code>，然后再goland使用Run或Debug</p><p>也可以将working-directory设置为<code>./</code>而不是设置为<code>./output</code>，这样以后goland编译执行引用的就是<code>./conf</code>中的配置文件，修改也就能直接同步了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文记录了作者由于不了解goland中Run与Debug配置中working-directory含义而引起的bug，简单来说:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;working directory就是golang项目编译好后的二进制文件执行的文件夹路径&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="goland" scheme="https://rivers-shall.github.io/tags/goland/"/>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>bash中的字符串处理操作</title>
    <link href="https://rivers-shall.github.io/2020/06/02/bash%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/"/>
    <id>https://rivers-shall.github.io/2020/06/02/bash中的字符串处理操作/</id>
    <published>2020-06-02T06:35:42.000Z</published>
    <updated>2020-06-02T06:54:41.375Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用bash过程中，为了解决去除前缀后缀的问题而了解到的bash的字符串操作，简单来说</p><ol><li><code>string:position</code>或者<code>string:position:length</code>进行子串提取</li><li><code>string#pattern</code>进行最短匹配前缀去除，<code>string##pattern</code>进行最长匹配前缀去除</li><li><code>string%pattern</code>进行最短匹配后缀去除，<code>string%%pattern</code>进行最长匹配后缀去除</li><li><code>string/pattern/string</code>进行首个<code>pattern</code>替换，<code>string//pattern/string</code>进行全部<code>pattern</code>替换</li><li>以上的<code>pattern</code>指的都是<em>wildcard</em>而不是<em>regular expression</em></li></ol><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有时在使用bash脚本的时候，希望对字符串做一些基本的操作，比如说去除前缀后缀（去除文件扩展名，统一前缀编号等），事实上，bash原生支持了许多字符串操作</p><h2 id="bash-中的字符串操作"><a href="#bash-中的字符串操作" class="headerlink" title="bash 中的字符串操作"></a>bash 中的字符串操作</h2><p><strong>下面所有的<code>pattern</code>指的都是bash wildcard而不是regular expression</strong></p><h3 id="子串提取"><a href="#子串提取" class="headerlink" title="子串提取"></a>子串提取</h3><p>使用<code>string:position</code>提取从<code>position</code>开始的子串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string:3&#125;</span></span><br><span class="line">t, dummy, text, dummy</span><br></pre></td></tr></table></figure><p>使用<code>string:position:length</code>提取从<code>position</code>开始，长度为<code>length</code>的子串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string:3:4&#125;</span></span><br><span class="line">t, d</span><br></pre></td></tr></table></figure><h3 id="前缀去除"><a href="#前缀去除" class="headerlink" title="前缀去除"></a>前缀去除</h3><p>使用<code>string#pattern</code>进行最短匹配前缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string#*text&#125;</span></span><br><span class="line">, dummy, text, dummy</span><br></pre></td></tr></table></figure><p>使用<code>string##pattern</code>进行最长匹配前缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string##*text&#125;</span></span><br><span class="line">, dummy</span><br></pre></td></tr></table></figure><h3 id="后缀去除"><a href="#后缀去除" class="headerlink" title="后缀去除"></a>后缀去除</h3><p>使用<code>string%pattern</code>进行最短匹配后缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string%dummy*&#125;</span></span><br><span class="line">text, dummy, text, y</span><br></pre></td></tr></table></figure><p>使用<code>string%%pattern</code>进行最长匹配后缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string%%dummy*&#125;</span></span><br><span class="line">text,</span><br></pre></td></tr></table></figure><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>使用<code>string/pattern/string</code>进行首个<code>pattern</code>的替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string/text/TEXT&#125;</span></span><br><span class="line">TEXT, dummy, text, dummy</span><br></pre></td></tr></table></figure><p>使用<code>string//pattern/string</code>进行全部<code>pattern</code>的替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string//text/TEXT&#125;</span></span><br><span class="line">TEXT, dummy, TEXT, dummy</span><br></pre></td></tr></table></figure><p>想要得到对正则表达式匹配替换的支持的话，可以使用<a href="https://man.linuxde.net/sed" target="_blank" rel="noopener">sed</a>命令</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用bash过程中，为了解决去除前缀后缀的问题而了解到的bash的字符串操作，简单来说&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;string:position&lt;/code&gt;或者&lt;code&gt;string:position:length&lt;/code&gt;进行子串提取&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string#pattern&lt;/code&gt;进行最短匹配前缀去除，&lt;code&gt;string##pattern&lt;/code&gt;进行最长匹配前缀去除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string%pattern&lt;/code&gt;进行最短匹配后缀去除，&lt;code&gt;string%%pattern&lt;/code&gt;进行最长匹配后缀去除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string/pattern/string&lt;/code&gt;进行首个&lt;code&gt;pattern&lt;/code&gt;替换，&lt;code&gt;string//pattern/string&lt;/code&gt;进行全部&lt;code&gt;pattern&lt;/code&gt;替换&lt;/li&gt;
&lt;li&gt;以上的&lt;code&gt;pattern&lt;/code&gt;指的都是&lt;em&gt;wildcard&lt;/em&gt;而不是&lt;em&gt;regular expression&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="bash" scheme="https://rivers-shall.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中箭头函数与普通函数</title>
    <link href="https://rivers-shall.github.io/2020/06/01/JavaScript%E4%B8%AD%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://rivers-shall.github.io/2020/06/01/JavaScript中箭头函数与普通函数/</id>
    <published>2020-06-01T12:26:38.000Z</published>
    <updated>2020-06-01T12:46:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用mongoose的过程中，因为箭头函数与普通函数的区别而引起的一个bug，以及因此而学会的有关箭头函数与普通函数的区别，简单来说：</p><ol><li>箭头函数不能使用<code>arguments</code>参数，普通函数可以</li><li>箭头函数的<code>this</code>关键字是lexically bound，也就是<code>this</code>是和<strong>最近的外层普通函数</strong>所具有的<code>this</code>一致(如果没有这样的函数，就和文件本身代表的对象绑定)；普通函数的<code>this</code>是dynamically bound，视运行时环境而确定</li></ol><p>其实还有什么<code>new</code>之类的，作者觉得不大重要，就算了</p><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在使用mongoose的过程中，需要对schema构造一个“虚字段”，参考实现中使用如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">itemSchema.virtual(<span class="string">"id"</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._id.toHexString();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我寻思着可以少写点东西，更精简一些，于是在我的实现里使用了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">itemSchema.virtual(<span class="string">"id"</span>).get(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._id.toHexString();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行时报错:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined 没有 toHexString 成员函数</span><br></pre></td></tr></table></figure><p>这才意识到，原来使用箭头函数的时候，<code>this</code>的绑定规则和普通函数不一致</p><h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f2(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这段代码<strong>在浏览器中</strong>，<code>f1</code>可以正常打印，<code>f2</code>会报<code>undefined</code>，当然，在node.js环境下，还会有些不同，可以自己试试</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">exports.mod = <span class="string">"mod"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    f1() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = &#123;</span><br><span class="line">    f1 : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.f1()</span><br><span class="line">user2.f1()</span><br></pre></td></tr></table></figure><p>这段代码在node.js下，打印出如下结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; node test2.js</span><br><span class="line">&#123; f1: [Function: f1] &#125;</span><br><span class="line">&#123; mod: <span class="string">'mod'</span> &#125;</span><br></pre></td></tr></table></figure><p>可见，普通函数绑定的是运行时的对象，箭头函数绑定的是静态的编译时的对象</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用mongoose的过程中，因为箭头函数与普通函数的区别而引起的一个bug，以及因此而学会的有关箭头函数与普通函数的区别，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;箭头函数不能使用&lt;code&gt;arguments&lt;/code&gt;参数，普通函数可以&lt;/li&gt;
&lt;li&gt;箭头函数的&lt;code&gt;this&lt;/code&gt;关键字是lexically bound，也就是&lt;code&gt;this&lt;/code&gt;是和&lt;strong&gt;最近的外层普通函数&lt;/strong&gt;所具有的&lt;code&gt;this&lt;/code&gt;一致(如果没有这样的函数，就和文件本身代表的对象绑定)；普通函数的&lt;code&gt;this&lt;/code&gt;是dynamically bound，视运行时环境而确定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实还有什么&lt;code&gt;new&lt;/code&gt;之类的，作者觉得不大重要，就算了&lt;/p&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
    
      <category term="JavaScript" scheme="https://rivers-shall.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>grep打印匹配行的未匹配内容</title>
    <link href="https://rivers-shall.github.io/2020/06/01/grep%E6%89%93%E5%8D%B0%E5%8C%B9%E9%85%8D%E8%A1%8C%E7%9A%84%E6%9C%AA%E5%8C%B9%E9%85%8D%E5%86%85%E5%AE%B9/"/>
    <id>https://rivers-shall.github.io/2020/06/01/grep打印匹配行的未匹配内容/</id>
    <published>2020-06-01T10:47:40.000Z</published>
    <updated>2020-06-01T12:06:53.634Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用<code>grep</code>和<code>sed</code>命令来实现，打印<code>grep</code>匹配行中的未匹配内容的功能的方法，简单来说：</p><ol><li>先使用<code>grep &lt;pattern&gt;</code>提取出匹配行</li><li>再使用<code>sed -e &#39;s/&lt;pattern&gt;//g&#39;</code>将匹配内容消除，即可得到未匹配内容</li></ol><a id="more"></a><h2 id="场景与方案"><a href="#场景与方案" class="headerlink" title="场景与方案"></a>场景与方案</h2><p>使用<code>grep</code>时，我们可以用<code>grep &lt;pattern&gt;</code>来打印出匹配行，可以使用<code>grep -o &lt;pattern&gt;</code>来打印出匹配行中的匹配内容，但是如果希望能够实现“反选”，也就是打印出匹配行中的费匹配内容，应该怎么做呢？</p><p>单纯的<code>grep</code>命令没有提供这种机制的支持，但是同时使用<code>grep</code>和<code>sed</code>命令就可以实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"matched not\nmat"</span> | grep <span class="string">"matched"</span> | sed <span class="string">"s/matched//g"</span></span><br><span class="line"> not</span><br></pre></td></tr></table></figure><p>首先，我们使用<code>grep &lt;pattern&gt;</code>打印出匹配行，而后，使用<code>sed &quot;s/&lt;pattern&gt;//g&quot;</code>将匹配行中的匹配内容替换为空字符串，就消除了匹配内容，留下了非匹配内容</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用&lt;code&gt;grep&lt;/code&gt;和&lt;code&gt;sed&lt;/code&gt;命令来实现，打印&lt;code&gt;grep&lt;/code&gt;匹配行中的未匹配内容的功能的方法，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先使用&lt;code&gt;grep &amp;lt;pattern&amp;gt;&lt;/code&gt;提取出匹配行&lt;/li&gt;
&lt;li&gt;再使用&lt;code&gt;sed -e &amp;#39;s/&amp;lt;pattern&amp;gt;//g&amp;#39;&lt;/code&gt;将匹配内容消除，即可得到未匹配内容&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://rivers-shall.github.io/tags/sed/"/>
    
      <category term="grep" scheme="https://rivers-shall.github.io/tags/grep/"/>
    
  </entry>
  
  <entry>
    <title>bash实现trim字符串</title>
    <link href="https://rivers-shall.github.io/2020/06/01/bash%E5%AE%9E%E7%8E%B0trim%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://rivers-shall.github.io/2020/06/01/bash实现trim字符串/</id>
    <published>2020-06-01T10:27:53.000Z</published>
    <updated>2020-06-01T10:43:55.574Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用<code>sed</code>命令对bash中的字符串进行去头尾空格的操作的方法，简单来说</p><ol><li>使用<code>echo &#39;  string  &#39; | sed -e &#39;s/^[[:space:]]*//&#39;</code>去除开头的空格</li><li>使用<code>echo &#39;  string  &#39; | sed -e &#39;s/[[:space:]]*$//&#39;</code>去除结尾的空格</li><li>将二者用管道结合，去除头尾空格<code>echo &#39;  string  &#39; | sed -e &#39;s/[[:space:]]*$//&#39; | sed -e &#39;s/^[[:space:]]*//&#39;</code></li></ol><a id="more"></a><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>去除头尾空格的字符串处理操作是非常常用的操作，在许多语言的标准库里都会以<code>trim</code>函数的方式提供出来</p><p>要在bash中实现这一功能，可以使用<code>sed</code>命令的替换子命令</p><p><code>sed -e &#39;s/^[[:space:]]*//&#39;</code>是指匹配所有行开头的空格并将其替换为空字符串</p><p><code>sed -e &#39;s/[[:space:]]*$//&#39;</code>是指匹配所有行结尾的空格并将其替换为空字符串</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用&lt;code&gt;sed&lt;/code&gt;命令对bash中的字符串进行去头尾空格的操作的方法，简单来说&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/^[[:space:]]*//&amp;#39;&lt;/code&gt;去除开头的空格&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/[[:space:]]*$//&amp;#39;&lt;/code&gt;去除结尾的空格&lt;/li&gt;
&lt;li&gt;将二者用管道结合，去除头尾空格&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/[[:space:]]*$//&amp;#39; | sed -e &amp;#39;s/^[[:space:]]*//&amp;#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://rivers-shall.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>转义sed替换模式字符串</title>
    <link href="https://rivers-shall.github.io/2020/06/01/%E8%BD%AC%E4%B9%89sed%E6%9B%BF%E6%8D%A2%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://rivers-shall.github.io/2020/06/01/转义sed替换模式字符串/</id>
    <published>2020-06-01T05:47:34.000Z</published>
    <updated>2020-06-01T10:43:41.406Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用<code>sed</code>命令进行文本替换时，对于使用到的替换模式进行转义处理使用到的<code>sed</code>命令，简单来说：</p><ul><li>使用<code>sed -e &#39;s/[]\/$*.^[]/\\&amp;/g&#39;</code>即可对输入字符串进行转义</li></ul><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><code>sed</code>命令常常被用来对文本做处理，其中一个最经常用到的处理就是替换，替换的语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$STRING</span> | sed -e <span class="string">'s/&lt;match_pattern&gt;/&lt;replace_pattern&gt;/g'</span></span><br></pre></td></tr></table></figure><p>当然也可以有其他的变化，不过这是作者使用的最多的方式。</p><p>在使用这些的时候，我们可能会在<code>match_pattern</code>和<code>replace_pattern</code>中引用变量，已达到分别管理和增强可读性的目的，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"ff"</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>但是，如果上面引用的<code>REPLACE</code>里面有特殊字符，我们就会遇到问题，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"/a"</span></span><br><span class="line"><span class="comment"># 有问题</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>我们的本意是将<code>a</code>替换为<code>/a</code>，但是，使用这几条命令，会得到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed: 1: <span class="string">"s/a//a/g</span></span><br><span class="line"><span class="string">"</span>: bad flag <span class="keyword">in</span> substitute <span class="built_in">command</span>: <span class="string">'a'</span></span><br></pre></td></tr></table></figure><p>这里的原因就是<code>/a</code>中的<code>/</code>是一个特殊字符，如果希望得到我们上述的效果，应该这么操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"\/a"</span></span><br><span class="line"><span class="comment"># 成功</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>我们通过<code>\/</code>进行转义，取得了成功，但是这种方式使得我们编写<code>replace_pattern</code>变得麻烦，而且很不直观，我们希望有一个函数来达到如下效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"/a"</span></span><br><span class="line">REPLACE=$(func <span class="variable">$REPLACE</span>)</span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>也就是说，编写<code>replace_pattern</code>时，可以直接编写，而后使用一个函数或者命令自动转义再使用</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><a href="https://stackoverflow.com/questions/407523/escape-a-string-for-a-sed-replace-pattern" target="_blank" rel="noopener">stackoverflow</a></p><p>使用<code>sed -e &#39;s/[]\/$*.^[]/\\&amp;/g&#39;</code>即可</p><h3 id="方案解析"><a href="#方案解析" class="headerlink" title="方案解析"></a>方案解析</h3><p>我们这次的方案就是对原生的<code>replace_pattern</code>做一次替换:</p><ul><li><code>match_pattern</code>为<code>[]\/$*.^[]</code><ul><li>这个正则表达式的结构很具有迷惑性，其实它是一个大的<em>bracket group</em></li><li>也就是说，实际上是<code>[</code> <code>]\/$*.^[</code> <code>]</code>的结构</li><li>意味着匹配<code>]\/$*.^[</code>中的任一字符</li></ul></li><li><code>replace_pattern</code>为<code>\\&amp;</code><ul><li>这个<code>replace_pattern</code>用到了一个转义字符和一个特殊字符</li><li>转义字符<code>\\</code>表示的就是<code>\</code></li><li>特殊字符<code>&amp;</code>表示的是<code>match_pattern</code>匹配到的内容</li></ul></li></ul><p>综合起来，这个替换语句就是把<code>]\/$*.^[</code>前面全部加上一个斜杠，进行转义</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用&lt;code&gt;sed&lt;/code&gt;命令进行文本替换时，对于使用到的替换模式进行转义处理使用到的&lt;code&gt;sed&lt;/code&gt;命令，简单来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;sed -e &amp;#39;s/[]\/$*.^[]/\\&amp;amp;/g&amp;#39;&lt;/code&gt;即可对输入字符串进行转义&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://rivers-shall.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>date命令的两种常用法</title>
    <link href="https://rivers-shall.github.io/2020/06/01/date%E5%91%BD%E4%BB%A4%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%B3%95/"/>
    <id>https://rivers-shall.github.io/2020/06/01/date命令的两种常用法/</id>
    <published>2020-06-01T03:17:25.000Z</published>
    <updated>2020-06-01T10:43:59.583Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在平时工作中经常用到的Linux命令<code>date</code>的两种常见使用方式，简单来说：</p><ol><li>打印当前时间，<code>date &quot;+&lt;output_format&gt;&quot;</code></li><li>将Unix时间戳转化为可读的日期+时间<code>date -r &lt;unix-timestamp&gt; &quot;+&lt;output_format&gt;&quot;</code></li></ol><a id="more"></a><h2 id="打印当前时间"><a href="#打印当前时间" class="headerlink" title="打印当前时间"></a>打印当前时间</h2><p>只需要使用<code>date &quot;+&lt;output_format&gt;&quot;</code>就可以打印当前时间，其中，<code>output_format</code>由正常字符和转义字符组成，转义字符用来打印当前的年，月，日等等</p><table><thead><tr><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td>%Y</td><td>年</td></tr><tr><td>%m</td><td>月</td></tr><tr><td>%d</td><td>日</td></tr><tr><td>%H</td><td>小时</td></tr><tr><td>%M</td><td>分钟</td></tr><tr><td>%S</td><td>秒</td></tr><tr><td>%s</td><td>时间戳</td></tr></tbody></table><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date <span class="string">"+%Y-%m-%d-%H-%M-%S"</span></span><br><span class="line">2020-06-01-11-24-39</span><br></pre></td></tr></table></figure><h2 id="将Unix时间戳转化为可读的日期-时间"><a href="#将Unix时间戳转化为可读的日期-时间" class="headerlink" title="将Unix时间戳转化为可读的日期+时间"></a>将Unix时间戳转化为可读的日期+时间</h2><p>使用<code>date -r &lt;unix-timestamp&gt; &quot;+&lt;output_format&gt;&quot;</code>即可完成转化，其中的<code>output_format</code>和上文中介绍的一样，<code>&lt;unix-timestamp</code>就是一个数字</p><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date -r 0 <span class="string">"+%Y-%m-%d-%H-%M-%S"</span></span><br><span class="line">1970-01-01-08-00-00</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在平时工作中经常用到的Linux命令&lt;code&gt;date&lt;/code&gt;的两种常见使用方式，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打印当前时间，&lt;code&gt;date &amp;quot;+&amp;lt;output_format&amp;gt;&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将Unix时间戳转化为可读的日期+时间&lt;code&gt;date -r &amp;lt;unix-timestamp&amp;gt; &amp;quot;+&amp;lt;output_format&amp;gt;&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>git-status中文乱码问题</title>
    <link href="https://rivers-shall.github.io/2020/05/29/git-status%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://rivers-shall.github.io/2020/05/29/git-status中文乱码问题/</id>
    <published>2020-05-29T10:21:28.000Z</published>
    <updated>2020-06-01T10:43:31.134Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者解决<code>git status</code>命令中出现中文名乱码问题的方法，简单来说</p><blockquote><p>配置 core.quotepath 为 false 即可</p></blockquote><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>当我们的修改文件中出现中文文件名时，<code>git status</code>就会出现乱码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  project git:(master) ✗ git status -s</span><br><span class="line">?? <span class="string">"\344\270\255\346\226\207\346\226\207\344\273\266"</span></span><br></pre></td></tr></table></figure><p>这是由于Git默认会对ASCII以外的编码进行转义，只要将这个转义关掉，就可以恢复正常了，关掉的方式就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  project git:(master) ✗ git config core.quotepath <span class="literal">false</span></span><br><span class="line">➜  project git:(master) ✗ git status -s</span><br><span class="line">?? 中文文件</span><br></pre></td></tr></table></figure><p>当然，如果希望让这个设定在所有的Git本地仓库里都生效，可以加上<code>--global</code>选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  project git:(master) ✗ git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者解决&lt;code&gt;git status&lt;/code&gt;命令中出现中文名乱码问题的方法，简单来说&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置 core.quotepath 为 false 即可&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="git" scheme="https://rivers-shall.github.io/tags/git/"/>
    
      <category term="中文乱码" scheme="https://rivers-shall.github.io/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>golang抽取接口，依赖注入(依赖倒置)解决包引用关系</title>
    <link href="https://rivers-shall.github.io/2020/05/28/golang%E6%8A%BD%E5%8F%96%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE-%E8%A7%A3%E5%86%B3%E5%8C%85%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB/"/>
    <id>https://rivers-shall.github.io/2020/05/28/golang抽取接口，依赖注入-依赖倒置-解决包引用关系/</id>
    <published>2020-05-28T06:58:15.000Z</published>
    <updated>2020-06-01T10:45:20.723Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在golang开发中，通过抽取接口，依赖注入的方式，解决包与包之间的不合理引用关系。</p><p>总结来说：</p><blockquote><p>面向接口编程，并且golang中接口函数的参数最好是标准库的类型</p></blockquote><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>目前项目中有一个业务逻辑包<code>business_logic</code>，两个工具库包<code>pkg1</code>和<code>pkg2</code>，其中</p><ul><li><code>pkg1</code>是旧库，API不宜改动，<code>pkg2</code>是新库，尚未正式使用</li><li><code>business_logic</code>会使用<code>pkg1</code>和<code>pkg2</code></li><li><code>pkg1</code>内部要添加使用<code>pkg2</code>的逻辑</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg1/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"pkg2"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg2.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg2/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    param1 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">(s S)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// business_logic/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"pkg1"</span></span><br><span class="line">    <span class="string">"pkg2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg1.ExternalAPI()</span><br><span class="line">    pkg2.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就引起了一个问题：</p><blockquote><p><code>business_logic</code>其实引用了两次<code>pkg2</code>，一次是直接引用，一次是通过<code>pkg1</code>间接引用，将来在版本更迭中，很有可能会出现直接引用的版本和间接引用的版本不一致的情况，从而引起未知bug</p></blockquote><h2 id="解决尝试"><a href="#解决尝试" class="headerlink" title="解决尝试"></a>解决尝试</h2><p>如果不希望两次引用，那么最好的方式是消除<code>pkg1</code>对<code>pkg2</code>的引用，消除引用的方式是</p><ul><li><code>pkg1</code>抽象出一个接口，</li><li>让<code>pkg2</code>提供结构体，实现<code>pkg1</code>抽象出的接口</li></ul><p>这样，<code>pkg2</code>实际上就变成了<code>pkg1</code>的一个插件，只要在<code>business_logic</code>初始化的时候，将<code>pkg2</code>的插件注入到<code>pkg1</code>里去就行</p><p>但是这样的尝试失败了，我们先来看一下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg1/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"pkg2"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    ExternalAPI(s pkg2.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plugin Plugin</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> plugin != <span class="literal">nil</span> &#123;</span><br><span class="line">        plugin.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetPlugin</span><span class="params">(p Plugin)</span></span> &#123;</span><br><span class="line">    plugin = p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg2/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    param1 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Plugin)</span> <span class="title">ExternalAPI</span><span class="params">(s S)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">(s S)</span></span> &#123;</span><br><span class="line">    p := Plugin&#123;&#125;</span><br><span class="line">    p.ExternalAPI(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// business_logic/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"pkg1"</span></span><br><span class="line">    <span class="string">"pkg2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg1.SetPlugin(&amp;pkg2.Plugin&#123;&#125;)</span><br><span class="line">    pkg1.ExternalAPI()</span><br><span class="line">    pkg2.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，<code>pkg1</code>对<code>pkg2</code>的引用仍旧存在，其原因在于抽取出来的接口函数中的参数是属于<code>pkg2</code>的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    ExternalAPI(s pkg2.S)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终解决方案"><a href="#最终解决方案" class="headerlink" title="最终解决方案"></a>最终解决方案</h2><p>由于<code>pkg2</code>是新库，所以我们决定更改它的接口，最终的代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg1/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    ExternalAPI(param <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plugin Plugin</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> plugin != <span class="literal">nil</span> &#123;</span><br><span class="line">        plugin.ExternalAPI(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetPlugin</span><span class="params">(p Plugin)</span></span> &#123;</span><br><span class="line">    plugin = p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg2/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Plugin)</span> <span class="title">ExternalAPI</span><span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    p := Plugin&#123;&#125;</span><br><span class="line">    p.ExternalAPI(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// business_logic/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"pkg1"</span></span><br><span class="line">    <span class="string">"pkg2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg1.SetPlugin(&amp;pkg2.Plugin&#123;&#125;)</span><br><span class="line">    pkg1.ExternalAPI()</span><br><span class="line">    pkg2.ExternalAPI(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这回彻底解决了<code>pkg1</code>引用<code>pkg2</code>的问题，代价就是将<code>pkg2.S</code>这个结构体参数展开了</p><p>视具体业务情况而定，我们可以通过：</p><ol><li>展开结构体</li><li>将结构体换做<code>map[string]interface{}</code>（当然需要手动做字段的提取和塞入）</li><li>将结构体换做<code>string</code>，用JSON传参（手动Marshal和Unmarshal）</li><li>将参数类型放到新的第三方库<code>pkg3</code>中（这样就又要维护引用的<code>pkg3</code>版本一致）</li></ol><p>软件开发中没有silver-bullet，只有trade-off，这次的方案，也还算满意</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在golang开发中，通过抽取接口，依赖注入的方式，解决包与包之间的不合理引用关系。&lt;/p&gt;
&lt;p&gt;总结来说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;面向接口编程，并且golang中接口函数的参数最好是标准库的类型&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/code-snippet/good-practice/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>一个golang的RPC框架设计中的坑点</title>
    <link href="https://rivers-shall.github.io/2020/05/27/%E4%B8%80%E4%B8%AAgolang%E7%9A%84RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%9D%91%E7%82%B9/"/>
    <id>https://rivers-shall.github.io/2020/05/27/一个golang的RPC框架设计中的坑点/</id>
    <published>2020-05-27T13:13:42.000Z</published>
    <updated>2020-06-01T10:45:39.404Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用公司的RPC框架时，由于RPC框架本身的设计以及程序员的投机取巧而遇到的一个坑点。</p><p>简单来说，RPC框架没有能够做足够好的封装，程序员（不是作者，是前人）也没有按照RPC框架约定的方式进行API调用。</p><a id="more"></a><h2 id="背景提要"><a href="#背景提要" class="headerlink" title="背景提要"></a>背景提要</h2><p>我们知道，RPC调用是不同主机间的进程通信的方式，如果想要额外传递消息，我们往往需要修改RPC调用的接口，通过新增参数的方式来新增传递信息。</p><p>但是这样修改参数，修改接口的方式侵入性太强，需要进行上下游调用接口的适配，很麻烦。</p><p>当我们面对一些遍布在各个RPC服务的需求（也就是很多人喜欢提及的编程”切面”Aspect），比如这回我接到的日志系统的需求，将所有的接口都修改一遍，显然是不现实的。</p><p>在这里，golang的RPC框架可以通过传递<code>context.Context</code>来实现，也就是说，这些额外的，遍布各个RPC服务的消息，通过<code>context.Context</code>来传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc 上游调用时，传递一个`context.Context`和本来必要的下游rpc接口参数</span></span><br><span class="line">rpcClient.remoteMethod(ctx, request)</span><br><span class="line"></span><br><span class="line"><span class="comment">// rpc 下游接受请求时，接受一个`context.Context`和本来必要的接口参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">methodHandler</span><span class="params">(ctx context.Context, request MethodRequest)</span></span></span><br></pre></td></tr></table></figure><h3 id="类比HTTP解释"><a href="#类比HTTP解释" class="headerlink" title="类比HTTP解释"></a>类比HTTP解释</h3><p>上面提及的RPC调用传递<code>context.Context</code>和本来的接口参数，其实可以类比HTTP协议：</p><ul><li><code>context.Context</code> -&gt; HTTP Request Headers</li><li>接口参数 -&gt; HTTP Request Body</li></ul><p>二者都是传递信息的手段，但是接口参数和Request Body往往是明面上的写出来的主要业务逻辑需要的消息，<code>context.Context</code>和Request Headers往往是一些元数据(metadata)。</p><h2 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h2><p>这次的日志系统，需要我记录RPC运行时的动态调用链，也就是说，如果有一条RPC调用链路是</p><blockquote><p>RPC1 -&gt; RPC2 -&gt; RPC3</p></blockquote><p>那么实时的日志里，会有如下条目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RPC1:</span><br><span class="line">stack : []</span><br><span class="line"></span><br><span class="line">RPC2:</span><br><span class="line">stack : [RPC1]</span><br><span class="line"></span><br><span class="line">RPC3:</span><br><span class="line">stack : [RPC1, RPC2]</span><br></pre></td></tr></table></figure><h2 id="解决过程中遇到的问题"><a href="#解决过程中遇到的问题" class="headerlink" title="解决过程中遇到的问题"></a>解决过程中遇到的问题</h2><p>对于这个功能，我们发现RPC框架提供了三个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向一个context.Context加入key-val键值对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInfo</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, val <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 获取上游通过<span class="title">AddInfo</span>传来的<span class="title">key</span>对应的<span class="title">val</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">GetUpstreamInfo</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 获取所有上游通过<span class="title">AddInfo</span>传来的键值对，组织成一个<span class="title">map</span>[<span class="title">string</span>][<span class="title">string</span>]</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">GetAllUpstreamInfo</span><span class="params">(ctx context.Context)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>为此，我们的解决方案是，将<code>stack</code>做成<code>[]RPC</code>，其中<code>struct RPC</code>记录RPC的信息，通过JSON将<code>[]RPC</code>转化成<code>string</code>，而后用<code>context.Context</code>里的<code>&quot;stack&quot; - JSON([]RPC)</code>的键值对进行传递。</p><p>在我之前编码的程序员，没有遵守API调用规则，不使用<code>AddInfo</code>，而是使用的是如下方式进行<code>stack</code>的传递的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有的键值对</span></span><br><span class="line">m := util.GetAllUpstreamInfo(ctx)</span><br><span class="line"><span class="comment">// 取出stack并使用JSON解析</span></span><br><span class="line">stack, err := json.Unmarshal(m[<span class="string">"stack"</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加现有RPC调用</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, currentRPC)</span><br><span class="line"><span class="comment">// JOSN编码，更新ctx内的map</span></span><br><span class="line">m[<span class="string">"stack"</span>], err = json.Marshal(stack)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于golang中的map是引用传值，所以看上去这个代码已经成功更新了ctx内部的map，使用Goland-Debug查看ctx也会发现map已经修改了</p><p>但事实上程序并没有按照预期的方式进行工作</p><h3 id="排查原因"><a href="#排查原因" class="headerlink" title="排查原因"></a>排查原因</h3><p>仔细观察<code>AddInfo</code>函数的签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInfo</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, val <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br></pre></td></tr></table></figure><p>该函数返回了一个全新的Context，事实上<code>AddInfo</code>的逻辑是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">newCtx := AddInfo(ctx, <span class="string">"key"</span>, <span class="string">"val"</span>)</span><br><span class="line"></span><br><span class="line">+------------------------------+</span><br><span class="line">|          newCtx              |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |        ctx             | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|    K_KV -&gt;                   |</span><br><span class="line">| <span class="keyword">struct</span>&#123;key:<span class="string">"key"</span>,val:<span class="string">"val"</span>&#125;  |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><p>也就是说，新的Context在原来的Context上多加了一层，这一层的结构是</p><p><code>K_KV(RPC框架定义的一个字符串) -&gt; struct{key: &quot;key&quot;, val: &quot;val&quot;}</code></p><p>我们通过<code>newCtx.Value(&quot;key&quot;)</code>是拿不到任何东西的，只能通过<code>newCtx.Value(K_KV)</code>才能拿到完整的键值对</p><h4 id="这时，RPC框架有了一个骚操作"><a href="#这时，RPC框架有了一个骚操作" class="headerlink" title="这时，RPC框架有了一个骚操作"></a>这时，RPC框架有了一个骚操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPC1 ctx -------中间对ctx做了转化----------&gt; RPC2</span><br></pre></td></tr></table></figure><p>假设我们上游RPC1使用了如下<code>AddInfo</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">newCtx := AddInfo(ctx, <span class="string">"key"</span>, <span class="string">"val"</span>)</span><br><span class="line">newCtx2 := AddInfo(newCtx, <span class="string">"key2"</span>, <span class="string">"val2"</span>)</span><br><span class="line"></span><br><span class="line">+------------------------------+</span><br><span class="line">|          newCtx2             |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|   |      newCtx            | |</span><br><span class="line">|   |   +-------------+      | |</span><br><span class="line">|   |   |    ctx      |      | |</span><br><span class="line">|   |   +-------------+      | |</span><br><span class="line">|   | K_KV -&gt; <span class="keyword">struct</span>&#123;        | |</span><br><span class="line">|   |          key:<span class="string">"key"</span>     | |</span><br><span class="line">|   |          val:<span class="string">"val"</span>&#125;    | |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|  K_KV -&gt; <span class="keyword">struct</span>&#123;key:<span class="string">"key2"</span>,  |</span><br><span class="line">|                 val:<span class="string">"val2"</span>&#125;  |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><p>那么<code>newCtx2</code>就该如图示的那样，但是下游RPC2拿到的是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------+</span><br><span class="line">|          newCtx              |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |        ctx             | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|    K_UPSTREAM -&gt;             |</span><br><span class="line">|     <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;       |</span><br><span class="line">|           <span class="string">"key"</span> : <span class="string">"val"</span>,     |</span><br><span class="line">|           <span class="string">"key2"</span> : <span class="string">"val2"</span>    |</span><br><span class="line">|     &#125;                        |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><p>所以，用于从Context取出键值对的索引从<code>K_KV</code>变为了<code>K_UPSTREAM</code>!!!</p><p>这意味着上游传来的消息最多只能保留一个RPC路径，所以我们必须使用<code>AddInfo</code>而不是直接写入map的方式来更新数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有的键值对</span></span><br><span class="line">m := util.GetAllUpstreamInfo(ctx)</span><br><span class="line"><span class="comment">// 取出stack并使用JSON解析</span></span><br><span class="line">stack, err := json.Unmarshal(m[<span class="string">"stack"</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加现有RPC调用</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, currentRPC)</span><br><span class="line"><span class="comment">// JOSN编码，更新ctx内的map</span></span><br><span class="line">jsonStack, err := json.Marshal(stack)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">ctx = util.AddInfo(ctx, <span class="string">"stack"</span>, jsonStack)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>框架底层的逻辑并不是很易懂，解释比较麻烦，一篇博文难以说明清楚，但是需要记住的是：</p><ol><li>使用框架，尽量使用框架的标准接口</li><li>框架封装的时候，如果有map这类可能会让人有hack欲望的，写明文档</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用公司的RPC框架时，由于RPC框架本身的设计以及程序员的投机取巧而遇到的一个坑点。&lt;/p&gt;
&lt;p&gt;简单来说，RPC框架没有能够做足够好的封装，程序员（不是作者，是前人）也没有按照RPC框架约定的方式进行API调用。&lt;/p&gt;
    
    </summary>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="RPC" scheme="https://rivers-shall.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>编写自定义启动脚本时的注意项</title>
    <link href="https://rivers-shall.github.io/2020/05/27/%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E9%A1%B9/"/>
    <id>https://rivers-shall.github.io/2020/05/27/编写自定义启动脚本时的注意项/</id>
    <published>2020-05-27T13:12:04.000Z</published>
    <updated>2020-06-01T10:44:34.420Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章介绍了作者在使用和编写自定义启动脚本时感受到的一个需要注意的点，简单来说，就是：</p><blockquote><p>一定要打印出事实上的最终启动命令</p></blockquote><a id="more"></a><h2 id="自定义启动脚本的使用场景"><a href="#自定义启动脚本的使用场景" class="headerlink" title="自定义启动脚本的使用场景"></a>自定义启动脚本的使用场景</h2><p>我们知道，启动一个程序需要固定的命令，比如说</p><ul><li>C/C++/Go可以编译出一个可执行文件，<code>./app</code>来启动</li><li>Java通过JDK<code>java</code>命令启动，<code>java APP</code></li></ul><p>但是，管理大型项目时，未必会是简单的<code>./app</code>这样就可以启动的，我们有可能会需要传入许多选项和参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./<span class="built_in">exec</span> -option1 -option2 arg1</span><br><span class="line"></span><br><span class="line">./app -debug -entryPoint 3000</span><br></pre></td></tr></table></figure><p>而这些选项和参数又有可能依赖于更高级的输入，比如说配置文件，环境变量等等</p><p>这时，就是自动化启动脚本登场的时候了，通过从高层输入（比如文件，环境变量）抽取出选项和参数，最终自动形成启动命令</p><h2 id="自动化启动脚本导致的问题"><a href="#自动化启动脚本导致的问题" class="headerlink" title="自动化启动脚本导致的问题"></a>自动化启动脚本导致的问题</h2><p>在各大IDE中，想要使用Debug功能，需要提供的正是<strong>最终启动命令</strong>，也就是上文的<code>./app -debug -entryPoint 3000</code>这种</p><p>否则IDE无法调用调试器连接调试端口，也就无法实现单步调试，变量检查等功能了</p><p>但是要想从自动化脚本和当下的高层输入一起来推算出最终启动命令，可能是一件比较困难或者至少是麻烦的事情（复杂的自动化启动脚本可能本身就有上百行）</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在自动化脚本启动最终命令之前，将最终命令打印出来。</p><p>这样，我们就只需要执行一次自动化脚本，而后将打印出来的最终命令提供给IDE，就可以开启Debug模式了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章介绍了作者在使用和编写自定义启动脚本时感受到的一个需要注意的点，简单来说，就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一定要打印出事实上的最终启动命令&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue中为对象添加字段</title>
    <link href="https://rivers-shall.github.io/2020/05/27/Vue%E4%B8%AD%E4%B8%BA%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5/"/>
    <id>https://rivers-shall.github.io/2020/05/27/Vue中为对象添加字段/</id>
    <published>2020-05-27T13:09:18.000Z</published>
    <updated>2020-06-01T10:43:19.589Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用Vue.js，并且在前端中为对象添加字段时遇到的坑点。</p><a id="more"></a><h2 id="场景与问题"><a href="#场景与问题" class="headerlink" title="场景与问题"></a>场景与问题</h2><p>从后端拿到数据之后，可能为了渲染时的方便，想要在对象里添加一些字段，而后直接在渲染时引用</p><p>直观上实现这种功能可以直接使用原生的js语法，抽象出来，可以用如下的代码段表示(为了复制就可以演示，没有组件化)</p><p>但是如下代码是有问题的，<code>obj.newField</code>不能被渲染出来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            &#123;&#123; obj.newField &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">            data : &#123;</span></span><br><span class="line"><span class="undefined">                obj : &#123;&#125;,</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            created() &#123;</span></span><br><span class="line"><span class="javascript">                obj.newField = <span class="string">"newData"</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正确的做法是使用<code>Vue.set</code>，因为在<a href="https://cn.vuejs.org/v2/api/#Vue-set" target="_blank" rel="noopener">Vue的官方文档</a>里有如下的表述</p><blockquote><p>因为 Vue 无法探测普通的新增 property (比如 this.myObject.newProperty = ‘hi’)</p></blockquote><p>所以上述代码应该改成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            &#123;&#123; obj.newField &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">            data : &#123;</span></span><br><span class="line"><span class="undefined">                obj : &#123;&#125;,</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            created() &#123;</span></span><br><span class="line"><span class="javascript">                Vue.set(obj, <span class="string">"newField"</span>, <span class="string">"newData"</span>)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用Vue.js，并且在前端中为对象添加字段时遇到的坑点。&lt;/p&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Vue" scheme="https://rivers-shall.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>golang获取执行函数名，执行文件名与所在行数</title>
    <link href="https://rivers-shall.github.io/2020/05/27/golang%E8%8E%B7%E5%8F%96%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E5%90%8D%EF%BC%8C%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%8E%E6%89%80%E5%9C%A8%E8%A1%8C%E6%95%B0/"/>
    <id>https://rivers-shall.github.io/2020/05/27/golang获取执行函数名，执行文件名与所在行数/</id>
    <published>2020-05-27T01:19:50.000Z</published>
    <updated>2020-06-01T10:43:16.678Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章介绍了作者在参与一个golang日志系统的开发的时候，解决需要打印出执行<strong>日志打印操作</strong>时的<strong>业务函数名，业务文件名与所在行数</strong>的需求过程中，遇到的问题和解决方案</p><a id="more"></a><h2 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h2><p>在平日里使用日志的时候，一个好的日志系统，往往会打印出类似如下的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;log_level&gt;:&lt;log_message&gt;:&lt;package_path&gt;/&lt;filename&gt;:&lt;line_no&gt;:&lt;function_name&gt;</span><br><span class="line">比如</span><br><span class="line">INFO:connect to sql:/users/admin/home/go/src/io/rivers/demoProject/main.go:45:io.rivers.demoProject.testFunction</span><br></pre></td></tr></table></figure><p>这样子在打印出日志等级，日志消息的同时，输出业务逻辑所在的文件，行数，函数，对后期的bug排查，性能分析都有很大的帮助</p><p>那么，如何在golang中实现这一功能呢？</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>golang的runtime包提供了与之相应的函数接口，主要是<code>runtime.Caller</code>和<code>runtime.FuncForPC</code></p><p>先看一下二者的函数签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Caller</span><span class="params">(skip <span class="keyword">int</span>)</span> <span class="params">(pc <span class="keyword">uintptr</span>, file <span class="keyword">string</span>, line <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FuncForPC</span><span class="params">(pc <span class="keyword">uintptr</span>)</span> *<span class="title">Func</span></span></span><br></pre></td></tr></table></figure><p>单看函数签名就比较容易了解到:</p><ul><li><code>runtime.Caller</code>能够返回在函数栈中的PC(指令寄存器，可以认为存储了当前执行到了哪里)，所在的文件，所在文件的具体哪一行</li><li><code>runtime.FuncForPC</code>能够根据给定的指令寄存器给出其所在的行数</li></ul><p>其中<code>runtime.FuncForPC</code>的参数比较容易理解，就是指指令寄存器，但是<code>runtime.Caller</code>的参数需要解释一下</p><p>这里的<code>skip</code>指的是跳过多少个函数栈：</p><ul><li><code>skip == 0</code>，不跳过函数栈，返回当前函数PC，文件名，所在行</li><li><code>skip == 1</code>，跳过当前函数栈，返回上层调用者<strong>调用当前函数时的PC</strong>，文件名，所在行</li><li><code>skip == 2</code>，以此类推</li></ul><p>一般情况下这两个函数都是连在一起使用，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取上层调用者PC，文件名，所在行</span></span><br><span class="line">pc, codePath, codeLine, ok := runtime.Caller(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> !ok&#123;</span><br><span class="line">    <span class="comment">// 不ok，函数栈用尽了</span></span><br><span class="line">    code = <span class="string">"-"</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> = "-"</span></span><br><span class="line"><span class="function">&#125; <span class="title">else</span></span> &#123;</span><br><span class="line">    <span class="comment">// 拼接文件名与所在行</span></span><br><span class="line">    code = fmt.Sprintf(<span class="string">"%s:%d"</span>, codePath, codeLine)</span><br><span class="line">    <span class="comment">// 根据PC获取函数名</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> = <span class="title">runtime</span>.<span class="title">FuncForPC</span><span class="params">(pc)</span>.<span class="title">Name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="实现重点与自动获取的优化"><a href="#实现重点与自动获取的优化" class="headerlink" title="实现重点与自动获取的优化"></a>实现重点与自动获取的优化</h2><p>可以看到，在我们使用<code>runtime.Caller</code>和<code>runtime.FuncForPC</code>这一组合击的时候，实际上的输入参数只有一个，那就是<code>runtime.Caller</code>的<code>skip</code>。</p><p>如何确定<code>skip</code>呢？在实践中，我一般使用两种方式：</p><ol><li>写死</li><li>尝试自动获取</li></ol><p>听起来第二种方法要比第一种方法好，但是事实上并不是这样的，在看完实现之后，大家就会明白了</p><h3 id="将skip写死"><a href="#将skip写死" class="headerlink" title="将skip写死"></a>将<code>skip</code>写死</h3><p>这种方式是比较常见的，通常适用于设计时确定了调用层数的情况，以日志系统为例，我们现在要提供一个接口<code>log</code>，那么我知道外界肯定是要直接调用<code>log</code>的，我最终要打印的就是调用<code>log</code>的函数的文件名，所在行，函数名</p><p>那么如果我是在<code>log</code>里使用<code>runtime.Caller</code>，那么我的<code>skip</code>就应该是<code>1</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(logLevel <span class="keyword">int</span>, logMessage <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    pc, file, line, ok := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我还做了封装，那么就要根据编写代码时的封装层数调整<code>skip</code>，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(logLevel <span class="keyword">int</span>, logMessage <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    logHelper(logLevel, logMessage)</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logHelper</span><span class="params">(logLevel <span class="keyword">int</span>, logMessage <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    logReal(logLevel, logMessage)</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logReal</span><span class="params">(logLevel <span class="keyword">int</span>, logMessage <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    pc, file, line, ok := runtime.Caller(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例中，由于多了两层封装，所以要把<code>skip</code>更改为3</p><h3 id="尝试自动获取"><a href="#尝试自动获取" class="headerlink" title="尝试自动获取"></a>尝试自动获取</h3><p>这次的尝试自动获取是我在编写日志系统时遇到的一个比较特殊的情况</p><p>在上面说的<a href="#将skip写死">#将skip写死</a>中，其实我们有一个重要的前提，那就是</p><blockquote><p>业务函数<strong>全部</strong>直接调用日志接口<code>log</code></p></blockquote><p>但是这次在开发日志系统时，遇到了这样的场景:</p><blockquote><p>日志拥有接口<code>log1</code>和<code>log2</code>，<code>log2</code>调用<code>log1</code>，业务代码既可能调用<code>log2</code>，也可能直接调用<code>log1</code><br><code>log1</code>下层调用<code>runtime.Caller</code>和<code>runtime.FuncForPC</code>组合</p></blockquote><p>这种情况下，<code>skip</code>是不可能写死在源代码里的，于是采取的解决方案如下</p><blockquote><p>由于日志系统在一个独立的包里，所以在<code>FuncForPC</code>将函数名取出来以后，判断是否是日志包中的函数，如果是，就增加<code>skip</code>的值</p></blockquote><p>实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> skip := <span class="number">1</span>; <span class="literal">true</span>; skip++ &#123;</span><br><span class="line">    pc, codePath, codeLine, ok := runtime.Caller(skip)</span><br><span class="line">    <span class="keyword">if</span> !ok&#123;</span><br><span class="line">        <span class="comment">// 不ok，函数栈用尽了</span></span><br><span class="line">        auto.Code = prevCode</span><br><span class="line">        auto.Func = prevFunc</span><br><span class="line">        <span class="keyword">return</span> auto</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        prevCode = fmt.Sprintf(<span class="string">"%s:%d"</span>, codePath, codeLine)</span><br><span class="line">        prevFunc = runtime.FuncForPC(pc).Name()</span><br><span class="line">        auto.Code = prevCode</span><br><span class="line">        auto.Func = prevFunc</span><br><span class="line">        <span class="keyword">if</span> !strings.Contains(prevFunc, <span class="string">"&lt;package_name&gt;"</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到包外的函数了</span></span><br><span class="line">            <span class="keyword">return</span> auto</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就算是一个能够解决问题的方案了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章介绍了作者在参与一个golang日志系统的开发的时候，解决需要打印出执行&lt;strong&gt;日志打印操作&lt;/strong&gt;时的&lt;strong&gt;业务函数名，业务文件名与所在行数&lt;/strong&gt;的需求过程中，遇到的问题和解决方案&lt;/p&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Vue+Axios自动更新</title>
    <link href="https://rivers-shall.github.io/2020/05/25/Vue-Axios%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"/>
    <id>https://rivers-shall.github.io/2020/05/25/Vue-Axios自动更新/</id>
    <published>2020-05-25T14:29:58.000Z</published>
    <updated>2020-06-01T10:43:06.047Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章记录了作者在使用Vue+Axios实现前端自动刷新数据时，遇到的一个坑点。</p><a id="more"></a><h2 id="场景需求"><a href="#场景需求" class="headerlink" title="场景需求"></a>场景需求</h2><p>在一个Vue单页应用中，使用VueRouter实现了App组件中点击链接后呈现Component组件的功能</p><p>App.Vue -&gt; Component.Vue</p><p>现在需要：在Component加载出来之后，每间隔1s的时间，自动通过Axios向后端接口获取数据并更新。</p><h2 id="有问题的实现方式"><a href="#有问题的实现方式" class="headerlink" title="有问题的实现方式"></a>有问题的实现方式</h2><p>App.Vue，内置router-link，可以跳转呈现Component</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// App.Vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;router-link :to=&quot;/Component&quot;&gt;Component&lt;/router-link&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>Component.Vue，在创建时，使用<code>setInterval</code>创建1s中的循环动作，在动作中使用Axios获取后端数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Component.Vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        // 设置一个间隔1s就进行的动作</span><br><span class="line">        setInterval(() =&gt; &#123;</span><br><span class="line">            Axios.get(&quot;/data&quot;).then((res) =&gt; &#123;</span><br><span class="line">                // 业务逻辑</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>出现问题的原因在于：</p><p><strong>只有<code>setInterval</code>，没有<code>clearInterval</code></strong></p><p>一个循环任务一旦被创建，就没有被销毁的可能，但是每次用户点击<code>Component</code>链接，都会创建<code>Component</code>实例，产生循环任务。</p><p>如果用户多次点击了<code>App.Vue</code>中的<code>Component</code>链接，那么就会在前端浏览器里产生多个循环任务，不断发送请求，最终导致前后端都不堪重负。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过<code>data</code>记录<code>created</code>中产生的循环任务，并在<code>beforeDestroy</code>里加入<code>clearInterval</code>清除它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Component.Vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            timer : &#123;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        // 设置一个间隔1s就进行的动作</span><br><span class="line">        this.timer = setInterval(() =&gt; &#123;</span><br><span class="line">            Axios.get(&quot;/data&quot;).then((res) =&gt; &#123;</span><br><span class="line">                // 业务逻辑</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy() &#123;</span><br><span class="line">        clearInterval(this.timer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章记录了作者在使用Vue+Axios实现前端自动刷新数据时，遇到的一个坑点。&lt;/p&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Vue" scheme="https://rivers-shall.github.io/tags/Vue/"/>
    
      <category term="Axios" scheme="https://rivers-shall.github.io/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>golang中使用elasticsearch</title>
    <link href="https://rivers-shall.github.io/2020/05/24/golang%E4%B8%AD%E4%BD%BF%E7%94%A8elasticsearch/"/>
    <id>https://rivers-shall.github.io/2020/05/24/golang中使用elasticsearch/</id>
    <published>2020-05-24T13:47:20.000Z</published>
    <updated>2020-06-01T10:42:50.444Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇介绍如何利用golang第三方库<a href="https://github.com/olivere/elastic" target="_blank" rel="noopener">https://github.com/olivere/elastic</a>进行elasticsearch的操作的文章。<br>文章中并不会介绍非常详细的API，更侧重于作者在工作中的使用经验和查文档经验。文章中主要包括以下内容：</p><ol><li>作者认为比较重要的API设计理念以及文档查阅方式</li><li>作者在工作中使用到的elasticsearch的实例，包括从接到需求，查阅文档，并实现的过程</li></ol><a id="more"></a><h2 id="API设计理念思考"><a href="#API设计理念思考" class="headerlink" title="API设计理念思考"></a>API设计理念思考</h2><h3 id="API的分类"><a href="#API的分类" class="headerlink" title="API的分类"></a>API的分类</h3><p>在使用elasticsearch的golang Client过程中，我觉得可以将olivere/elastic的常用API分作三类：</p><ol><li>面向elasticsearch的metadata的Service</li><li>面向elasticsearch的data的Service</li><li>面向Query</li></ol><p>而这三类分别对应了对elasticsearch的不同类别的操作：</p><ol><li>面向elasticsearch的metadata的Service，主要是对elasticsearch的metadata进行查询和操作，比如<ul><li>配置elasticsearch</li><li>查询elasticsearch的状态，比如集群状态，节点数目等</li></ul></li><li>面向elasticsearch的data的Service，住哟是对elasticsearch内的数据和数据格式进行操作<ol><li>elasticsearch中的index的metadata进行操作，比如<ol><li>查询是否存在某个index</li><li>创建并配置index</li></ol></li><li>elasticsearch中的index下的document的增删改操作</li></ol></li><li>面向Query，主要是对index下的document的查询操作</li></ol><h3 id="分类在代码中的体现"><a href="#分类在代码中的体现" class="headerlink" title="分类在代码中的体现"></a>分类在代码中的体现</h3><p>首先需要说明，在olivere/elastic的所有操作都是依靠生成一个<code>XXXService</code>对象然后<code>XXXService.Do(ctx)</code>来实现的，这里将他们分成面向Service和面向Query只是表示后者我们的主要精力都会集中在构造Query上</p><h4 id="面向elasticsearch的metadata的Service"><a href="#面向elasticsearch的metadata的Service" class="headerlink" title="面向elasticsearch的metadata的Service"></a>面向elasticsearch的metadata的Service</h4><p>面向elasticsearch的metadata的Service，一般是通过建立连接的ESClient，新建出查询或者操作所需的Service，而后进行操作的模式</p><p>比如如下，查询集群内es节点数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立连接的Client</span></span><br><span class="line">esClient, _ := elastic.NewClient()</span><br><span class="line"><span class="comment">// 新建出用于操作的Service</span></span><br><span class="line">clusterHealthClient := elastic.NewClusterHealthService(esClient)</span><br><span class="line"><span class="comment">// 查询，拿到结果</span></span><br><span class="line">result, _:= clusterHealthClient.Do(context.Background())</span><br><span class="line">fmt.Println(result.NumberOfNodes)</span><br></pre></td></tr></table></figure><h4 id="面向elasticsearch的data的Service"><a href="#面向elasticsearch的data的Service" class="headerlink" title="面向elasticsearch的data的Service"></a>面向elasticsearch的data的Service</h4><p>面向elasticsearch的data的Service，一般是通过建立连接的ESClient的成员函数直接取得Service，而后进行操作</p><p>比如如下，新建索引</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new index.</span></span><br><span class="line">mapping := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">    "settings":&#123;</span></span><br><span class="line"><span class="string">        "number_of_shards":1,</span></span><br><span class="line"><span class="string">        "number_of_replicas":0</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "mappings":&#123;</span></span><br><span class="line"><span class="string">        "properties":&#123;</span></span><br><span class="line"><span class="string">            "tags":&#123;</span></span><br><span class="line"><span class="string">                "type":"keyword"</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            "location":&#123;</span></span><br><span class="line"><span class="string">                "type":"geo_point"</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            "suggest_field":&#123;</span></span><br><span class="line"><span class="string">                "type":"completion"</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">ctx := context.Background()</span><br><span class="line">createIndex, _ := esClient.CreateIndex(<span class="string">"twitter"</span>).BodyString(mapping).Do(ctx)</span><br><span class="line">fmt.Println(createIndex.Index)</span><br></pre></td></tr></table></figure><h4 id="面向Query"><a href="#面向Query" class="headerlink" title="面向Query"></a>面向Query</h4><p>面向Query，一般是先新建出Query，而后通过<code>client.Search().Index(index).Query(query).Do(ctx)</code>的方式执行查询操作</p><p>比如如下，查询上一个构造的索引中，<code>tags</code>字段含有<code>test</code>的document</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query := elastic.NewBoolQuery()</span><br><span class="line">query = query.Must(elastic.NewTermQuery(<span class="string">"tags"</span>, <span class="string">"test"</span>))</span><br><span class="line">result, _ := esClient.Search().Index(<span class="string">"twitter"</span>).Query(query).Do(context.Background())</span><br></pre></td></tr></table></figure><h2 id="API文档的查询方法"><a href="#API文档的查询方法" class="headerlink" title="API文档的查询方法"></a>API文档的查询方法</h2><p>查询olivere/elastic的文档，主要有三个来源：</p><ol><li>项目Wiki <a href="https://github.com/olivere/elastic/wiki" target="_blank" rel="noopener">https://github.com/olivere/elastic/wiki</a></li><li>源代码 <a href="https://github.com/olivere/elastic" target="_blank" rel="noopener">https://github.com/olivere/elastic</a></li><li>elasticsearch官方文档 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></li></ol><p>这三者各有特点：</p><ol><li>项目Wiki<ul><li>优点：简单直接，并且会给出相应的操作的示例代码，上手很快</li><li>缺点：示例较简单，且不全面，面对复杂逻辑/特定逻辑很可能缺乏指导性，或者找不到相关文档</li></ul></li><li>源代码<ul><li>优点：全面而且本质的东西，掌握了源代码就掌握了一切</li><li>缺点：复杂，费力，考虑投入产出比，几乎绝无必要源码级掌握(除非想成为库的开发者)</li></ul></li><li>elasticsearch官方文档<ul><li>优点：比较齐全的同时仍然是可读性较高的文档，难度在项目Wiki和源代码之间</li><li>缺点：没有直接对应到olivere/elastic的API上，找到elasticsearch的API之后，要回头再找olivere/elastic的API</li></ul></li></ol><p>一般的查询方式如下：</p><ol><li>首先明确需求，即到底需要获得elasticsearch的什么信息或者对其进行什么操作</li><li>明确需求后先查阅Wiki，如果有相应的条目，可用的就可以直接用了</li><li>Wiki中找不到，那就按照<a href="#api设计理念思考">api设计理念思考</a>中描述的进行分类</li><li>分类后有两条路径<ol><li>源代码中寻找对应的Service或者Query接口，找到后去elasticsearch文档验证</li><li>elasticsearch文档中寻找对应的查询接口，找到后去olivere/elastic中找对应的接口</li></ol></li></ol><p>当然，合理利用其他资源作为文档入口也是有必要的(或许这才是很多人的首选)：</p><ol><li>Stack Overflow，启动！</li><li>输入关键字查询，能找到合适的问答，就直接采用，不能就返回上述的一般查询方式</li></ol><h2 id="使用实例与解决过程"><a href="#使用实例与解决过程" class="headerlink" title="使用实例与解决过程"></a>使用实例与解决过程</h2><h3 id="查询集群的健康状态"><a href="#查询集群的健康状态" class="headerlink" title="查询集群的健康状态"></a>查询集群的健康状态</h3><p>过程：</p><ol><li>查阅Wiki，没有</li><li>查阅源代码，cluster为关键字查找，找到cluster_health.go，前往注释中指定的elasticsearch文档<a href="http://www.elastic.co/guide/en/elasticsearch/reference/7.0/cluster-health.html" target="_blank" rel="noopener">http://www.elastic.co/guide/en/elasticsearch/reference/7.0/cluster-health.html</a>验证想法</li><li>想法验证成功，编程</li></ol><h3 id="实现text类型的字段的模糊查找"><a href="#实现text类型的字段的模糊查找" class="headerlink" title="实现text类型的字段的模糊查找"></a>实现text类型的字段的模糊查找</h3><p>过程：</p><ol><li>查找Wiki，没有</li><li>源代码，elasticsearch文档没有“模糊查找”相关的部分</li><li>stack overflow 搜索 match part of text，找到使用正则表达式查询RegexQuery的方法</li><li>返回elasticsearch文档验证，验证成功</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇介绍如何利用golang第三方库&lt;a href=&quot;https://github.com/olivere/elastic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/olivere/elastic&lt;/a&gt;进行elasticsearch的操作的文章。&lt;br&gt;文章中并不会介绍非常详细的API，更侧重于作者在工作中的使用经验和查文档经验。文章中主要包括以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作者认为比较重要的API设计理念以及文档查阅方式&lt;/li&gt;
&lt;li&gt;作者在工作中使用到的elasticsearch的实例，包括从接到需求，查阅文档，并实现的过程&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="elasticsearch" scheme="https://rivers-shall.github.io/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>看不清的答案</title>
    <link href="https://rivers-shall.github.io/2020/03/10/%E7%9C%8B%E4%B8%8D%E6%B8%85%E7%9A%84%E7%AD%94%E6%A1%88/"/>
    <id>https://rivers-shall.github.io/2020/03/10/看不清的答案/</id>
    <published>2020-03-10T11:41:47.000Z</published>
    <updated>2020-05-28T06:56:19.816Z</updated>
    
    <content type="html"><![CDATA[<p>莫非你在故作冷傲？<br>为何心为你如此牵动<br>从来如此 不知不觉<br>我一直在追寻你</p><p>要怎样才能将你<br>镌刻在事实的巨岩上</p><p>当我第一次绞尽脑汁<br>当你第一次映在心间<br>你的内容 竟如此模糊<br>让我茫然四顾 徘徊踌躇</p><p>要怎样才能将你<br>从梦的迷雾中取出</p><p>即使是一份终成过往的答案<br>是否也有镌刻在事实上的一天<br>在能够看见隐约的曙光之前<br>这份答案 依旧如雾中花 水中月</p><hr><p>我究竟喜爱着什么，痛恨着什么，努力追寻着什么，回忆的过往仿佛空无一物，展望的未来确实迷雾一片，我到底，该怎么办呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;莫非你在故作冷傲？&lt;br&gt;为何心为你如此牵动&lt;br&gt;从来如此 不知不觉&lt;br&gt;我一直在追寻你&lt;/p&gt;
&lt;p&gt;要怎样才能将你&lt;br&gt;镌刻在事实的巨岩上&lt;/p&gt;
&lt;p&gt;当我第一次绞尽脑汁&lt;br&gt;当你第一次映在心间&lt;br&gt;你的内容 竟如此模糊&lt;br&gt;让我茫然四顾 徘徊踌躇&lt;/p&gt;
      
    
    </summary>
    
      <category term="程序人生" scheme="https://rivers-shall.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络复习-第五章</title>
    <link href="https://rivers-shall.github.io/2019/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <id>https://rivers-shall.github.io/2019/12/31/计算机网络复习-第五章/</id>
    <published>2019-12-31T12:00:00.000Z</published>
    <updated>2020-05-28T06:56:19.816Z</updated>
    
    <content type="html"><![CDATA[<p>《Computer Networking - A Top-Down Approach》第五章复习知识点总结</p><a id="more"></a><p>第五章主要介绍如何配置和管理网络，以及这其中使用到的各种协议如OSPF，BFP，ICMP，SNMP</p><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><p>转发和路由之间的桥梁就是转发表：</p><ul><li>转发功能使用转发表进行包的转发</li><li>路由功能配置，更新，维护转发表以便转发使用</li></ul><p>而路由功能可以通过两种方式来实现：</p><ol><li>分布式的各路由器处理(Per-router control)<ol><li>每个路由器上都有一个路由处理单元，他们通过和邻居路由器的路由处理单元的通信，计算出路由表</li></ol></li><li>集中式的中央处理(Logically centralized control)<ol><li>存在一个中央处理单元负责计算所有的路由器上的路由表并将其分发到各个路由器上</li><li>每个路由器上又一个Control Agent负责接收中央处理单元的命令，更新路由表</li></ol></li></ol><h2 id="5-2-路由算法"><a href="#5-2-路由算法" class="headerlink" title="5.2 路由算法"></a>5.2 路由算法</h2><p>对于一个网络，可以将其抽象为一个图，路由器和链路分别对应图中的节点和边。</p><p>路由算法的任务，就是找出图上点对之间的最小距离及最小距离对应的路径。</p><p>路由算法的分类：</p><ul><li>中心化的或去中心化的<ul><li>中心化的路由算法是基于对整个网络有着完整的认识基础上进行最短路径计算的<ul><li>中心化路由算法可以由中央处理单元进行，也可以在每个路由器上分别进行</li><li>这需要在计算路由之前首先获得整个网络的链路信息</li><li>中心化路由算法又被称为LS(link-state)算法</li></ul></li><li>去中心化的路由算法是仅基于各个路由器知道邻居路由器之间的链路和链路代价进行最短路径计算的<ul><li>去中心化的路由算法是分布式的，分散在各个路由器上进行计算</li><li>去中心化的路由算法又被称为DV(distance-vector)算法</li></ul></li></ul></li><li>动态路由算法或静态路由算法<ul><li>动态路由算法改变比较迅速，随着链路负载和网络拓扑结构的改变而改变路径</li><li>静态路由算法相对来说改变比较少，一般需要认为改变链路代价才会改变路径</li></ul></li><li>负载敏感或负载不敏感<ul><li>负载敏感的路由算法随着链路拥塞情况的改变会改变路径</li><li>负载不敏感的路由算法于链路拥塞情况无关</li><li>负载敏感的路由算法实现起来困难重重，现实中使用的都是负载不敏感的算法</li></ul></li></ul><h3 id="5-2-1-LS-Link-State-算法"><a href="#5-2-1-LS-Link-State-算法" class="headerlink" title="5.2.1 LS(Link-State) 算法"></a>5.2.1 LS(Link-State) 算法</h3><p>LS算法需要提前知道网络中的链路结构和链路代价，一般来讲，这是通过各个路由节点广播自身周围的链路与链路代价完成的。</p><p>而后所有的节点都会对整个网络有了了解，每个节点都可以运行LS算法，计算最短路径。</p><p>Dijkstra‘s Algorithm是一个常用于LS算法的图论最短路算法。在运行了Dijkstra‘s Algorithm后，路由器上就只需要存储&lt;目的地，下一跳链路&gt;对就可以了。</p><p>但是如果希望满足负载敏感的话，就会出现路由震荡的情况，解决的办法是让路由器在不同的时间点上进行路径计算，但是因特网路由器被发现是自同步的，也就是说即便一开始设置了不同的时间点，后来也会变成同一时间点计算，最后的办法就是随机时间发送路由控制包。</p><h3 id="5-2-2-DV-Distance-Vector-算法"><a href="#5-2-2-DV-Distance-Vector-算法" class="headerlink" title="5.2.2 DV(Distance-Vector) 算法"></a>5.2.2 DV(Distance-Vector) 算法</h3><p>在DV算法中，每个路由器接收来自邻居路由器的消息，计算路径，而后将结果再交给邻居路由器。常此往复，知道没有消息传递为止。</p><ul><li>DV算法是去中心化的算法，不需要知道所有链路结构和代价</li><li>DV算法是异步算法，不需要同步，只需要接受消息并计算</li><li>DV算法是自终止算法，不需要特定的消息提醒终止，当链路上没有消息传递时，自动终止</li></ul><p>Bellman-Ford等式是DV算法的重要基础：</p><p>$d(x,y)=\min_v{c(x,v) + d(v, y)}$</p><p>其中$v$是$x$的邻居，$d(x,y)$代表$x,y$之间的最短路径，$c(x,v)$代表$x,v$之间的路径代价。</p><p>这个等式对于$x$的取值揭示了从$x$到$y$所需要的下一跳目标$v$。而且所需要用到的信息只有$x$本身和邻居的信息。</p><p>所以路由器x上存储了：</p><ul><li>x到周围邻居的链路代价</li><li>x的距离矢量，也即x到所有节点的最小路径长度</li><li>x的邻居的距离矢量</li></ul><p>在DV算法中，每个路由器会将自己的距离矢量发送给邻居，邻居接收到后根据Bellman-Ford等式修改自己的距离矢量，如果修改成功，就将更新后的自己的距离矢量发送给邻居，最终距离矢量收敛到真正的最小距离。</p><h4 id="count-to-infinity问题和poisoned-reverse"><a href="#count-to-infinity问题和poisoned-reverse" class="headerlink" title="count-to-infinity问题和poisoned reverse"></a>count-to-infinity问题和poisoned reverse</h4><p>count-to-infinity 是指由于链路代价的变化，使得某个节点x选择前往y的最短路下一跳时选择了z，但同时z前往y的最短路下一跳是x。这时在转发表中就形成了一个环。</p><p>解决这个问题的办法是，如果z前往y的最短路下一跳是x，那么在向x发送距离矢量的时候，告知z前往y的代价是无穷大，避免x选择前往y的下一跳时选择z，这就是poisoned reverse。</p><p>但是poisoned reverse也不能完全解决count-to-infinity问题。</p><h4 id="LS-和-DV-算法比较"><a href="#LS-和-DV-算法比较" class="headerlink" title="LS 和 DV 算法比较"></a>LS 和 DV 算法比较</h4><p>从消息复杂度，时间复杂度和鲁棒性来看，两个算法都不相上下。</p><p>其中LS需要$O(|V||E|)$的消息复杂度，$O(n^2)$的时间复杂度，由于计算是每个路由器独立计算，提供了一定的鲁棒性，但是一个路由器的错误消息也会被传递到所有路由器上进行计算。</p><p>DV的消息复杂度和时间复杂度都很难确定，鲁棒性上来看，一个错误的距离矢量也可能被传播到许多路由器上。</p><h2 id="5-3-intra-AS-Routing-in-the-Internet-OSPF"><a href="#5-3-intra-AS-Routing-in-the-Internet-OSPF" class="headerlink" title="5.3 intra-AS Routing in the Internet: OSPF"></a>5.3 intra-AS Routing in the Internet: OSPF</h2><p>在之前的讨论中，我们一直对路由网络做了简化，其中只有路由器和链路，但事实上，我们忽略了以下两个重要因素：</p><ul><li>规模。大规模的网络不可以向上述讨论一样简单使用普通的路由协议。因为即便只是存储下一跳的目标，都需要极大的内存。</li><li>管理自治。不同的网络一般需要进行独立的管理，但是将所有的路由器纳入一个路由协议下，显然不能满足这个需求。</li></ul><p>于是自治系统应运而生，也就是说，一个自治系统内，使用统一的路由协议进行管理，对外暴露网关进行通信，这样既能够通过控制自治系统的大小来控制路由协议作用的规模，也能实现自治系统内部的管理自治。</p><h3 id="OSPF-Open-Shortest-Path-First"><a href="#OSPF-Open-Shortest-Path-First" class="headerlink" title="OSPF(Open Shortest Path First)"></a>OSPF(Open Shortest Path First)</h3><p>OSPF协议就是自治系统内部的路由协议。Open的意思是开源的，他的各种细则声明都可以在网上查到。</p><p>OSPF是一个LS算法的协议。所有的路由器首先以广播洪泛的方式将整个网络的链路结构和链路代价存储下来，而后使用Dijkstra‘s Algorithm进行最短路径和下一跳的计算。</p><p>同时OSPF并不涉及链路代价的配置，这个配置是有人为决定的。</p><p>所有的OSPF消息都由IP包携带，通过将IP包头中的上层协议域设置为89表明这是OSPF消息包。</p><p>OSPF支持以下的特性：</p><ul><li>安全。OSPF消息可以进行验证，验证方式有两种 — 简单验证和MD5验证。<ul><li>简单验证<ul><li>每个路由器上存放有明文密码</li><li>传输消息时将明文密码放在消息里。</li></ul></li><li>MD5验证<ul><li>每个路由器上存放有MD5密钥</li><li>传输消息时将消息内容和MD5密钥结合算法产出一段哈希值，放在内容后面</li><li>收到消息的路由器使用密钥再度哈希内容并和传来的哈希值比较，如果一致，验证就通过。</li><li>MD5验证时还会有序列号，防备replay攻击。</li></ul></li></ul></li><li>多个同代价的路径。<ul><li>在选择最短路径时，可能会有多条路径，OSPF并不要求一定要选择一条，可以多条一起使用，降低负载压力。</li></ul></li><li>单播和多播的整合支持</li><li>自治系统内部的再度结构化<ul><li>自治系统内部可以在被分成不同的区域</li><li>有一个特殊区域为backbone area</li><li>一个区域内部自由通信</li><li>一个区域边界会有一个border router，用于和别的区域通信</li><li>不同区域通信需要先经过border router，进入backbone area，再从border router出去到目标区域的border router，再进入区域，到达终点</li></ul></li></ul><h2 id="5-4-Routing-Around-the-ISPs-BGP"><a href="#5-4-Routing-Around-the-ISPs-BGP" class="headerlink" title="5.4 Routing Around the ISPs: BGP"></a>5.4 Routing Around the ISPs: BGP</h2><p>当我们需要在不同的自治系统之间进行通信时，OSPF就不能满足我们的需要了，同时，在不同的自治系统之间进行通信必须使用统一的协议，而实际上在因特网里就是全部使用的边际网关协议(Border Gateway Protocol)进行自治系统之间的通信。</p><p>对于一个自治系统内的主机，我们是使用IP地址进行的定位，但是对于一整个自治系统，我们是使用IP地址前缀进行定位。</p><h3 id="5-4-1-The-Role-of-BGP"><a href="#5-4-1-The-Role-of-BGP" class="headerlink" title="5.4.1 The Role of BGP"></a>5.4.1 The Role of BGP</h3><p>对于一个自治系统间的通信协议，BGP需要提供一下两个基本的功能：</p><ol><li>获取可到达的子网前缀。对于一个自治系统，他需要知道自己能够和哪些自治系统通信，以及这些自治系统的IP地址前缀是什么。</li><li>获取自治系统间的最好路径。</li></ol><p>这两个功能是通过在路由器中存储&lt;子网前缀，输出端口&gt;的表来实现的</p><h3 id="5-4-2-Advertising-BGP-Route-Information"><a href="#5-4-2-Advertising-BGP-Route-Information" class="headerlink" title="5.4.2 Advertising BGP Route Information"></a>5.4.2 Advertising BGP Route Information</h3><p>BGP协议是通过TCP连接来获取路由信息的：</p><ul><li>不同自治系统之间的BGP连接称为eBGP连接</li><li>自治系统内部的BGP连接称为iBGP连接</li></ul><p>注：BGP连接是逻辑连接，BGP连接的两端之间可能有多条链路</p><p>想要告知其他自治系统关于子网前缀的信息，就必须使用BGP消息：</p><ol><li>源节点首先发出BGP消息</li><li>在路径上的自治系统网关通过eBGP连接收到消息</li><li>网关通过iBGP将消息广播到自治系统内的所有节点</li><li>网关继续通过eBGP将消息传递到其他的自治系统</li></ol><h3 id="5-4-3-Determining-the-Best-Routes"><a href="#5-4-3-Determining-the-Best-Routes" class="headerlink" title="5.4.3 Determining the Best Routes"></a>5.4.3 Determining the Best Routes</h3><p>当一个子网前缀通过BGP消息在自治系统间进行传输时，还会带上额外的属性：</p><ul><li>AS-PATH，记录传播这个消息所经过的自治系统路径，同时可以作为环路检测–如果一个自治系统发现AS-PATH上有自己的名称，就说明出现环路，可以直接丢弃BGP消息</li><li>NEXT-HOP，AS-PATH的起始节点的IP地址</li></ul><p>这两个属性是众多属性中对于选路最重要的两个属性。</p><p>也就是说，我们现在有的是多个(子网前缀，AS-PATH，NEXT-HOP)元组，这被称为一条路径，BGP需要决定最优路径</p><h4 id="烫手山芋路由-Hot-Potato-Routing"><a href="#烫手山芋路由-Hot-Potato-Routing" class="headerlink" title="烫手山芋路由 (Hot Potato Routing)"></a>烫手山芋路由 (Hot Potato Routing)</h4><p>烫手山芋路由的主要原则是：</p><blockquote><p>尽量使得包在本自治系统内的时间短</p></blockquote><p>所以烫手山芋路由采用的策略是：</p><blockquote><p>选取从当前节点到NEXT-HOP最短的路径</p></blockquote><p>我们可以看到，在这个过程中，起作用的最主要不是BGP，而是自治系统内部的路由协议(比如OSPF)，因为从当前自治系统的网关到达NEXT-HOP只有一条链路(这就是NEXT-HOP的定义)，剩余的代价是由当前节点到网关的代价决定的。</p><h4 id="Route-Selection-Algorithm"><a href="#Route-Selection-Algorithm" class="headerlink" title="Route Selection Algorithm"></a>Route Selection Algorithm</h4><p>实际上，BGP使用更加复杂的策略进行选路：</p><ol><li>每条路径有一个本地偏好，选择本地偏好最优的。本地偏好由路由器自己设置或者由邻居路由学习而来，但是产生本地偏好的策略是由路由管理者人为设置的。</li><li>在剩余的路径中，选择AS-PATH最短的。</li><li>在剩余的路径中，采用烫手山芋路由策略。</li><li>如果还有多条路径，使用BGP identifier选路</li></ol><h3 id="5-4-4-IP任播"><a href="#5-4-4-IP任播" class="headerlink" title="5.4.4 IP任播"></a>5.4.4 IP任播</h3><p>IP任播的意思是给出一组服务器，向其播送IP包，但是最终只能有一个服务器收到IP包。</p><p>IP任播可以用于DNS服务，因为所有的DNS服务最终返回的结果都是一样的(域名对应的IP地址)，但是需要选择一个最近的DNS服务器以便更快地获得结果。也就是要对一组DNS服务器发送请求，但是最终只需要一个DNS服务器回复就可以。</p><p>使用BGP实现IP任播的原理是：</p><ol><li>给所有服务器赋予相同的IP地址(虽然说不同的主机需要唯一IP地址，但是由于这里的服务器提供的服务是一摸一样的，所以这么做没问题)</li><li>当使用BGP进行路由注册时，BGP自动使用选路策略完成了到当前最近的服务器的选路</li><li>接下来向该IP地址发送包，就已经是最近的服务器了</li></ol><h3 id="5-4-5-Routing-Policy"><a href="#5-4-5-Routing-Policy" class="headerlink" title="5.4.5 Routing Policy"></a>5.4.5 Routing Policy</h3><p>对于选路，最终其实还是靠策略来决定选择的路径。</p><p>树上描述了一个情境，比如希望B不要选择通过X发包到C，避免这样的做法就是在策略中是的X不告知B从X可以发到C。</p><h3 id="5-4-6-Putting-the-Pieces-Together-Obtaining-Internet-Presence"><a href="#5-4-6-Putting-the-Pieces-Together-Obtaining-Internet-Presence" class="headerlink" title="5.4.6 Putting the Pieces Together: Obtaining Internet Presence"></a>5.4.6 Putting the Pieces Together: Obtaining Internet Presence</h3><p>假设你开了一家公司，架设了几台服务器，那么，想要全世界访问你的网站，需要如下操作：</p><ol><li>获得物理连接，接到一个ISP上</li><li>获得IP地址分配，在这一步，获得了子网的IP地址前缀，并且通过BGP注册到了各个路由器上</li><li>将具体的IP地址分配给每一台主机</li><li>购买域名，提供你的DNS服务器IP地址，顶层域名上会注册你的域名和DNS服务器地址</li><li>用户访问，首先通过顶级域名DNS服务器获得你的DNS服务器地址，通过你的DNS服务器获得你的其他服务器地址，而后建立TCP连接</li></ol><h2 id="5-6-ICMP-Internet-Control-Message-Protocol"><a href="#5-6-ICMP-Internet-Control-Message-Protocol" class="headerlink" title="5.6 ICMP(Internet Control Message Protocol)"></a>5.6 ICMP(Internet Control Message Protocol)</h2><p>ICMP在结构上是传输层协议，ICMP消息通过IP包的负载传递。</p><p>但是在作用上，ICMP是用于传递IP协议的信息的，尤其是报错信息。</p><p>ICMP消息有三个部分，类型，消息码和产生ICMP消息的IP包的前8个字节。</p><p>ping命令原理：ping向目标服务器发送类型8消息码0的ICMP消息，服务器返回类型0消息码0的回应。</p><p>traceroute命令原理：</p><ul><li>traceroute向目标服务器传递UDP消息</li><li>但是将外层的IP协议包头的TTL设置为1，2，3，…一直下去</li><li>每次当TTL到0，IP包被丢弃的时候，路由器都会发送特定的ICMP消息告知traceroute</li><li>最终到达目标时，由于traceroute传出的UDP包端口号是无效的，目标服务器也会发ICMP消息告知traceroute</li><li>此时的ICMP和之前的不同，所以traceroute也停止了UDP包的继续发送</li><li>通过这些消息到达计时，traceroute算出每一跳的时间</li></ul><h2 id="5-7-Network-Management-and-SNMP"><a href="#5-7-Network-Management-and-SNMP" class="headerlink" title="5.7 Network Management and SNMP"></a>5.7 Network Management and SNMP</h2><p>网络管理其实类似于网络配置，使用一定的协议进行通讯并对网络中各个组件的参数进行监控和配置。</p><h3 id="5-7-1-网络管理框架"><a href="#5-7-1-网络管理框架" class="headerlink" title="5.7.1 网络管理框架"></a>5.7.1 网络管理框架</h3><p>网络管理有如下部分组成：</p><ol><li>网络管理服务器，一般有人在服务器上进行操控</li><li>被管理设备，一个软硬都包含的设备，设备上有一个或者多个被管理对象</li><li>每个被管理对象都有一个MIB(Management Information Base)，用于存储对象相关的参数</li><li>每个被管理设备上都有一个管理用户程序，用于和网络管理服务器通信和修改MIB</li><li>网络管理协议</li></ol><h3 id="5-7-2-SNMP-Simple-Network-Manangement-Protocol"><a href="#5-7-2-SNMP-Simple-Network-Manangement-Protocol" class="headerlink" title="5.7.2 SNMP (Simple Network Manangement Protocol)"></a>5.7.2 SNMP (Simple Network Manangement Protocol)</h3><p>一个网络管理协议是用来在网络管理服务器和管理用户程序之间传递消息的，SNMP就是一个网络管理服务器，SNMP消息有如下类型：</p><ol><li>服务器主动联系用户程序，发送消息，用户程序接收消息，采取行动，并返回结果消息</li><li>被管理设备出现意外状况，MIB改变，用户程序主动联系服务器。通知服务其MIB改变</li></ol><p>SNMP的具体消息类型有如下几类：</p><ol><li>Get*Request用于获取被管理设备MIB的信息</li><li>SetRequest用于设置被管理设备的MIB</li><li>InformRequest用于通知别的管理服务器一些接收不到的MIB信息</li><li>Response用于用户程序回复管理服务器</li><li>Trap用于用户程序通知服务器特定的事件发生了</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Computer Networking - A Top-Down Approach》第五章复习知识点总结&lt;/p&gt;
    
    </summary>
    
      <category term="NJU-Class" scheme="https://rivers-shall.github.io/categories/NJU-Class/"/>
    
      <category term="计算机网络" scheme="https://rivers-shall.github.io/categories/NJU-Class/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络复习-第四章</title>
    <link href="https://rivers-shall.github.io/2019/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <id>https://rivers-shall.github.io/2019/12/31/计算机网络复习-第四章/</id>
    <published>2019-12-31T02:11:35.000Z</published>
    <updated>2020-05-28T06:56:19.816Z</updated>
    
    <content type="html"><![CDATA[<p>《Computer Networking - A Top-Down Approach》第四章4.1-4.3复习知识点总结</p><a id="more"></a><p>第四章主要是讲网络层，也就是IP协议。</p><h2 id="4-1-网络层概览"><a href="#4-1-网络层概览" class="headerlink" title="4.1 网络层概览"></a>4.1 网络层概览</h2><h3 id="4-1-1-转发和路由"><a href="#4-1-1-转发和路由" class="headerlink" title="4.1.1 转发和路由"></a>4.1.1 转发和路由</h3><p>转发和路由很相近，但是是两个不同的服务，都由网络层进行支持。</p><ul><li>转发。转发是指，一个IP包到达路由器，路由器决定要将这个包从哪一个接口再度发出去，以便该接口到达目的IP地址。这是一个路由器本地的操作。</li><li>路由。路由是指，在整个网络范围内，决定好从一个源地址到目的地址的路线。这是一个全网的操作，通常耗时更长。</li></ul><p>对于路由器来说，<strong>转发表</strong>是最重要的数据结构。</p><p>转发就是靠从IP包中找出几个域，而后从转发表中索引出目的IP地址对应的发出接口。</p><p>路由则是用来决定转发表中的值的。</p><h3 id="4-1-2-网络层服务模型"><a href="#4-1-2-网络层服务模型" class="headerlink" title="4.1.2 网络层服务模型"></a>4.1.2 网络层服务模型</h3><p>网络层服务模型为：最大努力模型，也就是没有任何保证的模型。</p><h2 id="4-2-路由器里有什么"><a href="#4-2-路由器里有什么" class="headerlink" title="4.2 路由器里有什么"></a>4.2 路由器里有什么</h2><p>路由器里有四个重要的组成部分：</p><ol><li>输入端口。输入端口有如下作用：<ol><li>终止物理连接，使得物理链路上传输的bit流进入路由器</li><li>进行链路层包解析，提取出网络层包</li><li>根据网络层的包结构进行转发，如果是控制消息包，比如路由协议的包，就转发给路由处理器，如果是数据包，就查询转发表并发到对应的输出端口上</li></ol></li><li>输出端口，向外传输数据</li><li>Switching Fabric 连接输入端口和输出端口/路由处理器</li><li>路由处理器，使用相应的路由协议，路由算法，维护转发表，接受路由协议消息或向外发送路由协议消息。</li></ol><p>其中，前三个部分一般以硬件实现(因为软件处理速度跟不上链路上包到达的速度，纳秒级的到达速度)，路由处理器一般由软件实现，对处理速度要求不高，因为路由协议的处理一般是毫秒或秒级的。</p><p>由于需要转发，转发之前就一定要根据到达的IP包中的信息进行处理，决定输出端口，而一般情况下有这两种决定方式：</p><ol><li>基于目的地的转发。通过检查IP包的目的IP地址，决定对应的输出端口。</li><li>一般化转发。一般化转发的思想是检查IP包的任意的信息，而后决定对应的输出端口。当然，对于每个IP包检查的信息是一致的，只不过不局限于目的IP地址而已。</li></ol><h3 id="4-2-1-输入端口处理和基于目的地的转发"><a href="#4-2-1-输入端口处理和基于目的地的转发" class="headerlink" title="4.2.1 输入端口处理和基于目的地的转发"></a>4.2.1 输入端口处理和基于目的地的转发</h3><p>输入端口有如下作用：</p><ol><li>终止物理连接，使得物理链路上传输的bit流进入路由器</li><li>进行链路层包解析，提取出网络层包</li><li>根据网络层的包结构进行转发，如果是控制消息包，比如路由协议的包，就转发给路由处理器，如果是数据包，就查询转发表并发到对应的输出端口上</li></ol><p>而对于基于目的地的转发，查询转发表的方式就是<strong>最长前缀匹配</strong>：</p><blockquote><p>对于一个目的IP地址A，转发表中有许多&lt;字符串,端口号&gt;对，将A与这些字符串进行匹配，匹配时仅仅使用A的前缀进行匹配，在所有匹配的字符串中，寻找最长的字符串，其对应的端口号就是输出端口号。</p></blockquote><h3 id="4-2-2-交换-Switching"><a href="#4-2-2-交换-Switching" class="headerlink" title="4.2.2 交换(Switching)"></a>4.2.2 交换(Switching)</h3><p>交换是指Switching Fabric将来自输入端口的IP包转交给输出端口的过程。</p><p>常见的交换方式有如下几种：</p><ul><li>基于主存的交换<ul><li>输入端口将到达的IP包写入主存，而后再从主存中读到输出端口上完成转发</li></ul></li><li>基于总线的交换<ul><li>输入端口给到达的IP包打上标签，发送到总线上，只有对应标签的输出端口会接受这个IP包</li></ul></li><li>基于交叉网络的交换<ul><li>多个端口对应多个总线的交叉网络</li></ul></li></ul><h3 id="4-2-3-输出端口处理"><a href="#4-2-3-输出端口处理" class="headerlink" title="4.2.3 输出端口处理"></a>4.2.3 输出端口处理</h3><p>输出端口需要取出从输入端口转发来的IP包，进行链路层封装后，转发出去。</p><h3 id="4-2-4-排队情境会在哪里出现"><a href="#4-2-4-排队情境会在哪里出现" class="headerlink" title="4.2.4 排队情境会在哪里出现"></a>4.2.4 排队情境会在哪里出现</h3><p>输入排队：如果Switching Fabric转发的速度比<strong>所有</strong>输入端口的IP包到达的速度要慢的话，就会在输入端口出现排队现象。</p><p>同时，排队时会出现行首阻塞(head of line blocking)的现象，也就是说对于一个输入端口上的队列，如果队首的包被阻塞，那么根据先进先出原则，即便后面的包所对应的输出端口没有被占用，也必须等待队首先被取出才行。这会极大降低转发效率。</p><hr><p>输出排队：如果Switching Fabric转发的速度比输出端口的处理速度还要快的话，就会在输出端口出现排队现象。</p><h3 id="4-2-5-Packet-Scheduling-包调度"><a href="#4-2-5-Packet-Scheduling-包调度" class="headerlink" title="4.2.5 Packet Scheduling 包调度"></a>4.2.5 Packet Scheduling 包调度</h3><p>包调度是指在一个输出端口的缓冲区上决定下面转发哪一个包。</p><hr><p>先进先出调度：简单，就是先到达的包先调度处理</p><hr><p>优先级调度排队：在包到达时，会先将包分类，不同的类有不同的优先级，也有自己的队列，取包时先从高优先级的队列中取。相同队列中的包一般以先进先出的方式处理。</p><p>优先级调度通常用在比如：</p><ul><li>网络控制包(比如路由协议包) 优先于 用户数据包</li><li>实时性数据包(比如实时视频会议数据) 优先于 普通数据(比如电子邮件)</li></ul><hr><p>轮询和权值轮询：在包到达时，先将包分类，不同的类有自己的队列，每次取包时，轮流从不同的队列中取。我们也可以为每个队列加上权值，权值高的每次多取几个包再转移到下一个队列中去取包。</p><h2 id="4-3-IP协议，IP地址，IPv4，IPv6"><a href="#4-3-IP协议，IP地址，IPv4，IPv6" class="headerlink" title="4.3 IP协议，IP地址，IPv4，IPv6"></a>4.3 IP协议，IP地址，IPv4，IPv6</h2><h3 id="4-3-1-IPv4包格式"><a href="#4-3-1-IPv4包格式" class="headerlink" title="4.3.1 IPv4包格式"></a>4.3.1 IPv4包格式</h3><p>IPv4包头有如下的域：</p><ul><li>版本号。IPv4或者IPv6</li><li>包头长度。由于IPv4包头有可选的域，于是需要说明一下包头长度</li><li>服务类型(Type of Service)。可以将比如实时性数据包和非实时性数据包区分开来。如何设置由路由器管理者决定。</li><li>包长度。</li><li>Identifier, flags, fragmentation offset.这三者用来处理IP包的分段</li><li>Time-to-live. 这个域用于确保IP包不会在网络中永久循环传播，每次经过一跳，就会减一，直到成为0，路由器就会直接丢弃该IP包。</li><li>上层协议。一般IP包到达目的地，才会通过这个域决定IP包中的数据交给哪个上层协议。类似于传输层的端口号决定传给哪个应用进程。</li><li>包头校验和。用于错误检查。注意，每一跳上，由于Time-to-live会改变，所以校验和也必须重新计算。</li><li>源IP地址，目的IP地址</li><li>可选项</li></ul><h3 id="4-3-2-IPv4包分段"><a href="#4-3-2-IPv4包分段" class="headerlink" title="4.3.2 IPv4包分段"></a>4.3.2 IPv4包分段</h3><p>由于链路层对于最大可传送的链路层包大小有限制，所以一个IP包未必能完整的组成一个整包进行发送，就需要用到IPv4包分段。</p><p>包分段主要涉及到包头Identifier, flags, fragmentation offset三个域：</p><ul><li>identifier 用于标示所在的原始包，也就是说，拥有相同identifier的片段是属于相同的原始IP包的</li><li>flags 包括两个flag<ul><li>一个用于标示是否允许IP协议进行分段</li><li>另一个用于标示该分段是否是最后一段，0表示最后一段，1表示不是最后一段</li></ul></li><li>fragmentation offset用于表示该分段的数据在原数据中的偏移，以八字节为单位<ul><li>比如fragmentation offset是20，就说明这个片段里的第一个字节的数据已经是原数据里第161字节的数据了，前面有160个字节的数据在别的分段里</li></ul></li></ul><h3 id="4-3-3-IPv4地址"><a href="#4-3-3-IPv4地址" class="headerlink" title="4.3.3 IPv4地址"></a>4.3.3 IPv4地址</h3><p>IPv4地址为32位的二进制数。</p><p>一般情况下，IPv4被表示为a.b.c.d的形式，其中，a,b,c,d是IPv4地址中第1,2,3,4个字节的十进制表示。</p><p>由于因特网被分成了各个不同的子网，所以对于每一个IPv4地址，都可以将它分为两部分，第一部分是网络地址部分，代表了该IP地址所在的网络，第二部分是主机地址部分，代表了IP地址在网络中的标识符。</p><p>现在的网络-主机地址划分方法为CIDR(Classless Interdomain Routing)，也就是以32位地址的前x位作为网络地址，剩下的32-x位是主机地址，记作a.b.c.d/x。</p><p>特殊的IP地址：255.255.255.255，该地址为特定的广播地址，只要向该地址发送IP包，路由器会自动将包发送到当前子网下的所有主机上，甚至有可能发送到子网外的主机上。</p><h4 id="获取子网IP地址"><a href="#获取子网IP地址" class="headerlink" title="获取子网IP地址"></a>获取子网IP地址</h4><p>想要获取子网的IP地址，必须向上一级的IP地址管理者发出申请并由上一级进行分配。</p><h4 id="获取主机IP地址"><a href="#获取主机IP地址" class="headerlink" title="获取主机IP地址"></a>获取主机IP地址</h4><p>主机的IP地址可以手动分配，也可以使用DHCP(Dynamic Host Configuration Protocol)进行分配。</p><h5 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h5><p>想要DHCP正常工作，子网内必须有一个DHCP服务器，当一个新到来的主机想要获得IP地址时，过程如下：</p><ol><li>主机尝试发现DHCP服务器。<ol><li>由于新来的主机既不清楚自己的IP地址，也不清楚DHCP服务器的IP地址，所以主机以0.0.0.0的源IP地址向广播端口255.255.255.255发送一条探测消息，固定端口号为67</li><li>在这条消息里会包含一个事务ID</li></ol></li><li>DHCP服务器给出IP地址。<ol><li>同样，由于DHCP服务器暂时无法确定主机的IP地址，它需要向255.255.255.255发送消息。</li><li>这条消息里包含了提供的IP地址，该地址的有效时间，自身DHCP服务器的IP地址，主机传来的事务ID。</li></ol></li><li>DHCP Request。<ol><li>新来的主机可能会从多个DHCP服务器中获得提供的IP地址，它需要选择一个，然后发送DHCP Request Message，此时还不确定能不能真的拿到该IP，所以仍然需要0.0.0.0到255.255.255.255发送Request</li><li>这个Request消息里会包含被选中的IP地址，那么对应的服务器就知道新来的主机选择了自己提供的IP</li></ol></li><li>DHCP ACK。<ol><li>DHCP服务器接收到新来主机的Request Message之后，发出DHCP ACK，确认已经配置好了。此时仍然需要向255.255.255.255发送ACK。</li></ol></li></ol><h3 id="4-3-4-Network-Address-Translation-NAT"><a href="#4-3-4-Network-Address-Translation-NAT" class="headerlink" title="4.3.4 Network Address Translation(NAT)"></a>4.3.4 Network Address Translation(NAT)</h3><p>在IP地址中，有一类地址被保留下来作为私有地址，10.0.0.0/8就是其中一类。</p><p>所谓私有地址就是指该地址只在当前所在的子网中有意义，一旦考虑外部网络，该地址就没有意义。</p><p>那么当私有地址的主机尝试和外界通讯时，需要将私有地址转化为公开地址，这就是NAT的作用。</p><p>NAT通过如下几点来进行私有地址到公开地址的转化：</p><ol><li>NAT由一个路由器来进行操作</li><li>NAT路由器拥有一个公开的IP地址，假设为X</li><li>NAT路由器中维护了一张&lt;端口号, &lt;私有IP，端口号&gt;&gt;的表，也就是说子网中的&lt;私有IP地址, 端口号&gt;对应到了&lt;统一的公开IP地址, 端口号&gt;上</li><li>当子网内的主机尝试向外发送包，源地址就从&lt;私有IP地址, 端口号&gt;被NAT转化为&lt;统一的公开IP地址, 端口号&gt;，同样，当外部网络发送包到NAT时，NAT将目的地址转化为&lt;私有IP地址, 端口号&gt;而后发给对应主机。</li></ol><p>NAT的使用备受争议：</p><ol><li>NAT打破了因特网中的分层原则，同时使用传输层和网络层来修改地址和端口号。</li><li>NAT将许多主机隐藏在了一个路由器后面，将原本用于定位应用进程的端口号用于定位主机，那么有一些专用的端口号比如服务器的80端口就会受到影响(事实上很少将服务器放置在NAT后面)</li></ol><h3 id="4-3-5-IPv6"><a href="#4-3-5-IPv6" class="headerlink" title="4.3.5 IPv6"></a>4.3.5 IPv6</h3><p>由于32位IPv4地址会被用尽，所以新的IPv6进入了开发阶段，虽然距离IPv4地址真正用尽还有一定的时间，但是想要部署IPv6，也同样需要大量的时间。</p><p>相比于IPv4，IPv6有如下特性：</p><ol><li>扩展的地址空间。<ol><li>IPv6地址为128位地址</li><li>IPv6地址除了支持IPv4中的单播，广播，还支持组播(即向固定的一组IP地址进行发包)</li></ol></li><li>定长的40字节包头<ol><li>除去了IPv4包头里的可选项</li><li>定长包头更加易于处理，路由更快</li></ol></li><li>流标签<ol><li>类似于IPv4中的Type of Service，IPv6使用流来区别不同的包</li><li>流标签用来区别不同的流</li></ol></li></ol><h4 id="IPv6-包头格式"><a href="#IPv6-包头格式" class="headerlink" title="IPv6 包头格式"></a>IPv6 包头格式</h4><p>IPv6包头中包含了：</p><ul><li>版本(IPv4 or IPv6)</li><li>等级(Traffic Class)，用于给包赋予优先级，可以是根据流来赋予，也可以根据源应用来赋予</li><li>流标签(Flow Label)，用于标示一个流</li><li>负载长度(Payload Length)，由于包头定长，所以只记录了携带数据的长度</li><li>下一包头(Next Header)，也就是类似于IPv4中的协议，用于标示上一层使用的协议(TCP,UDP, etc.)，或者指向可选项</li><li>跳限制(Hop Limit)，类似于IPv4中的Time-to-live，减小到零，直接丢弃</li><li>源地址和目的地址</li></ul><p>可以从IPv6的包头中看到，有一部分功能被删除了：</p><ul><li>分片/重组<ul><li>IPv6的IP包如果由于过大不能在链路层上传输，路由器会返回一个<em>Packet too big</em>的ICMP消息，而不是像IPv4一样进行分片</li><li>如果要分片，就是在收到ICMP消息后在终端主机上进行分片</li><li>加快了路由的速度</li></ul></li><li>校验和<ul><li>由于传输层和链路层都有校验机制，所以在网络层就不再设置校验机制</li><li>加快了路由速度</li></ul></li><li>可选项<ul><li>使用Next Header进行指向而不是放在包头内</li><li>定长的包头，更易处理</li></ul></li></ul><h4 id="IPv4到IPv6"><a href="#IPv4到IPv6" class="headerlink" title="IPv4到IPv6"></a>IPv4到IPv6</h4><p>如果想要从IPv4转变到IPv6，我们新建的IPv6路由器可以兼容IPv4的IP包路由，但是以往的IPv4路由器想要兼容IPv6就会比较困难。</p><p>我们可以使用隧道(tunneling)的方式解决这个问题。</p><p>也就是说，将两个IPv6的路由/主机之间的IPv4路由视作链路层协议而不是同等的网络层协议，当需要发送IPv6包时，将其包裹在一个IPv4包中发出，到达终点后解开IPv4包，提取出IPv6包。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Computer Networking - A Top-Down Approach》第四章4.1-4.3复习知识点总结&lt;/p&gt;
    
    </summary>
    
      <category term="NJU-Class" scheme="https://rivers-shall.github.io/categories/NJU-Class/"/>
    
      <category term="计算机网络" scheme="https://rivers-shall.github.io/categories/NJU-Class/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
</feed>
