<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>碧漾的自我</title>
  
  <subtitle>beyond myself</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rivers-shall.github.io/"/>
  <updated>2020-06-10T11:54:36.544Z</updated>
  <id>https://rivers-shall.github.io/</id>
  
  <author>
    <name>碧漾</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>star-history源码阅读笔记(01)-项目介绍,Github的stargazers接口与分页机制，获取star历史的思路</title>
    <link href="https://rivers-shall.github.io/2020/06/09/star-history%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-01-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D-Github%E7%9A%84stargazers%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/"/>
    <id>https://rivers-shall.github.io/2020/06/09/star-history源码阅读笔记-01-项目介绍-Github的stargazers接口与分页机制/</id>
    <published>2020-06-09T08:20:00.000Z</published>
    <updated>2020-06-10T11:54:36.544Z</updated>
    
    <content type="html"><![CDATA[<p>本文是<a href="https://github.com/timqian/star-history" target="_blank" rel="noopener">star-history项目</a>源码阅读的第一篇文章，会包含:</p><ul><li>作者对项目的介绍，这个系列博文的目的</li><li>Github的stargazers接口</li><li>Github接口的分页策略</li><li>获取star历史的思路</li></ul><p>本次对代码的分析基于Commit - <a href="https://github.com/timqian/star-history/tree/deecd92097809f39cd0ccd521b85ad54ac8fad24" target="_blank" rel="noopener">first commit deecd92 timqian</a></p><a id="more"></a><h2 id="项目的介绍与系列博文的目的"><a href="#项目的介绍与系列博文的目的" class="headerlink" title="项目的介绍与系列博文的目的"></a>项目的介绍与系列博文的目的</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>首先说明，本文作者并非项目作者，各种介绍和分析，如有不当，还请谅解。</p><p><a href="https://github.com/timqian/star-history" target="_blank" rel="noopener">star-history项目</a>(<a href="https://star-history.t9t.io/" target="_blank" rel="noopener">体验地址</a>)是一个用于统计github项目获得star历史的组件，包括web app网页版本和chrome extension版本</p><p>产生这个项目的原因，是Github官方并没有提供查看项目star历史的功能</p><h3 id="博文目的"><a href="#博文目的" class="headerlink" title="博文目的"></a>博文目的</h3><ul><li>留作知识沉淀<ul><li>从体验界面来看，前端效果和功能都很不错，希望学习一下</li></ul></li><li>将我三次元的时间，尽！情！挥！霍！</li></ul><h2 id="Github的stargazers接口"><a href="#Github的stargazers接口" class="headerlink" title="Github的stargazers接口"></a>Github的stargazers接口</h2><p>Github官方提供了一系列REST API(现在有向graphql上迁移的趋势)，通过REST API，可以获得许多Github上的信息，以此为基础，我们可以构建各式各样的APP，star-history这个项目也是这样建立起来的</p><p>Github虽然没有提供直接查看项目star历史的功能，但是却提供了<a href="https://developer.github.com/v3/activity/starring/" target="_blank" rel="noopener">stargazers接口</a>，这个接口有两种形式</p><ol><li>查看star了一个项目的所有用户</li><li>同上，并且加入该用户star该项目的时间</li></ol><p>这二者共用同一个rest url，不同的是：</p><blockquote><p>方法2需要在HTTP请求头中加入<code>Accept: application/vnd.github.v3.star+json</code></p></blockquote><p>其rest url和返回的json格式分别是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">GET /repos/:owner/:repo/stargazers</span><br><span class="line"># 没有时间</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"login"</span>: <span class="string">"octocat"</span>,</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"node_id"</span>: <span class="string">"MDQ6VXNlcjE="</span>,</span><br><span class="line">    <span class="attr">"avatar_url"</span>: <span class="string">"https://github.com/images/error/octocat_happy.gif"</span>,</span><br><span class="line">    <span class="attr">"gravatar_id"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://api.github.com/users/octocat"</span>,</span><br><span class="line">    <span class="attr">"html_url"</span>: <span class="string">"https://github.com/octocat"</span>,</span><br><span class="line">    <span class="attr">"followers_url"</span>: <span class="string">"https://api.github.com/users/octocat/followers"</span>,</span><br><span class="line">    <span class="attr">"following_url"</span>: <span class="string">"https://api.github.com/users/octocat/following&#123;/other_user&#125;"</span>,</span><br><span class="line">    <span class="attr">"gists_url"</span>: <span class="string">"https://api.github.com/users/octocat/gists&#123;/gist_id&#125;"</span>,</span><br><span class="line">    <span class="attr">"starred_url"</span>: <span class="string">"https://api.github.com/users/octocat/starred&#123;/owner&#125;&#123;/repo&#125;"</span>,</span><br><span class="line">    <span class="attr">"subscriptions_url"</span>: <span class="string">"https://api.github.com/users/octocat/subscriptions"</span>,</span><br><span class="line">    <span class="attr">"organizations_url"</span>: <span class="string">"https://api.github.com/users/octocat/orgs"</span>,</span><br><span class="line">    <span class="attr">"repos_url"</span>: <span class="string">"https://api.github.com/users/octocat/repos"</span>,</span><br><span class="line">    <span class="attr">"events_url"</span>: <span class="string">"https://api.github.com/users/octocat/events&#123;/privacy&#125;"</span>,</span><br><span class="line">    <span class="attr">"received_events_url"</span>: <span class="string">"https://api.github.com/users/octocat/received_events"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"User"</span>,</span><br><span class="line">    <span class="attr">"site_admin"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">GET /repos/:owner/:repo/stargazers</span><br><span class="line">Header:</span><br><span class="line">Accept: application/vnd.github.v3.star+json</span><br><span class="line"># 有star时间</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"starred_at"</span>: <span class="string">"2011-01-16T19:06:43Z"</span>,</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">      <span class="attr">"login"</span>: <span class="string">"octocat"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"node_id"</span>: <span class="string">"MDQ6VXNlcjE="</span>,</span><br><span class="line">      <span class="attr">"avatar_url"</span>: <span class="string">"https://github.com/images/error/octocat_happy.gif"</span>,</span><br><span class="line">      <span class="attr">"gravatar_id"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"url"</span>: <span class="string">"https://api.github.com/users/octocat"</span>,</span><br><span class="line">      <span class="attr">"html_url"</span>: <span class="string">"https://github.com/octocat"</span>,</span><br><span class="line">      <span class="attr">"followers_url"</span>: <span class="string">"https://api.github.com/users/octocat/followers"</span>,</span><br><span class="line">      <span class="attr">"following_url"</span>: <span class="string">"https://api.github.com/users/octocat/following&#123;/other_user&#125;"</span>,</span><br><span class="line">      <span class="attr">"gists_url"</span>: <span class="string">"https://api.github.com/users/octocat/gists&#123;/gist_id&#125;"</span>,</span><br><span class="line">      <span class="attr">"starred_url"</span>: <span class="string">"https://api.github.com/users/octocat/starred&#123;/owner&#125;&#123;/repo&#125;"</span>,</span><br><span class="line">      <span class="attr">"subscriptions_url"</span>: <span class="string">"https://api.github.com/users/octocat/subscriptions"</span>,</span><br><span class="line">      <span class="attr">"organizations_url"</span>: <span class="string">"https://api.github.com/users/octocat/orgs"</span>,</span><br><span class="line">      <span class="attr">"repos_url"</span>: <span class="string">"https://api.github.com/users/octocat/repos"</span>,</span><br><span class="line">      <span class="attr">"events_url"</span>: <span class="string">"https://api.github.com/users/octocat/events&#123;/privacy&#125;"</span>,</span><br><span class="line">      <span class="attr">"received_events_url"</span>: <span class="string">"https://api.github.com/users/octocat/received_events"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"User"</span>,</span><br><span class="line">      <span class="attr">"site_admin"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="Github接口的分页策略"><a href="#Github接口的分页策略" class="headerlink" title="Github接口的分页策略"></a>Github接口的分页策略</h2><p>对于stargazers接口，一个仓库很可能有数万甚至数十万个用户star过，如果我们在一次请求<br><code>GET /repos/:owner/:repo/stargazers</code><br>中，就将所有的信息全部都拿出来，会导致:</p><ul><li>网络IO和内存IO负荷过大</li><li>不灵活，也许有些接口调用方并不想要全部的数据，只想要部分的，这样的请求IO就全部浪费了</li></ul><p>为此，Github的很多API都引入了分页机制</p><p>分页机制中，比较重要的有几点：</p><ul><li>如何知道一个url的资源被分成了多少页？</li><li>如何知道目前是哪一页？</li><li>如何知道一个url的资源在一页上有多少个？</li><li>如何获取一个url任意一页的资源？</li></ul><p>我们先来看看Github的REST API是如何接受和提供分页信息的</p><h3 id="接受分页信息"><a href="#接受分页信息" class="headerlink" title="接受分页信息"></a>接受分页信息</h3><p>对于每一个url，我们可以在后面加上<code>page</code>和<code>per_page</code>参数:</p><ul><li><code>per_page</code>参数指定了一页上有多少个资源<ul><li>这个参数可以没有，不同的url接口会有不同的默认值，有的是30，有的是100，具体靠阅读文档</li><li>并不是所有的url接口都接受这个参数，有些url接口不接受，具体靠阅读文档</li></ul></li><li><code>page</code>参数指定了需要拿哪一页的资源</li></ul><h3 id="提供分页信息"><a href="#提供分页信息" class="headerlink" title="提供分页信息"></a>提供分页信息</h3><p>在HTTP响应中，Github接口加入一个响应头<code>Link</code>，这个响应头的样式大概是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 注意这个请求没有加上page参数，也能获得Link响应头</span><br><span class="line">GET https://api.github.com/search/code?q=addClass+user%3Amozilla</span><br><span class="line"></span><br><span class="line"># HTTP响应的响应头</span><br><span class="line">Link: &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=15&gt;; rel=&quot;next&quot;,</span><br><span class="line">  &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=34&gt;; rel=&quot;last&quot;,</span><br><span class="line">  &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=1&gt;; rel=&quot;first&quot;,</span><br><span class="line">  &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=13&gt;; rel=&quot;prev&quot;</span><br></pre></td></tr></table></figure><p>其中<code>rel</code>表示的是url和当前url的关系:</p><ul><li><code>prev</code>，前一页的url</li><li><code>next</code>，下一页的url</li><li><code>last</code>，最后一页的url，也就是总页数</li><li><code>first</code>，第一页的url</li></ul><h3 id="疑问的解答"><a href="#疑问的解答" class="headerlink" title="疑问的解答"></a>疑问的解答</h3><p>所以我们之前的数个疑问就可以得到解答</p><ul><li>如何知道一个url的资源被分成了多少页？<ul><li>首先不带<code>page</code>参数进行请求，而后通过响应头，提取出<code>last</code>对应的url中的<code>page</code>参数即可</li></ul></li><li>如何知道目前是哪一页？<ul><li>当前url的<code>page</code>参数就是当前页数</li><li>响应头中的<code>next</code>对应的url中的<code>page</code>参数是下一页</li></ul></li><li>如何知道一个url的资源在一页上有多少个？<ul><li>查看文档，会有默认值</li><li>查看文档，如果url接口接受<code>per_page</code>参数，就可以自行设置(注意可能会有最大值限制)</li></ul></li><li>如何获取一个url任意一页的资源？<ul><li>加入<code>page</code>参数</li></ul></li></ul><h2 id="获取star历史的思路"><a href="#获取star历史的思路" class="headerlink" title="获取star历史的思路"></a>获取star历史的思路</h2><p>了解了Github的stargazers接口及分页策略，我们就可以来分析一下获取star历史的方法:</p><ol><li>调用stargazers接口，要带star日期的</li><li>根据star日期进行排序</li><li>统计出star发生改变的时间(也就是某个用户star了仓库的时间)和当时的star数目(就是排序后的索引值)</li><li>以改变的时间作为横轴，改变当时的star数目作为纵轴，绘制图像</li></ol><p>这样来看，基本上是没错的，但是还要考虑一点</p><blockquote><p>如果一个仓库有数千数万数十万star，我们就要绘制数千数万数十万的点吗？</p></blockquote><p>可以当然是可以的，但是这么做，对于高star的项目，内存和网络消耗过大，处理时间过长，项目初期，不利于我们开发和调试</p><p>所以我们可以利用分页机制进行<strong>取样</strong></p><p>比如，我们选定取样点数为20，那么，</p><ul><li>对于star数目不足20的项目，<ul><li>我们获取所有的信息，并绘制出所有的点</li></ul></li><li>对于star数目高于20的项目(假设star数为N)，<ul><li>我们获取0, N/20, 2N/20, 3N/20, …, N时的时间</li><li>然后以这二十个时间点和star数，绘制20个点即可</li></ul></li></ul><p>上面描述的是如何取样，那么<strong>取样</strong>与<strong>分页</strong>有什么关系呢？</p><p>那就是——我们不需要获取<em>总star数目</em>，我们只需要获取<em>总页数</em></p><ul><li>对于一个stargazers接口页数为N的项目<ul><li>我们获取0, N/20, 2N/20, 3N/20, …, N页上最早的时间</li><li>然后以这二十个时间点和star数(页编号 * 每页资源数目)，绘制20个点即可</li></ul></li></ul><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>事实上，项目代码中也是这么操作的(事实上刚才的思路是我从代码中倒推出来的，尬笑)</p><p><code>generateUrls.js</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getConfig = &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    Accept: <span class="string">'application/vnd.github.v3.star+json'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">repo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> initUrl = <span class="string">`https://api.github.com/repos/<span class="subst">$&#123;repo&#125;</span>/stargazers`</span>;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> axios.get(initUrl, getConfig).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表明我们使用的是stargazers的带时间的接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> link = res.headers.link;</span><br><span class="line"><span class="keyword">if</span> (!link) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> pageNumArray = <span class="regexp">/next.*?page=(\d*).*?last/</span>.exec(link);</span><br><span class="line">  <span class="keyword">const</span> pageNum = pageNumArray[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> samplePageUrls = [];</span><br><span class="line">  <span class="keyword">let</span> pageIndexes = [];</span><br><span class="line">  <span class="keyword">if</span> (pageNum &lt;= sampleNum) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= pageNum; i++) &#123;</span><br><span class="line">      pageIndexes.push(i);</span><br><span class="line">      samplePageUrls.push(initUrl + <span class="string">'?page='</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; sampleNum; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> pageIndex = <span class="built_in">Math</span>.round(i / sampleNum * pageNum);</span><br><span class="line">      pageIndexes.push(pageIndex);</span><br><span class="line">      samplePageUrls.push(initUrl + <span class="string">'?page='</span> + pageIndex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    samplePageUrls, pageIndexes,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这一段代码是通过响应头<code>Link</code>，使用正则表达式提取出总页数，然后取样<code>sampleNum</code>个点</p><p><code>getStarHistory.js</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">repo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    samplePageUrls, pageIndexes</span><br><span class="line">  &#125; = <span class="keyword">await</span> generateUrls(repo).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">// throw don't work</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getArray = samplePageUrls.map(<span class="function"><span class="params">url</span> =&gt;</span> axios.get(url, getConfig));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> resArray = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(getArray).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">// throw don't work</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> starHistory = pageIndexes.map(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      date: resArray[i].data[<span class="number">0</span>].starred_at.slice(<span class="number">0</span>, <span class="number">10</span>),</span><br><span class="line">      starNum: <span class="number">30</span> * (p - <span class="number">1</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(starHistory);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> starHistory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段代码，</p><ol><li>通过<code>generateUrls.js</code>的接口获取所有采样的url接口，而后进行请求</li><li>请求后获得每一页最小的时间，并把最小的时间和当页代表的star数组合起来返回</li></ol><p>这样，就得到了一个项目的star历史</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是&lt;a href=&quot;https://github.com/timqian/star-history&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;star-history项目&lt;/a&gt;源码阅读的第一篇文章，会包含:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作者对项目的介绍，这个系列博文的目的&lt;/li&gt;
&lt;li&gt;Github的stargazers接口&lt;/li&gt;
&lt;li&gt;Github接口的分页策略&lt;/li&gt;
&lt;li&gt;获取star历史的思路&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本次对代码的分析基于Commit - &lt;a href=&quot;https://github.com/timqian/star-history/tree/deecd92097809f39cd0ccd521b85ad54ac8fad24&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;first commit deecd92 timqian&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
      <category term="star-history源码阅读笔记" scheme="https://rivers-shall.github.io/categories/star-history%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Github" scheme="https://rivers-shall.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>goland提取方法与...interface{}类型的注意点</title>
    <link href="https://rivers-shall.github.io/2020/06/08/goland%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%E4%B8%8E-interface-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>https://rivers-shall.github.io/2020/06/08/goland提取方法与-interface-类型的注意点/</id>
    <published>2020-06-08T09:15:04.000Z</published>
    <updated>2020-06-08T11:50:33.943Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用goland提供的提取方法(Extract Method)功能时，由于<code>...interface{}</code>的类型问题而遭遇到的bug和一点感悟，简单来说:</p><ul><li>可变长的参数会被goland的Extract Method转化为切片(slice)，比如<code>...interface{}</code>会被转化为<code>[]interface{}</code></li><li>由于<code>interface{}</code>的特殊性，需要额外注意</li></ul><a id="more"></a><h2 id="bug的产生"><a href="#bug的产生" class="headerlink" title="bug的产生"></a>bug的产生</h2><p>在代码中有如下片段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在想要将循环提取出来，作为一个方法，在goland中可以直接选中文本然后Extract Method，但是结果是这样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ExtractedMethod(payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtractedMethod</span><span class="params">(payload []<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>期望中的函数签名是<code>ExtractedMethod(payload ...interface{})</code>，不符合预期，所以要进行修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG!!!!!!!!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ExtractedMethod(payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtractedMethod</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码不会有编译错误，但是是完全不符合预期的，为什么呢？</p><h2 id="bug的原因"><a href="#bug的原因" class="headerlink" title="bug的原因"></a>bug的原因</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG!!!!!!!!</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// we need to unpack payload</span></span><br><span class="line">    ExtractedMethod(payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtractedMethod</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述注释所说，我们需要对<code>f</code>中传递给<code>ExtractedMethod</code>的参数<code>payload</code>做一个解包工作，因为</p><ul><li>我们<code>f</code>函数的本意是要用<code>ExtractedMehtod</code>对<code>payload</code>中的每一个元素做处理</li><li>现在不解包，<code>payload</code>原本一个<code>[]interface{}</code>又被<strong>额外自动包装了一层</strong>，成为了<code>interface{}</code>传递给了<code>ExtractedMethod</code>，只会对整个<code>payload</code>做一次处理</li></ul><h2 id="bug的解决与思考"><a href="#bug的解决与思考" class="headerlink" title="bug的解决与思考"></a>bug的解决与思考</h2><p>将代码修改为如下后正确</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ExtractedMethod(payload...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExtractedMethod</span><span class="params">(payload ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> payload &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后可以采取的方法是，先将传参的地方<code>payload</code>改为<code>payload...</code>，这样的话如果忘记修改参数<code>[]interface{}</code>为<code>...interface{}</code>，是会有编译器报错的</p><p>这个修改顺序可以让编译器为我们保驾</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用goland提供的提取方法(Extract Method)功能时，由于&lt;code&gt;...interface{}&lt;/code&gt;的类型问题而遭遇到的bug和一点感悟，简单来说:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可变长的参数会被goland的Extract Method转化为切片(slice)，比如&lt;code&gt;...interface{}&lt;/code&gt;会被转化为&lt;code&gt;[]interface{}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;interface{}&lt;/code&gt;的特殊性，需要额外注意&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="goland" scheme="https://rivers-shall.github.io/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>常见的git工作流</title>
    <link href="https://rivers-shall.github.io/2020/06/07/%E5%B8%B8%E8%A7%81%E7%9A%84git%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>https://rivers-shall.github.io/2020/06/07/常见的git工作流/</id>
    <published>2020-06-07T03:58:16.000Z</published>
    <updated>2020-06-07T05:18:53.805Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了作者了解到的三种常见的<em>单仓库</em>的git工作流，它们是:</p><ol><li>Centralized工作流<ul><li>仅使用master一个分支</li></ul></li><li>Feature Branch工作流<ul><li>使用一个master分支管理稳定版本</li><li>使用多个feature分支管理需求开发</li></ul></li><li>Gitflow工作流<ul><li>使用一个master分支管理发布版本历史</li><li>使用一个develop分支管理开发流程</li><li>使用多个feature分支管理需求开发</li><li>使用多个release分支管理版本发布</li><li>使用多个hotfix分支修复紧急bug</li></ul></li></ol><a id="more"></a><h2 id="Centralized工作流"><a href="#Centralized工作流" class="headerlink" title="Centralized工作流"></a>Centralized工作流</h2><p><img src="centralized-rebase.svg" alt="centralized"></p><p>这种工作流只使用唯一的master分支</p><h3 id="Centralized需求开发的过程"><a href="#Centralized需求开发的过程" class="headerlink" title="Centralized需求开发的过程"></a>Centralized需求开发的过程</h3><ul><li>拉取远端分支(pull/clone)</li><li>开发(add, commit)<ul><li>上图中的白色master</li></ul></li><li>再次拉取远端分支(fetch)<ul><li>上图中的紫色origin/master</li></ul></li><li>合入，处理冲突(rebase)<ul><li>上图中的蓝色master</li><li>注意这里不使用merge，merge会导致master分支出现类似新branch的分叉行为, 丢失了单分支的简洁性</li></ul></li><li>提交修改(push)</li></ul><h3 id="Centralized工作流优点"><a href="#Centralized工作流优点" class="headerlink" title="Centralized工作流优点"></a>Centralized工作流优点</h3><ul><li>简单，对于单人小项目，没有必要考虑太多管理的情况下直接使用，没有问题</li><li>和SVN的工作流非常相似，方便从SVN迁移到Git的团队做一段时间的缓冲</li></ul><h3 id="Centralized工作流缺点"><a href="#Centralized工作流缺点" class="headerlink" title="Centralized工作流缺点"></a>Centralized工作流缺点</h3><ul><li>太过简单，没有利用好Git的分支特性</li></ul><h2 id="Feature-Branch工作流"><a href="#Feature-Branch工作流" class="headerlink" title="Feature Branch工作流"></a>Feature Branch工作流</h2><p><img src="feature-branch.svg" alt="feature-branch"></p><p>对于这种工作流，开发者需要使用:</p><ul><li>一个master分支管理稳定版本</li><li>多个feature分支管理需求开发</li></ul><h3 id="Feature-Branch需求开发的过程"><a href="#Feature-Branch需求开发的过程" class="headerlink" title="Feature Branch需求开发的过程"></a>Feature Branch需求开发的过程</h3><ul><li>拉取远端分支(pull/clone)</li><li>从master新建feature分支(checkout -b feature/XXX)</li><li>开发(add, commit)</li><li>再次拉取远端分支(fetch)</li><li>合入，处理冲突(merge)<ul><li>注意这里需要的合入处理冲突是指将feature/XXX合入master，而不是将master合入feature/XXX</li><li>另外，merge的时候建议使用<code>--no-ff</code>，保证只产生一个merge commit，原因下面会讲</li></ul></li><li>提交修改(push)</li></ul><h3 id="Feature-Branch工作流优点"><a href="#Feature-Branch工作流优点" class="headerlink" title="Feature Branch工作流优点"></a>Feature Branch工作流优点</h3><p>该工作流相比于Centralized工作流，更加复杂，利用了Git分支的特性，相比之下，优点有:</p><ul><li>需求开发的管理更加清晰，有单独的分支</li><li>由于使用的是不同的分支，可以开启pull request和merge review，通过强制code review提高代码质量</li><li>需求分支合入master时，只会产生唯一的merge commit(如果merge的时候使用了<code>--no-ff</code>的话)，这样如果想要把一个feature revert掉，只需要revert唯一的一个commit，而不需要选出有关的commit一个个地revert</li></ul><h3 id="Feature-Branch工作流缺点"><a href="#Feature-Branch工作流缺点" class="headerlink" title="Feature Branch工作流缺点"></a>Feature Branch工作流缺点</h3><p>缺点/不足:</p><ul><li>没有专门用于版本发布的机制<ul><li>版本发布可能涉及到很多非开发的杂事(比如文档编写与生成，项目打包等等)，这些不适合作为feature来开发</li><li>在该工作流中，没有办法清晰看出哪些commit是发布的版本</li></ul></li><li>没有用于紧急修复bug的机制<ul><li>紧急bug修复，也不适合作为feature来开发</li></ul></li></ul><h2 id="Gitflow工作流"><a href="#Gitflow工作流" class="headerlink" title="Gitflow工作流"></a>Gitflow工作流</h2><p><img src="gitflow.svg" alt="gitflow"></p><p>这个工作流需要开发者:</p><ul><li>使用一个master分支管理发布版本历史</li><li>使用一个develop分支管理开发流程</li><li>使用多个feature分支管理需求开发</li><li>使用多个release分支管理版本发布</li><li>使用多个hotfix分支修复紧急bug</li></ul><h3 id="Gitflow需求开发流程-feature分支"><a href="#Gitflow需求开发流程-feature分支" class="headerlink" title="Gitflow需求开发流程(feature分支)"></a>Gitflow需求开发流程(feature分支)</h3><ul><li>拉取远端分支(pull/clone)</li><li>从develop分支开启新的feature分支(checkout -b feature/XXX)</li><li>开发(add, commit)</li><li>再次拉取远端分支(fetch)</li><li>合入，解决冲突(merge)</li><li>提交修改(push)</li></ul><p>这个流程和feature branch是一致的，只不过把base分支从master改为了develop</p><p>注意所有的feature分支都:</p><ul><li>从<strong>develop</strong>分支新建而来</li><li>合入到develop分支而去</li></ul><h3 id="Gitflow版本发布流程-release分支"><a href="#Gitflow版本发布流程-release分支" class="headerlink" title="Gitflow版本发布流程(release分支)"></a>Gitflow版本发布流程(release分支)</h3><ul><li>拉取远端分支(pull/clone)</li><li>从develop分支开启新的release分支(checkout -b release/XXX)</li><li>版本发布开发(add, commit)<ul><li>包括文档生成，打包等杂事</li><li>也可以修复小bug</li><li>但是大的改动必须使用需求开发流程，去新feature分支进行处理，并移动到下个版本上</li></ul></li><li>再次拉取远端分支(fetch)</li><li>合入，解决冲突(merge)<ul><li>这里，需要将release分支同时合入master和develop分支</li><li>合入master，是为了保存版本发布记录</li><li>合入develop，是为了后续开发能够兼容该版本<ul><li>比如说在release上修复了小bug，或者添加了文档注释等，都要反映到后续开发上</li></ul></li></ul></li><li>提交(push)</li></ul><p>注意所有的release分支都:</p><ul><li>从<strong>develop</strong>分支新建而来</li><li>合入到master和develop分支而去</li></ul><h3 id="Gitflow紧急修复bug流程"><a href="#Gitflow紧急修复bug流程" class="headerlink" title="Gitflow紧急修复bug流程"></a>Gitflow紧急修复bug流程</h3><ul><li>拉取远端分支(pull/clone)</li><li>从master分支新建hotfix分支(checkout -b hotfix/XXX)</li><li>开发，修复bug(add, commit)</li><li>再次拉取远端分支(fetch)</li><li>合入，解决冲突(merge)<ul><li>这里的合入需要同时合入master和develop，理由同release分支</li><li>但是理论上合入master分支的时候不应该有冲突，只能在合入develop分支的时候才会有可能冲突</li></ul></li><li>提交(push)</li></ul><p>注意所有的release分支都:</p><ul><li>从<strong>master</strong>分支新建而来</li><li>合入到master和develop分支而去</li></ul><h3 id="Gitflow工作流评价"><a href="#Gitflow工作流评价" class="headerlink" title="Gitflow工作流评价"></a>Gitflow工作流评价</h3><p>这里就不放优缺点了，因为Gitflow是目前使用最广，最为流行的git工作流</p><p>或许会有一些小的出入，但是各大公司基本上内部都会遵守这样的规则</p><p>大小项目，大小团队，都适用gitflow工作流</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了作者了解到的三种常见的&lt;em&gt;单仓库&lt;/em&gt;的git工作流，它们是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Centralized工作流&lt;ul&gt;
&lt;li&gt;仅使用master一个分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Feature Branch工作流&lt;ul&gt;
&lt;li&gt;使用一个master分支管理稳定版本&lt;/li&gt;
&lt;li&gt;使用多个feature分支管理需求开发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Gitflow工作流&lt;ul&gt;
&lt;li&gt;使用一个master分支管理发布版本历史&lt;/li&gt;
&lt;li&gt;使用一个develop分支管理开发流程&lt;/li&gt;
&lt;li&gt;使用多个feature分支管理需求开发&lt;/li&gt;
&lt;li&gt;使用多个release分支管理版本发布&lt;/li&gt;
&lt;li&gt;使用多个hotfix分支修复紧急bug&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
    
      <category term="git" scheme="https://rivers-shall.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>defer+recover保护gin不panic</title>
    <link href="https://rivers-shall.github.io/2020/06/04/defer-recover%E4%BF%9D%E6%8A%A4gin%E4%B8%8Dpanic/"/>
    <id>https://rivers-shall.github.io/2020/06/04/defer-recover保护gin不panic/</id>
    <published>2020-06-04T10:33:59.000Z</published>
    <updated>2020-06-04T10:51:31.819Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者保护gin构建的web app不panic的方式，简单来说：</p><ol><li>主程中的panic本身是会被gin拦截的</li><li>协程中的panic需要使用<code>defer</code>和<code>recover</code>进行保护</li></ol><a id="more"></a><h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>在我们用gin构建，运行web app并上线了之后，或许有一些请求会经过业务，在特定的情况下出发会触发golang中的<code>panic</code></p><p>按照golang的设定，一旦<code>panic</code>，如果不在函数调用栈中存在<code>recover</code>，那么是一定会使得整个程序终止的</p><p>但是线上的服务是不能够因为一个两个的请求就直接终止了的，这样非常危险，所以我们需要手段来阻止web app在<code>panic</code>的情况下直接终止</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="主程序中的panic"><a href="#主程序中的panic" class="headerlink" title="主程序中的panic"></a>主程序中的<code>panic</code></h3><p>对于gin这个web框架来说，主程序中的<code>panic</code>是会被自动<code>recover</code>的，还会打印出非常详细的日志信息，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/panic"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后我们作如下HTTP请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl localhost:8080/panic</span><br></pre></td></tr></table></figure><p>会发现在gin的运行窗口出现如下信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">2020/06/04 18:42:12 [Recovery] 2020/06/04 - 18:42:12 panic recovered:</span><br><span class="line">GET /panic HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: curl/7.64.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">panic</span><br><span class="line">/Users/admin/go/src/gin-test/main.go:10 (0x1581418)</span><br><span class="line">        main.func1: panic(<span class="string">"panic"</span>)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/context.go:165 (0x156baca)</span><br><span class="line">        (*Context).Next: c.handlers[c.index](c)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/recovery.go:83 (0x157fb13)</span><br><span class="line">        RecoveryWithWriter.func1: c.Next()</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/context.go:165 (0x156baca)</span><br><span class="line">        (*Context).Next: c.handlers[c.index](c)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/logger.go:241 (0x157ec40)</span><br><span class="line">        LoggerWithConfig.func1: c.Next()</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/context.go:165 (0x156baca)</span><br><span class="line">        (*Context).Next: c.handlers[c.index](c)</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/gin.go:420 (0x1575d20)</span><br><span class="line">        (*Engine).handleHTTPRequest: c.Next()</span><br><span class="line">/Users/admin/go/src/github.com/gin-gonic/gin/gin.go:376 (0x157548c)</span><br><span class="line">        (*Engine).ServeHTTP: engine.handleHTTPRequest(c)</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/go/1.13.8/libexec/src/net/http/server.go:2802 (0x12cb6d3)</span><br><span class="line">        serverHandler.ServeHTTP: handler.ServeHTTP(rw, req)</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/go/1.13.8/libexec/src/net/http/server.go:1890 (0x12c6f74)</span><br><span class="line">        (*conn).serve: serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/go/1.13.8/libexec/src/runtime/asm_amd64.s:1357 (0x105c030)</span><br><span class="line">        goexit: BYTE    <span class="variable">$0x90</span>   // NOP</span><br><span class="line"></span><br><span class="line">[GIN] 2020/06/04 - 18:42:12 | 500 |    1.238546ms |             ::1 | GET      <span class="string">"/panic"</span></span><br></pre></td></tr></table></figure><p>并且整个app还在正常运行，没有终止，这非常好</p><h3 id="协程中的panic"><a href="#协程中的panic" class="headerlink" title="协程中的panic"></a>协程中的<code>panic</code></h3><p>不过非常可惜的是，对于协程中的<code>panic</code>，gin并不能做到自动<code>recover</code>并打印日志信息，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/go-panic"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该app之后，我们作如下的HTTP请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl localhost:8080/go-panic</span><br></pre></td></tr></table></figure><p>会发现gin app退出了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">panic: panic</span><br><span class="line"></span><br><span class="line">goroutine 24 [running]:</span><br><span class="line">main.main.func1.1()</span><br><span class="line">        /Users/admin/go/src/gin-test/main.go:11 +0x39</span><br><span class="line">created by main.main.func1</span><br><span class="line">        /Users/admin/go/src/gin-test/main.go:10 +0x35</span><br><span class="line"><span class="built_in">exit</span> status 2</span><br></pre></td></tr></table></figure><h4 id="协程解决方案"><a href="#协程解决方案" class="headerlink" title="协程解决方案"></a>协程解决方案</h4><p>所以，对于协程，我们要手动进行<code>defer</code>和<code>recover</code>，来避免app的退出和打印日志信息，比如上面的代码应该修改为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">"/go-panic"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    fmt.Printf(<span class="string">"error: %v\n"</span>, err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;()</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">"panic"</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后我们像刚才一样进行HTTP请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl localhost:8080/go-panic</span><br></pre></td></tr></table></figure><p>会得到如下打印</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: panic</span><br><span class="line">[GIN] 2020/06/04 - 18:50:20 | 200 |       2.951µs |             ::1 | GET      <span class="string">"/go-panic"</span></span><br></pre></td></tr></table></figure><p>可以看到app正常响应了请求，并且没有退出并打印了日志，想要更多定制操作可以修改<code>defer</code>的函数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者保护gin构建的web app不panic的方式，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主程中的panic本身是会被gin拦截的&lt;/li&gt;
&lt;li&gt;协程中的panic需要使用&lt;code&gt;defer&lt;/code&gt;和&lt;code&gt;recover&lt;/code&gt;进行保护&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="gin" scheme="https://rivers-shall.github.io/tags/gin/"/>
    
  </entry>
  
  <entry>
    <title>oop大作业总结与从中看到的未来计划</title>
    <link href="https://rivers-shall.github.io/2020/06/04/oop%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BB%8E%E4%B8%AD%E7%9C%8B%E5%88%B0%E7%9A%84%E6%9C%AA%E6%9D%A5%E8%AE%A1%E5%88%92/"/>
    <id>https://rivers-shall.github.io/2020/06/04/oop大作业总结与从中看到的未来计划/</id>
    <published>2020-06-04T03:12:09.000Z</published>
    <updated>2020-06-04T08:37:43.540Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是在我完成了oop大作业之后，重新审视自己的开发流程与系统设计的一点总结与展望，简单来说：</p><ol><li>这是个”154/“(一无是处)的项目</li><li>好在能够让我感受到一些努力的方向</li></ol><p>代码就不开源了，实在太差了，就在这里口嗨一下就好</p><a id="more"></a><h2 id="存在的问题与未来的计划"><a href="#存在的问题与未来的计划" class="headerlink" title="存在的问题与未来的计划"></a>存在的问题与未来的计划</h2><h3 id="前端问题"><a href="#前端问题" class="headerlink" title="前端问题"></a>前端问题</h3><ol><li>没有对界面做任何的优化</li><li>没有任何的自动化测试，没有任何的后端分离的测试</li><li>模块化做的很差</li></ol><h4 id="没有对界面做任何的优化"><a href="#没有对界面做任何的优化" class="headerlink" title="没有对界面做任何的优化"></a>没有对界面做任何的优化</h4><p>CSS，是前端三大件中，我认为最复杂的一件，重点在于，CSS并不能被称为一门”编程语言”，应该来说，它是一门”设计用语”，在大学计算机科学中接触到的训练，可以说对CSS的学习是没有任何帮助的，这就导致即便看了很多CSS相关的资料，到了要实现界面效果的时候，还是会出现无从下手的情况</p><p>这次的大作业中，我几乎没有涉及到任何的CSS，只有在数个<code>div</code>需要并列做出类似column的效果时，使用了<code>display: inline-block</code>这样的属性设置，其他的我也想不到什么了</p><p>虽然离提交还有两三个星期，这个时间拿来上手一下element-ui之类的高层库，也是可能优化界面的，但是我觉得简约也是一种特色吧，另外，布置大作业时，长度不到一页纸的需求文档，我也没有太大的兴趣做出一个炫酷的界面，简约的界面反而和这样简约的需求很配呢</p><h4 id="没有任何的自动化测试，没有任何的后端分离测试"><a href="#没有任何的自动化测试，没有任何的后端分离测试" class="headerlink" title="没有任何的自动化测试，没有任何的后端分离测试"></a>没有任何的自动化测试，没有任何的后端分离测试</h4><p>前端的开发流程中，当然会需要测试</p><p>而我这次开发，测试的手段就是把后端服务起来，然后把前端dev-server起来，在界面上点来点去</p><p>这样子的效率低到令人发指，还需要后端的配合：</p><ol><li>点来点去，人傻了都</li><li>如果几次操作之间记忆出现错误，很有可能上一回测到的路径，这次又没有测到</li><li>如果后端接口没有准备好，前端就没有办法测试</li></ol><h4 id="模块化做的很差"><a href="#模块化做的很差" class="headerlink" title="模块化做的很差"></a>模块化做的很差</h4><p>前端的模块化一直以来都是问题挺大的，说实在的设计类要做出非常好的模块化也有点尴尬，另外一方面没有使用高层框架，也会使得模块化更加困难</p><p>首先，vue中的各个模组就已经出现了类似的结构，但是我并没有很好地方法来模块化，做的也有点烦躁</p><p>其次，前端存储和请求发送没有能够很好的模块化，尤其是请求发送模块，完全耦合在了vue的代码里，前端存储模块由于使用的是vuex框架，模块性还好一些，但是由于使用上经验不足，在引入到vue中的时候，出现了一些可读性较差的冗余代码</p><h3 id="前端未来的计划"><a href="#前端未来的计划" class="headerlink" title="前端未来的计划"></a>前端未来的计划</h3><ol><li>basic knowledge + code snippet 学习界面设计</li><li>了解前端的测试方式方法</li><li>了解好的前端架构与模块化开发方式</li></ol><h4 id="basic-knowledge-code-snippet-学习界面设计"><a href="#basic-knowledge-code-snippet-学习界面设计" class="headerlink" title="basic knowledge + code snippet 学习界面设计"></a>basic knowledge + code snippet 学习界面设计</h4><p>如何学习界面的设计？如何用CSS+JS或者高层框架实现设计？这两个问题，每个人都有不同的答案</p><p>我的答案是: basic knowledge + code snippet</p><h5 id="basic-knowledge"><a href="#basic-knowledge" class="headerlink" title="basic knowledge"></a>basic knowledge</h5><p>这就是指对CSS+JS或者高层框架的基础知识要了解，不需要深入，只要能够做到，看到代码，不会感到一头雾水，而是明白，这个属性/样式作用在了哪里，至于效果如何，怎么配置，知道去那里可以查文档就行</p><h5 id="code-snippet"><a href="#code-snippet" class="headerlink" title="code snippet"></a>code snippet</h5><p>这个才是重头戏，毕竟设计类的，只要不是强要求，大部分都可以通过修改他人的设计，而后达到自己的目的</p><p>所以平时要多积累：</p><ol><li>页面经典的布局(导航栏，登录界面，展示界面等)与实现代码</li><li>特殊的交互逻辑(固定在顶部的导航栏，顶部页面滑动进度显示等)与实现代码</li></ol><p>到时候自己想要做炫酷的功能，就直接去code snippet库里找一找，改一改就好</p><h4 id="了解前端的测试方式与方法"><a href="#了解前端的测试方式与方法" class="headerlink" title="了解前端的测试方式与方法"></a>了解前端的测试方式与方法</h4><p>最重要的几个问题：</p><ol><li>如何自动化？<ul><li>如何模拟鼠标，键盘等的交互操作？</li><li>如何验证测试结果？</li><li>前端JS逻辑代码如何测试？如何单元测试？</li></ul></li><li>如何与后端分离？<ul><li>如何模拟(mock)后端接口？</li><li>怎样设计</li></ul></li></ol><h4 id="了解好的前端架构与模块化开发方式"><a href="#了解好的前端架构与模块化开发方式" class="headerlink" title="了解好的前端架构与模块化开发方式"></a>了解好的前端架构与模块化开发方式</h4><p>去看看好的开源项目，他们是</p><ol><li>如何联动使用vue，vuex，vue-router，axios的</li><li>如何将前端存储，请求发送包装成为独立的模块</li><li>如何包装前端框架中的各种模组</li><li>其他的优秀设计理念</li></ol><h3 id="后端的问题"><a href="#后端的问题" class="headerlink" title="后端的问题"></a>后端的问题</h3><ol><li>没有自动化测试</li><li>没有使用数据库事务</li><li>后端REST接口设计的不好</li></ol><h4 id="没有自动化测试"><a href="#没有自动化测试" class="headerlink" title="没有自动化测试"></a>没有自动化测试</h4><p>没有，真的没有，为了快速开发，测试代码为零</p><h4 id="没有使用数据库事务"><a href="#没有使用数据库事务" class="headerlink" title="没有使用数据库事务"></a>没有使用数据库事务</h4><p>这有需求文档的问题(其实大作业布置下来的要求根本没资格被称为需求文档，只能说是非常模糊的甲方需求，<del>啊！万恶的甲方</del>)</p><p>也有个人的问题，本身是有情景需要事务的，但是由于对技术栈不熟悉(JS的express.js+mongoose)，在尝试了几下之后，就放弃了，毕竟还要优先保证完成业务逻辑，现在想想实际上并不是很困难，完全可以做</p><h4 id="后端REST接口设计的不好"><a href="#后端REST接口设计的不好" class="headerlink" title="后端REST接口设计的不好"></a>后端REST接口设计的不好</h4><p>这个”不好”，指的是什么方面呢？</p><p>首先，后端接口在开发过程中还几经变迁，基本上是开发到哪算到哪，最终导致接口变来变去，同时REST的”面向资源的操作”特性不明显</p><p>特性不明显这一点倒感觉未必非常重要，但是几经变迁这件事槽点比较大</p><h3 id="后端未来的计划"><a href="#后端未来的计划" class="headerlink" title="后端未来的计划"></a>后端未来的计划</h3><ol><li>学会自动化测试</li><li>了解各类数据库的使用</li><li>学习各种后端接口的设计</li></ol><h4 id="学会自动化测试"><a href="#学会自动化测试" class="headerlink" title="学会自动化测试"></a>学会自动化测试</h4><ul><li>如何在框架内使用单元测试？</li><li>如何mock HTTP请求?(postman)</li><li>如何自动化mock HTTP请求并验证response？</li></ul><h4 id="了解各类数据库的使用"><a href="#了解各类数据库的使用" class="headerlink" title="了解各类数据库的使用"></a>了解各类数据库的使用</h4><ul><li>SQL与NoSQL</li><li>数据库事务</li><li>数据库底层的实现，各类锁</li></ul><h4 id="学习各种后端接口的设计"><a href="#学习各种后端接口的设计" class="headerlink" title="学习各种后端接口的设计"></a>学习各种后端接口的设计</h4><ul><li>REST风格</li><li>GraphQL接口设计</li><li>RPC调用接口设计</li></ul><h3 id="开发流程上的问题与计划"><a href="#开发流程上的问题与计划" class="headerlink" title="开发流程上的问题与计划"></a>开发流程上的问题与计划</h3><p>主要是文档和git的workflow</p><p>文档方面，要养成良好的习惯，多写点注释，使用文档，需求文档，接口文档，设计的优先级一定是要高于编码的</p><p>git的workflow，要采用master/dev/feature/hotfix的开发方式，保持主分支的干净</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的开发活动，需求不明确，开发者也缺少经验，同时缺少动力(既不能赚钱，也不是自己感兴趣的产品)，所以最终的成品是比较惨的</p><p>总的来说，需要多读，读开源项目的代码，多写，自己找到有兴趣的项目，做一些完整的，良好的开发活动</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是在我完成了oop大作业之后，重新审视自己的开发流程与系统设计的一点总结与展望，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这是个”154/“(一无是处)的项目&lt;/li&gt;
&lt;li&gt;好在能够让我感受到一些努力的方向&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码就不开源了，实在太差了，就在这里口嗨一下就好&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="https://rivers-shall.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>goland中Run与Debug里working-directory的含义</title>
    <link href="https://rivers-shall.github.io/2020/06/03/goland%E4%B8%ADRun%E4%B8%8EDebug%E9%87%8Cworking-directory%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>https://rivers-shall.github.io/2020/06/03/goland中Run与Debug里working-directory的含义/</id>
    <published>2020-06-03T12:15:43.000Z</published>
    <updated>2020-06-03T12:26:58.028Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者由于不了解goland中Run与Debug配置中working-directory含义而引起的bug，简单来说:</p><blockquote><p>working directory就是golang项目编译好后的二进制文件执行的文件夹路径</p></blockquote><h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>项目框架中存在<code>conf</code>这样的专门放置配置文件的文件夹，当使用项目框架自带的<code>build.sh</code>构建脚本时，会将编译好的二进制文件和<code>conf</code>中的配置文件分别拷贝到<code>output/bin</code>和<code>output/conf</code>这两个文件夹下，将<code>output</code>试做发布文件夹</p><p>但是，在goland中如果想要配置Run或者Debug，是不能使用<code>build.sh</code>脚本的，只能配置原始的go编译命令</p><p>在配置的同时，我将working-directory很随意地设置为了<code>output</code>文件夹</p><h2 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h2><p>当我修改了配置文件并进行Run或者Debug时，发现修改没有生效</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>没有生效是因为，working-directory被设置为<code>output</code>文件夹，那么goland在执行goland本身编译好的二进制文件时，会引用<code>output/conf</code>下的配置文件</p><p>但是，<code>conf</code>文件夹下的修改是不会自动同步到<code>output/conf</code>里的(对源代码的修改会同步到goland上，因为goland会重新编译)，必须执行<code>./build.sh</code>脚本才可以</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>可以每次修改配置文件是都先执行<code>./build.sh</code>，然后再goland使用Run或Debug</p><p>也可以将working-directory设置为<code>./</code>而不是设置为<code>./output</code>，这样以后goland编译执行引用的就是<code>./conf</code>中的配置文件，修改也就能直接同步了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文记录了作者由于不了解goland中Run与Debug配置中working-directory含义而引起的bug，简单来说:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;working directory就是golang项目编译好后的二进制文件执行的文件夹路径&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="goland" scheme="https://rivers-shall.github.io/tags/goland/"/>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/tags/basic-knowledge/"/>
    
  </entry>
  
  <entry>
    <title>bash中的字符串处理操作</title>
    <link href="https://rivers-shall.github.io/2020/06/02/bash%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/"/>
    <id>https://rivers-shall.github.io/2020/06/02/bash中的字符串处理操作/</id>
    <published>2020-06-02T06:35:42.000Z</published>
    <updated>2020-06-02T06:54:41.375Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用bash过程中，为了解决去除前缀后缀的问题而了解到的bash的字符串操作，简单来说</p><ol><li><code>string:position</code>或者<code>string:position:length</code>进行子串提取</li><li><code>string#pattern</code>进行最短匹配前缀去除，<code>string##pattern</code>进行最长匹配前缀去除</li><li><code>string%pattern</code>进行最短匹配后缀去除，<code>string%%pattern</code>进行最长匹配后缀去除</li><li><code>string/pattern/string</code>进行首个<code>pattern</code>替换，<code>string//pattern/string</code>进行全部<code>pattern</code>替换</li><li>以上的<code>pattern</code>指的都是<em>wildcard</em>而不是<em>regular expression</em></li></ol><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>有时在使用bash脚本的时候，希望对字符串做一些基本的操作，比如说去除前缀后缀（去除文件扩展名，统一前缀编号等），事实上，bash原生支持了许多字符串操作</p><h2 id="bash-中的字符串操作"><a href="#bash-中的字符串操作" class="headerlink" title="bash 中的字符串操作"></a>bash 中的字符串操作</h2><p><strong>下面所有的<code>pattern</code>指的都是bash wildcard而不是regular expression</strong></p><h3 id="子串提取"><a href="#子串提取" class="headerlink" title="子串提取"></a>子串提取</h3><p>使用<code>string:position</code>提取从<code>position</code>开始的子串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string:3&#125;</span></span><br><span class="line">t, dummy, text, dummy</span><br></pre></td></tr></table></figure><p>使用<code>string:position:length</code>提取从<code>position</code>开始，长度为<code>length</code>的子串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string:3:4&#125;</span></span><br><span class="line">t, d</span><br></pre></td></tr></table></figure><h3 id="前缀去除"><a href="#前缀去除" class="headerlink" title="前缀去除"></a>前缀去除</h3><p>使用<code>string#pattern</code>进行最短匹配前缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string#*text&#125;</span></span><br><span class="line">, dummy, text, dummy</span><br></pre></td></tr></table></figure><p>使用<code>string##pattern</code>进行最长匹配前缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string##*text&#125;</span></span><br><span class="line">, dummy</span><br></pre></td></tr></table></figure><h3 id="后缀去除"><a href="#后缀去除" class="headerlink" title="后缀去除"></a>后缀去除</h3><p>使用<code>string%pattern</code>进行最短匹配后缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string%dummy*&#125;</span></span><br><span class="line">text, dummy, text, y</span><br></pre></td></tr></table></figure><p>使用<code>string%%pattern</code>进行最长匹配后缀去除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string%%dummy*&#125;</span></span><br><span class="line">text,</span><br></pre></td></tr></table></figure><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>使用<code>string/pattern/string</code>进行首个<code>pattern</code>的替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string/text/TEXT&#125;</span></span><br><span class="line">TEXT, dummy, text, dummy</span><br></pre></td></tr></table></figure><p>使用<code>string//pattern/string</code>进行全部<code>pattern</code>的替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; string=<span class="string">"text, dummy, text, dummy"</span></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$&#123;string//text/TEXT&#125;</span></span><br><span class="line">TEXT, dummy, TEXT, dummy</span><br></pre></td></tr></table></figure><p>想要得到对正则表达式匹配替换的支持的话，可以使用<a href="https://man.linuxde.net/sed" target="_blank" rel="noopener">sed</a>命令</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用bash过程中，为了解决去除前缀后缀的问题而了解到的bash的字符串操作，简单来说&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;string:position&lt;/code&gt;或者&lt;code&gt;string:position:length&lt;/code&gt;进行子串提取&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string#pattern&lt;/code&gt;进行最短匹配前缀去除，&lt;code&gt;string##pattern&lt;/code&gt;进行最长匹配前缀去除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string%pattern&lt;/code&gt;进行最短匹配后缀去除，&lt;code&gt;string%%pattern&lt;/code&gt;进行最长匹配后缀去除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string/pattern/string&lt;/code&gt;进行首个&lt;code&gt;pattern&lt;/code&gt;替换，&lt;code&gt;string//pattern/string&lt;/code&gt;进行全部&lt;code&gt;pattern&lt;/code&gt;替换&lt;/li&gt;
&lt;li&gt;以上的&lt;code&gt;pattern&lt;/code&gt;指的都是&lt;em&gt;wildcard&lt;/em&gt;而不是&lt;em&gt;regular expression&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="bash" scheme="https://rivers-shall.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中箭头函数与普通函数</title>
    <link href="https://rivers-shall.github.io/2020/06/01/JavaScript%E4%B8%AD%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://rivers-shall.github.io/2020/06/01/JavaScript中箭头函数与普通函数/</id>
    <published>2020-06-01T12:26:38.000Z</published>
    <updated>2020-06-01T12:46:58.992Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用mongoose的过程中，因为箭头函数与普通函数的区别而引起的一个bug，以及因此而学会的有关箭头函数与普通函数的区别，简单来说：</p><ol><li>箭头函数不能使用<code>arguments</code>参数，普通函数可以</li><li>箭头函数的<code>this</code>关键字是lexically bound，也就是<code>this</code>是和<strong>最近的外层普通函数</strong>所具有的<code>this</code>一致(如果没有这样的函数，就和文件本身代表的对象绑定)；普通函数的<code>this</code>是dynamically bound，视运行时环境而确定</li></ol><p>其实还有什么<code>new</code>之类的，作者觉得不大重要，就算了</p><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在使用mongoose的过程中，需要对schema构造一个“虚字段”，参考实现中使用如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">itemSchema.virtual(<span class="string">"id"</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._id.toHexString();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我寻思着可以少写点东西，更精简一些，于是在我的实现里使用了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">itemSchema.virtual(<span class="string">"id"</span>).get(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._id.toHexString();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行时报错:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined 没有 toHexString 成员函数</span><br></pre></td></tr></table></figure><p>这才意识到，原来使用箭头函数的时候，<code>this</code>的绑定规则和普通函数不一致</p><h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f2(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这段代码<strong>在浏览器中</strong>，<code>f1</code>可以正常打印，<code>f2</code>会报<code>undefined</code>，当然，在node.js环境下，还会有些不同，可以自己试试</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">exports.mod = <span class="string">"mod"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">    f1() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = &#123;</span><br><span class="line">    f1 : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.f1()</span><br><span class="line">user2.f1()</span><br></pre></td></tr></table></figure><p>这段代码在node.js下，打印出如下结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; node test2.js</span><br><span class="line">&#123; f1: [Function: f1] &#125;</span><br><span class="line">&#123; mod: <span class="string">'mod'</span> &#125;</span><br></pre></td></tr></table></figure><p>可见，普通函数绑定的是运行时的对象，箭头函数绑定的是静态的编译时的对象</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用mongoose的过程中，因为箭头函数与普通函数的区别而引起的一个bug，以及因此而学会的有关箭头函数与普通函数的区别，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;箭头函数不能使用&lt;code&gt;arguments&lt;/code&gt;参数，普通函数可以&lt;/li&gt;
&lt;li&gt;箭头函数的&lt;code&gt;this&lt;/code&gt;关键字是lexically bound，也就是&lt;code&gt;this&lt;/code&gt;是和&lt;strong&gt;最近的外层普通函数&lt;/strong&gt;所具有的&lt;code&gt;this&lt;/code&gt;一致(如果没有这样的函数，就和文件本身代表的对象绑定)；普通函数的&lt;code&gt;this&lt;/code&gt;是dynamically bound，视运行时环境而确定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其实还有什么&lt;code&gt;new&lt;/code&gt;之类的，作者觉得不大重要，就算了&lt;/p&gt;
    
    </summary>
    
      <category term="basic knowledge" scheme="https://rivers-shall.github.io/categories/basic-knowledge/"/>
    
    
      <category term="JavaScript" scheme="https://rivers-shall.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>grep打印匹配行的未匹配内容</title>
    <link href="https://rivers-shall.github.io/2020/06/01/grep%E6%89%93%E5%8D%B0%E5%8C%B9%E9%85%8D%E8%A1%8C%E7%9A%84%E6%9C%AA%E5%8C%B9%E9%85%8D%E5%86%85%E5%AE%B9/"/>
    <id>https://rivers-shall.github.io/2020/06/01/grep打印匹配行的未匹配内容/</id>
    <published>2020-06-01T10:47:40.000Z</published>
    <updated>2020-06-01T12:06:53.634Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用<code>grep</code>和<code>sed</code>命令来实现，打印<code>grep</code>匹配行中的未匹配内容的功能的方法，简单来说：</p><ol><li>先使用<code>grep &lt;pattern&gt;</code>提取出匹配行</li><li>再使用<code>sed -e &#39;s/&lt;pattern&gt;//g&#39;</code>将匹配内容消除，即可得到未匹配内容</li></ol><a id="more"></a><h2 id="场景与方案"><a href="#场景与方案" class="headerlink" title="场景与方案"></a>场景与方案</h2><p>使用<code>grep</code>时，我们可以用<code>grep &lt;pattern&gt;</code>来打印出匹配行，可以使用<code>grep -o &lt;pattern&gt;</code>来打印出匹配行中的匹配内容，但是如果希望能够实现“反选”，也就是打印出匹配行中的费匹配内容，应该怎么做呢？</p><p>单纯的<code>grep</code>命令没有提供这种机制的支持，但是同时使用<code>grep</code>和<code>sed</code>命令就可以实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"matched not\nmat"</span> | grep <span class="string">"matched"</span> | sed <span class="string">"s/matched//g"</span></span><br><span class="line"> not</span><br></pre></td></tr></table></figure><p>首先，我们使用<code>grep &lt;pattern&gt;</code>打印出匹配行，而后，使用<code>sed &quot;s/&lt;pattern&gt;//g&quot;</code>将匹配行中的匹配内容替换为空字符串，就消除了匹配内容，留下了非匹配内容</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用&lt;code&gt;grep&lt;/code&gt;和&lt;code&gt;sed&lt;/code&gt;命令来实现，打印&lt;code&gt;grep&lt;/code&gt;匹配行中的未匹配内容的功能的方法，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先使用&lt;code&gt;grep &amp;lt;pattern&amp;gt;&lt;/code&gt;提取出匹配行&lt;/li&gt;
&lt;li&gt;再使用&lt;code&gt;sed -e &amp;#39;s/&amp;lt;pattern&amp;gt;//g&amp;#39;&lt;/code&gt;将匹配内容消除，即可得到未匹配内容&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://rivers-shall.github.io/tags/sed/"/>
    
      <category term="grep" scheme="https://rivers-shall.github.io/tags/grep/"/>
    
  </entry>
  
  <entry>
    <title>bash实现trim字符串</title>
    <link href="https://rivers-shall.github.io/2020/06/01/bash%E5%AE%9E%E7%8E%B0trim%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://rivers-shall.github.io/2020/06/01/bash实现trim字符串/</id>
    <published>2020-06-01T10:27:53.000Z</published>
    <updated>2020-06-01T10:43:55.574Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用<code>sed</code>命令对bash中的字符串进行去头尾空格的操作的方法，简单来说</p><ol><li>使用<code>echo &#39;  string  &#39; | sed -e &#39;s/^[[:space:]]*//&#39;</code>去除开头的空格</li><li>使用<code>echo &#39;  string  &#39; | sed -e &#39;s/[[:space:]]*$//&#39;</code>去除结尾的空格</li><li>将二者用管道结合，去除头尾空格<code>echo &#39;  string  &#39; | sed -e &#39;s/[[:space:]]*$//&#39; | sed -e &#39;s/^[[:space:]]*//&#39;</code></li></ol><a id="more"></a><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>去除头尾空格的字符串处理操作是非常常用的操作，在许多语言的标准库里都会以<code>trim</code>函数的方式提供出来</p><p>要在bash中实现这一功能，可以使用<code>sed</code>命令的替换子命令</p><p><code>sed -e &#39;s/^[[:space:]]*//&#39;</code>是指匹配所有行开头的空格并将其替换为空字符串</p><p><code>sed -e &#39;s/[[:space:]]*$//&#39;</code>是指匹配所有行结尾的空格并将其替换为空字符串</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用&lt;code&gt;sed&lt;/code&gt;命令对bash中的字符串进行去头尾空格的操作的方法，简单来说&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/^[[:space:]]*//&amp;#39;&lt;/code&gt;去除开头的空格&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/[[:space:]]*$//&amp;#39;&lt;/code&gt;去除结尾的空格&lt;/li&gt;
&lt;li&gt;将二者用管道结合，去除头尾空格&lt;code&gt;echo &amp;#39;  string  &amp;#39; | sed -e &amp;#39;s/[[:space:]]*$//&amp;#39; | sed -e &amp;#39;s/^[[:space:]]*//&amp;#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://rivers-shall.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>转义sed替换模式字符串</title>
    <link href="https://rivers-shall.github.io/2020/06/01/%E8%BD%AC%E4%B9%89sed%E6%9B%BF%E6%8D%A2%E6%A8%A1%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://rivers-shall.github.io/2020/06/01/转义sed替换模式字符串/</id>
    <published>2020-06-01T05:47:34.000Z</published>
    <updated>2020-06-01T10:43:41.406Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用<code>sed</code>命令进行文本替换时，对于使用到的替换模式进行转义处理使用到的<code>sed</code>命令，简单来说：</p><ul><li>使用<code>sed -e &#39;s/[]\/$*.^[]/\\&amp;/g&#39;</code>即可对输入字符串进行转义</li></ul><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><code>sed</code>命令常常被用来对文本做处理，其中一个最经常用到的处理就是替换，替换的语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$STRING</span> | sed -e <span class="string">'s/&lt;match_pattern&gt;/&lt;replace_pattern&gt;/g'</span></span><br></pre></td></tr></table></figure><p>当然也可以有其他的变化，不过这是作者使用的最多的方式。</p><p>在使用这些的时候，我们可能会在<code>match_pattern</code>和<code>replace_pattern</code>中引用变量，已达到分别管理和增强可读性的目的，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"ff"</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>但是，如果上面引用的<code>REPLACE</code>里面有特殊字符，我们就会遇到问题，比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"/a"</span></span><br><span class="line"><span class="comment"># 有问题</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>我们的本意是将<code>a</code>替换为<code>/a</code>，但是，使用这几条命令，会得到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed: 1: <span class="string">"s/a//a/g</span></span><br><span class="line"><span class="string">"</span>: bad flag <span class="keyword">in</span> substitute <span class="built_in">command</span>: <span class="string">'a'</span></span><br></pre></td></tr></table></figure><p>这里的原因就是<code>/a</code>中的<code>/</code>是一个特殊字符，如果希望得到我们上述的效果，应该这么操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"\/a"</span></span><br><span class="line"><span class="comment"># 成功</span></span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>我们通过<code>\/</code>进行转义，取得了成功，但是这种方式使得我们编写<code>replace_pattern</code>变得麻烦，而且很不直观，我们希望有一个函数来达到如下效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dummy text</span></span><br><span class="line">TEXT=<span class="string">"affaflns,fakfnakn"</span></span><br><span class="line">REPLACE=<span class="string">"/a"</span></span><br><span class="line">REPLACE=$(func <span class="variable">$REPLACE</span>)</span><br><span class="line">REPLACED_TEXT=$(<span class="built_in">echo</span> <span class="variable">$TEXT</span> | sed -e <span class="string">"s/a/<span class="variable">$REPLACE</span>/g"</span>)</span><br></pre></td></tr></table></figure><p>也就是说，编写<code>replace_pattern</code>时，可以直接编写，而后使用一个函数或者命令自动转义再使用</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><a href="https://stackoverflow.com/questions/407523/escape-a-string-for-a-sed-replace-pattern" target="_blank" rel="noopener">stackoverflow</a></p><p>使用<code>sed -e &#39;s/[]\/$*.^[]/\\&amp;/g&#39;</code>即可</p><h3 id="方案解析"><a href="#方案解析" class="headerlink" title="方案解析"></a>方案解析</h3><p>我们这次的方案就是对原生的<code>replace_pattern</code>做一次替换:</p><ul><li><code>match_pattern</code>为<code>[]\/$*.^[]</code><ul><li>这个正则表达式的结构很具有迷惑性，其实它是一个大的<em>bracket group</em></li><li>也就是说，实际上是<code>[</code> <code>]\/$*.^[</code> <code>]</code>的结构</li><li>意味着匹配<code>]\/$*.^[</code>中的任一字符</li></ul></li><li><code>replace_pattern</code>为<code>\\&amp;</code><ul><li>这个<code>replace_pattern</code>用到了一个转义字符和一个特殊字符</li><li>转义字符<code>\\</code>表示的就是<code>\</code></li><li>特殊字符<code>&amp;</code>表示的是<code>match_pattern</code>匹配到的内容</li></ul></li></ul><p>综合起来，这个替换语句就是把<code>]\/$*.^[</code>前面全部加上一个斜杠，进行转义</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用&lt;code&gt;sed&lt;/code&gt;命令进行文本替换时，对于使用到的替换模式进行转义处理使用到的&lt;code&gt;sed&lt;/code&gt;命令，简单来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;sed -e &amp;#39;s/[]\/$*.^[]/\\&amp;amp;/g&amp;#39;&lt;/code&gt;即可对输入字符串进行转义&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
      <category term="sed" scheme="https://rivers-shall.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>date命令的两种常用法</title>
    <link href="https://rivers-shall.github.io/2020/06/01/date%E5%91%BD%E4%BB%A4%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%B3%95/"/>
    <id>https://rivers-shall.github.io/2020/06/01/date命令的两种常用法/</id>
    <published>2020-06-01T03:17:25.000Z</published>
    <updated>2020-06-01T10:43:59.583Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在平时工作中经常用到的Linux命令<code>date</code>的两种常见使用方式，简单来说：</p><ol><li>打印当前时间，<code>date &quot;+&lt;output_format&gt;&quot;</code></li><li>将Unix时间戳转化为可读的日期+时间<code>date -r &lt;unix-timestamp&gt; &quot;+&lt;output_format&gt;&quot;</code></li></ol><a id="more"></a><h2 id="打印当前时间"><a href="#打印当前时间" class="headerlink" title="打印当前时间"></a>打印当前时间</h2><p>只需要使用<code>date &quot;+&lt;output_format&gt;&quot;</code>就可以打印当前时间，其中，<code>output_format</code>由正常字符和转义字符组成，转义字符用来打印当前的年，月，日等等</p><table><thead><tr><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td>%Y</td><td>年</td></tr><tr><td>%m</td><td>月</td></tr><tr><td>%d</td><td>日</td></tr><tr><td>%H</td><td>小时</td></tr><tr><td>%M</td><td>分钟</td></tr><tr><td>%S</td><td>秒</td></tr><tr><td>%s</td><td>时间戳</td></tr></tbody></table><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date <span class="string">"+%Y-%m-%d-%H-%M-%S"</span></span><br><span class="line">2020-06-01-11-24-39</span><br></pre></td></tr></table></figure><h2 id="将Unix时间戳转化为可读的日期-时间"><a href="#将Unix时间戳转化为可读的日期-时间" class="headerlink" title="将Unix时间戳转化为可读的日期+时间"></a>将Unix时间戳转化为可读的日期+时间</h2><p>使用<code>date -r &lt;unix-timestamp&gt; &quot;+&lt;output_format&gt;&quot;</code>即可完成转化，其中的<code>output_format</code>和上文中介绍的一样，<code>&lt;unix-timestamp</code>就是一个数字</p><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date -r 0 <span class="string">"+%Y-%m-%d-%H-%M-%S"</span></span><br><span class="line">1970-01-01-08-00-00</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在平时工作中经常用到的Linux命令&lt;code&gt;date&lt;/code&gt;的两种常见使用方式，简单来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打印当前时间，&lt;code&gt;date &amp;quot;+&amp;lt;output_format&amp;gt;&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将Unix时间戳转化为可读的日期+时间&lt;code&gt;date -r &amp;lt;unix-timestamp&amp;gt; &amp;quot;+&amp;lt;output_format&amp;gt;&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Linux" scheme="https://rivers-shall.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>git-status中文乱码问题</title>
    <link href="https://rivers-shall.github.io/2020/05/29/git-status%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://rivers-shall.github.io/2020/05/29/git-status中文乱码问题/</id>
    <published>2020-05-29T10:21:28.000Z</published>
    <updated>2020-06-01T10:43:31.134Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者解决<code>git status</code>命令中出现中文名乱码问题的方法，简单来说</p><blockquote><p>配置 core.quotepath 为 false 即可</p></blockquote><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>当我们的修改文件中出现中文文件名时，<code>git status</code>就会出现乱码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  project git:(master) ✗ git status -s</span><br><span class="line">?? <span class="string">"\344\270\255\346\226\207\346\226\207\344\273\266"</span></span><br></pre></td></tr></table></figure><p>这是由于Git默认会对ASCII以外的编码进行转义，只要将这个转义关掉，就可以恢复正常了，关掉的方式就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  project git:(master) ✗ git config core.quotepath <span class="literal">false</span></span><br><span class="line">➜  project git:(master) ✗ git status -s</span><br><span class="line">?? 中文文件</span><br></pre></td></tr></table></figure><p>当然，如果希望让这个设定在所有的Git本地仓库里都生效，可以加上<code>--global</code>选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  project git:(master) ✗ git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者解决&lt;code&gt;git status&lt;/code&gt;命令中出现中文名乱码问题的方法，简单来说&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置 core.quotepath 为 false 即可&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="git" scheme="https://rivers-shall.github.io/tags/git/"/>
    
      <category term="中文乱码" scheme="https://rivers-shall.github.io/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>golang抽取接口，依赖注入(依赖倒置)解决包引用关系</title>
    <link href="https://rivers-shall.github.io/2020/05/28/golang%E6%8A%BD%E5%8F%96%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE-%E8%A7%A3%E5%86%B3%E5%8C%85%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB/"/>
    <id>https://rivers-shall.github.io/2020/05/28/golang抽取接口，依赖注入-依赖倒置-解决包引用关系/</id>
    <published>2020-05-28T06:58:15.000Z</published>
    <updated>2020-06-09T08:16:14.109Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在golang开发中，通过抽取接口，依赖注入的方式，解决包与包之间的不合理引用关系。</p><p>总结来说：</p><blockquote><p>面向接口编程，并且golang中接口函数的参数最好是标准库的类型</p></blockquote><a id="more"></a><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>目前项目中有一个业务逻辑包<code>business_logic</code>，两个工具库包<code>pkg1</code>和<code>pkg2</code>，其中</p><ul><li><code>pkg1</code>是旧库，API不宜改动，<code>pkg2</code>是新库，尚未正式使用</li><li><code>business_logic</code>会使用<code>pkg1</code>和<code>pkg2</code></li><li><code>pkg1</code>内部要添加使用<code>pkg2</code>的逻辑</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg1/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"pkg2"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg2.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg2/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    param1 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">(s S)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// business_logic/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"pkg1"</span></span><br><span class="line">    <span class="string">"pkg2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg1.ExternalAPI()</span><br><span class="line">    pkg2.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就引起了一个问题：</p><blockquote><p><code>business_logic</code>其实引用了两次<code>pkg2</code>，一次是直接引用，一次是通过<code>pkg1</code>间接引用，将来在版本更迭中，很有可能会出现直接引用的版本和间接引用的版本不一致的情况，从而引起未知bug</p></blockquote><h2 id="解决尝试"><a href="#解决尝试" class="headerlink" title="解决尝试"></a>解决尝试</h2><p>如果不希望两次引用，那么最好的方式是消除<code>pkg1</code>对<code>pkg2</code>的引用，消除引用的方式是</p><ul><li><code>pkg1</code>抽象出一个接口，</li><li>让<code>pkg2</code>提供结构体，实现<code>pkg1</code>抽象出的接口</li></ul><p>这样，<code>pkg2</code>实际上就变成了<code>pkg1</code>的一个插件，只要在<code>business_logic</code>初始化的时候，将<code>pkg2</code>的插件注入到<code>pkg1</code>里去就行</p><p>但是这样的尝试失败了，我们先来看一下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg1/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"pkg2"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    ExternalAPI(s pkg2.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plugin Plugin</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> plugin != <span class="literal">nil</span> &#123;</span><br><span class="line">        plugin.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetPlugin</span><span class="params">(p Plugin)</span></span> &#123;</span><br><span class="line">    plugin = p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg2/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    param1 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Plugin)</span> <span class="title">ExternalAPI</span><span class="params">(s S)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">(s S)</span></span> &#123;</span><br><span class="line">    p := Plugin&#123;&#125;</span><br><span class="line">    p.ExternalAPI(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// business_logic/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"pkg1"</span></span><br><span class="line">    <span class="string">"pkg2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg1.SetPlugin(&amp;pkg2.Plugin&#123;&#125;)</span><br><span class="line">    pkg1.ExternalAPI()</span><br><span class="line">    pkg2.ExternalAPI(pkg2.S&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，<code>pkg1</code>对<code>pkg2</code>的引用仍旧存在，其原因在于抽取出来的接口函数中的参数是属于<code>pkg2</code>的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    ExternalAPI(s pkg2.S)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终解决方案"><a href="#最终解决方案" class="headerlink" title="最终解决方案"></a>最终解决方案</h2><p>由于<code>pkg2</code>是新库，所以我们决定更改它的接口，最终的代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg1/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">    ExternalAPI(param <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plugin Plugin</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> plugin != <span class="literal">nil</span> &#123;</span><br><span class="line">        plugin.ExternalAPI(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetPlugin</span><span class="params">(p Plugin)</span></span> &#123;</span><br><span class="line">    plugin = p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg2/main.go</span></span><br><span class="line"><span class="keyword">package</span> pkg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Plugin)</span> <span class="title">ExternalAPI</span><span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExternalAPI</span><span class="params">(s <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    p := Plugin&#123;&#125;</span><br><span class="line">    p.ExternalAPI(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// business_logic/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"pkg1"</span></span><br><span class="line">    <span class="string">"pkg2"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pkg1.SetPlugin(&amp;pkg2.Plugin&#123;&#125;)</span><br><span class="line">    pkg1.ExternalAPI()</span><br><span class="line">    pkg2.ExternalAPI(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这回彻底解决了<code>pkg1</code>引用<code>pkg2</code>的问题，代价就是将<code>pkg2.S</code>这个结构体参数展开了</p><p>视具体业务情况而定，我们可以通过：</p><ol><li>展开结构体</li><li>将结构体换做<code>map[string]interface{}</code>（当然需要手动做字段的提取和塞入）</li><li>将结构体换做<code>string</code>，用JSON传参（手动Marshal和Unmarshal）</li><li>将参数类型放到新的第三方库<code>pkg3</code>中（这样就又要维护引用的<code>pkg3</code>版本一致）</li></ol><p>软件开发中没有silver-bullet，只有trade-off，这次的方案，也还算满意</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在golang开发中，通过抽取接口，依赖注入的方式，解决包与包之间的不合理引用关系。&lt;/p&gt;
&lt;p&gt;总结来说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;面向接口编程，并且golang中接口函数的参数最好是标准库的类型&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>一个golang的RPC框架设计中的坑点</title>
    <link href="https://rivers-shall.github.io/2020/05/27/%E4%B8%80%E4%B8%AAgolang%E7%9A%84RPC%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%9D%91%E7%82%B9/"/>
    <id>https://rivers-shall.github.io/2020/05/27/一个golang的RPC框架设计中的坑点/</id>
    <published>2020-05-27T13:13:42.000Z</published>
    <updated>2020-06-01T10:45:39.404Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者在使用公司的RPC框架时，由于RPC框架本身的设计以及程序员的投机取巧而遇到的一个坑点。</p><p>简单来说，RPC框架没有能够做足够好的封装，程序员（不是作者，是前人）也没有按照RPC框架约定的方式进行API调用。</p><a id="more"></a><h2 id="背景提要"><a href="#背景提要" class="headerlink" title="背景提要"></a>背景提要</h2><p>我们知道，RPC调用是不同主机间的进程通信的方式，如果想要额外传递消息，我们往往需要修改RPC调用的接口，通过新增参数的方式来新增传递信息。</p><p>但是这样修改参数，修改接口的方式侵入性太强，需要进行上下游调用接口的适配，很麻烦。</p><p>当我们面对一些遍布在各个RPC服务的需求（也就是很多人喜欢提及的编程”切面”Aspect），比如这回我接到的日志系统的需求，将所有的接口都修改一遍，显然是不现实的。</p><p>在这里，golang的RPC框架可以通过传递<code>context.Context</code>来实现，也就是说，这些额外的，遍布各个RPC服务的消息，通过<code>context.Context</code>来传递。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc 上游调用时，传递一个`context.Context`和本来必要的下游rpc接口参数</span></span><br><span class="line">rpcClient.remoteMethod(ctx, request)</span><br><span class="line"></span><br><span class="line"><span class="comment">// rpc 下游接受请求时，接受一个`context.Context`和本来必要的接口参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">methodHandler</span><span class="params">(ctx context.Context, request MethodRequest)</span></span></span><br></pre></td></tr></table></figure><h3 id="类比HTTP解释"><a href="#类比HTTP解释" class="headerlink" title="类比HTTP解释"></a>类比HTTP解释</h3><p>上面提及的RPC调用传递<code>context.Context</code>和本来的接口参数，其实可以类比HTTP协议：</p><ul><li><code>context.Context</code> -&gt; HTTP Request Headers</li><li>接口参数 -&gt; HTTP Request Body</li></ul><p>二者都是传递信息的手段，但是接口参数和Request Body往往是明面上的写出来的主要业务逻辑需要的消息，<code>context.Context</code>和Request Headers往往是一些元数据(metadata)。</p><h2 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h2><p>这次的日志系统，需要我记录RPC运行时的动态调用链，也就是说，如果有一条RPC调用链路是</p><blockquote><p>RPC1 -&gt; RPC2 -&gt; RPC3</p></blockquote><p>那么实时的日志里，会有如下条目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RPC1:</span><br><span class="line">stack : []</span><br><span class="line"></span><br><span class="line">RPC2:</span><br><span class="line">stack : [RPC1]</span><br><span class="line"></span><br><span class="line">RPC3:</span><br><span class="line">stack : [RPC1, RPC2]</span><br></pre></td></tr></table></figure><h2 id="解决过程中遇到的问题"><a href="#解决过程中遇到的问题" class="headerlink" title="解决过程中遇到的问题"></a>解决过程中遇到的问题</h2><p>对于这个功能，我们发现RPC框架提供了三个接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向一个context.Context加入key-val键值对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInfo</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, val <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 获取上游通过<span class="title">AddInfo</span>传来的<span class="title">key</span>对应的<span class="title">val</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">GetUpstreamInfo</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 获取所有上游通过<span class="title">AddInfo</span>传来的键值对，组织成一个<span class="title">map</span>[<span class="title">string</span>][<span class="title">string</span>]</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">GetAllUpstreamInfo</span><span class="params">(ctx context.Context)</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span></span><br></pre></td></tr></table></figure><p>为此，我们的解决方案是，将<code>stack</code>做成<code>[]RPC</code>，其中<code>struct RPC</code>记录RPC的信息，通过JSON将<code>[]RPC</code>转化成<code>string</code>，而后用<code>context.Context</code>里的<code>&quot;stack&quot; - JSON([]RPC)</code>的键值对进行传递。</p><p>在我之前编码的程序员，没有遵守API调用规则，不使用<code>AddInfo</code>，而是使用的是如下方式进行<code>stack</code>的传递的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有的键值对</span></span><br><span class="line">m := util.GetAllUpstreamInfo(ctx)</span><br><span class="line"><span class="comment">// 取出stack并使用JSON解析</span></span><br><span class="line">stack, err := json.Unmarshal(m[<span class="string">"stack"</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加现有RPC调用</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, currentRPC)</span><br><span class="line"><span class="comment">// JOSN编码，更新ctx内的map</span></span><br><span class="line">m[<span class="string">"stack"</span>], err = json.Marshal(stack)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于golang中的map是引用传值，所以看上去这个代码已经成功更新了ctx内部的map，使用Goland-Debug查看ctx也会发现map已经修改了</p><p>但事实上程序并没有按照预期的方式进行工作</p><h3 id="排查原因"><a href="#排查原因" class="headerlink" title="排查原因"></a>排查原因</h3><p>仔细观察<code>AddInfo</code>函数的签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInfo</span><span class="params">(ctx context.Context, key <span class="keyword">string</span>, val <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span></span><br></pre></td></tr></table></figure><p>该函数返回了一个全新的Context，事实上<code>AddInfo</code>的逻辑是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">newCtx := AddInfo(ctx, <span class="string">"key"</span>, <span class="string">"val"</span>)</span><br><span class="line"></span><br><span class="line">+------------------------------+</span><br><span class="line">|          newCtx              |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |        ctx             | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|    K_KV -&gt;                   |</span><br><span class="line">| <span class="keyword">struct</span>&#123;key:<span class="string">"key"</span>,val:<span class="string">"val"</span>&#125;  |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><p>也就是说，新的Context在原来的Context上多加了一层，这一层的结构是</p><p><code>K_KV(RPC框架定义的一个字符串) -&gt; struct{key: &quot;key&quot;, val: &quot;val&quot;}</code></p><p>我们通过<code>newCtx.Value(&quot;key&quot;)</code>是拿不到任何东西的，只能通过<code>newCtx.Value(K_KV)</code>才能拿到完整的键值对</p><h4 id="这时，RPC框架有了一个骚操作"><a href="#这时，RPC框架有了一个骚操作" class="headerlink" title="这时，RPC框架有了一个骚操作"></a>这时，RPC框架有了一个骚操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPC1 ctx -------中间对ctx做了转化----------&gt; RPC2</span><br></pre></td></tr></table></figure><p>假设我们上游RPC1使用了如下<code>AddInfo</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">newCtx := AddInfo(ctx, <span class="string">"key"</span>, <span class="string">"val"</span>)</span><br><span class="line">newCtx2 := AddInfo(newCtx, <span class="string">"key2"</span>, <span class="string">"val2"</span>)</span><br><span class="line"></span><br><span class="line">+------------------------------+</span><br><span class="line">|          newCtx2             |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|   |      newCtx            | |</span><br><span class="line">|   |   +-------------+      | |</span><br><span class="line">|   |   |    ctx      |      | |</span><br><span class="line">|   |   +-------------+      | |</span><br><span class="line">|   | K_KV -&gt; <span class="keyword">struct</span>&#123;        | |</span><br><span class="line">|   |          key:<span class="string">"key"</span>     | |</span><br><span class="line">|   |          val:<span class="string">"val"</span>&#125;    | |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|  K_KV -&gt; <span class="keyword">struct</span>&#123;key:<span class="string">"key2"</span>,  |</span><br><span class="line">|                 val:<span class="string">"val2"</span>&#125;  |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><p>那么<code>newCtx2</code>就该如图示的那样，但是下游RPC2拿到的是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------+</span><br><span class="line">|          newCtx              |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   |        ctx             | |</span><br><span class="line">|   |                        | |</span><br><span class="line">|   +------------------------+ |</span><br><span class="line">|    K_UPSTREAM -&gt;             |</span><br><span class="line">|     <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;       |</span><br><span class="line">|           <span class="string">"key"</span> : <span class="string">"val"</span>,     |</span><br><span class="line">|           <span class="string">"key2"</span> : <span class="string">"val2"</span>    |</span><br><span class="line">|     &#125;                        |</span><br><span class="line">+------------------------------+</span><br></pre></td></tr></table></figure><p>所以，用于从Context取出键值对的索引从<code>K_KV</code>变为了<code>K_UPSTREAM</code>!!!</p><p>这意味着上游传来的消息最多只能保留一个RPC路径，所以我们必须使用<code>AddInfo</code>而不是直接写入map的方式来更新数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有的键值对</span></span><br><span class="line">m := util.GetAllUpstreamInfo(ctx)</span><br><span class="line"><span class="comment">// 取出stack并使用JSON解析</span></span><br><span class="line">stack, err := json.Unmarshal(m[<span class="string">"stack"</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加现有RPC调用</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, currentRPC)</span><br><span class="line"><span class="comment">// JOSN编码，更新ctx内的map</span></span><br><span class="line">jsonStack, err := json.Marshal(stack)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logError(...)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">ctx = util.AddInfo(ctx, <span class="string">"stack"</span>, jsonStack)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>框架底层的逻辑并不是很易懂，解释比较麻烦，一篇博文难以说明清楚，但是需要记住的是：</p><ol><li>使用框架，尽量使用框架的标准接口</li><li>框架封装的时候，如果有map这类可能会让人有hack欲望的，写明文档</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者在使用公司的RPC框架时，由于RPC框架本身的设计以及程序员的投机取巧而遇到的一个坑点。&lt;/p&gt;
&lt;p&gt;简单来说，RPC框架没有能够做足够好的封装，程序员（不是作者，是前人）也没有按照RPC框架约定的方式进行API调用。&lt;/p&gt;
    
    </summary>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="RPC" scheme="https://rivers-shall.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>编写自定义启动脚本时的注意项</title>
    <link href="https://rivers-shall.github.io/2020/05/27/%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E9%A1%B9/"/>
    <id>https://rivers-shall.github.io/2020/05/27/编写自定义启动脚本时的注意项/</id>
    <published>2020-05-27T13:12:04.000Z</published>
    <updated>2020-06-01T10:44:34.420Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章介绍了作者在使用和编写自定义启动脚本时感受到的一个需要注意的点，简单来说，就是：</p><blockquote><p>一定要打印出事实上的最终启动命令</p></blockquote><a id="more"></a><h2 id="自定义启动脚本的使用场景"><a href="#自定义启动脚本的使用场景" class="headerlink" title="自定义启动脚本的使用场景"></a>自定义启动脚本的使用场景</h2><p>我们知道，启动一个程序需要固定的命令，比如说</p><ul><li>C/C++/Go可以编译出一个可执行文件，<code>./app</code>来启动</li><li>Java通过JDK<code>java</code>命令启动，<code>java APP</code></li></ul><p>但是，管理大型项目时，未必会是简单的<code>./app</code>这样就可以启动的，我们有可能会需要传入许多选项和参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./<span class="built_in">exec</span> -option1 -option2 arg1</span><br><span class="line"></span><br><span class="line">./app -debug -entryPoint 3000</span><br></pre></td></tr></table></figure><p>而这些选项和参数又有可能依赖于更高级的输入，比如说配置文件，环境变量等等</p><p>这时，就是自动化启动脚本登场的时候了，通过从高层输入（比如文件，环境变量）抽取出选项和参数，最终自动形成启动命令</p><h2 id="自动化启动脚本导致的问题"><a href="#自动化启动脚本导致的问题" class="headerlink" title="自动化启动脚本导致的问题"></a>自动化启动脚本导致的问题</h2><p>在各大IDE中，想要使用Debug功能，需要提供的正是<strong>最终启动命令</strong>，也就是上文的<code>./app -debug -entryPoint 3000</code>这种</p><p>否则IDE无法调用调试器连接调试端口，也就无法实现单步调试，变量检查等功能了</p><p>但是要想从自动化脚本和当下的高层输入一起来推算出最终启动命令，可能是一件比较困难或者至少是麻烦的事情（复杂的自动化启动脚本可能本身就有上百行）</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在自动化脚本启动最终命令之前，将最终命令打印出来。</p><p>这样，我们就只需要执行一次自动化脚本，而后将打印出来的最终命令提供给IDE，就可以开启Debug模式了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章介绍了作者在使用和编写自定义启动脚本时感受到的一个需要注意的点，简单来说，就是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一定要打印出事实上的最终启动命令&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="good practice" scheme="https://rivers-shall.github.io/categories/good-practice/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue中为对象添加字段</title>
    <link href="https://rivers-shall.github.io/2020/05/27/Vue%E4%B8%AD%E4%B8%BA%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5/"/>
    <id>https://rivers-shall.github.io/2020/05/27/Vue中为对象添加字段/</id>
    <published>2020-05-27T13:09:18.000Z</published>
    <updated>2020-06-01T10:43:19.589Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录了作者使用Vue.js，并且在前端中为对象添加字段时遇到的坑点。</p><a id="more"></a><h2 id="场景与问题"><a href="#场景与问题" class="headerlink" title="场景与问题"></a>场景与问题</h2><p>从后端拿到数据之后，可能为了渲染时的方便，想要在对象里添加一些字段，而后直接在渲染时引用</p><p>直观上实现这种功能可以直接使用原生的js语法，抽象出来，可以用如下的代码段表示(为了复制就可以演示，没有组件化)</p><p>但是如下代码是有问题的，<code>obj.newField</code>不能被渲染出来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            &#123;&#123; obj.newField &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">            data : &#123;</span></span><br><span class="line"><span class="undefined">                obj : &#123;&#125;,</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            created() &#123;</span></span><br><span class="line"><span class="javascript">                obj.newField = <span class="string">"newData"</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正确的做法是使用<code>Vue.set</code>，因为在<a href="https://cn.vuejs.org/v2/api/#Vue-set" target="_blank" rel="noopener">Vue的官方文档</a>里有如下的表述</p><blockquote><p>因为 Vue 无法探测普通的新增 property (比如 this.myObject.newProperty = ‘hi’)</p></blockquote><p>所以上述代码应该改成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            &#123;&#123; obj.newField &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">"#app"</span>,</span></span><br><span class="line"><span class="undefined">            data : &#123;</span></span><br><span class="line"><span class="undefined">                obj : &#123;&#125;,</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            created() &#123;</span></span><br><span class="line"><span class="javascript">                Vue.set(obj, <span class="string">"newField"</span>, <span class="string">"newData"</span>)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录了作者使用Vue.js，并且在前端中为对象添加字段时遇到的坑点。&lt;/p&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Vue" scheme="https://rivers-shall.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>golang获取执行函数名，执行文件名与所在行数</title>
    <link href="https://rivers-shall.github.io/2020/05/27/golang%E8%8E%B7%E5%8F%96%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E5%90%8D%EF%BC%8C%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%8E%E6%89%80%E5%9C%A8%E8%A1%8C%E6%95%B0/"/>
    <id>https://rivers-shall.github.io/2020/05/27/golang获取执行函数名，执行文件名与所在行数/</id>
    <published>2020-05-27T01:19:50.000Z</published>
    <updated>2020-06-01T10:43:16.678Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章介绍了作者在参与一个golang日志系统的开发的时候，解决需要打印出执行<strong>日志打印操作</strong>时的<strong>业务函数名，业务文件名与所在行数</strong>的需求过程中，遇到的问题和解决方案</p><a id="more"></a><h2 id="需求场景"><a href="#需求场景" class="headerlink" title="需求场景"></a>需求场景</h2><p>在平日里使用日志的时候，一个好的日志系统，往往会打印出类似如下的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;log_level&gt;:&lt;log_message&gt;:&lt;package_path&gt;/&lt;filename&gt;:&lt;line_no&gt;:&lt;function_name&gt;</span><br><span class="line">比如</span><br><span class="line">INFO:connect to sql:/users/admin/home/go/src/io/rivers/demoProject/main.go:45:io.rivers.demoProject.testFunction</span><br></pre></td></tr></table></figure><p>这样子在打印出日志等级，日志消息的同时，输出业务逻辑所在的文件，行数，函数，对后期的bug排查，性能分析都有很大的帮助</p><p>那么，如何在golang中实现这一功能呢？</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>golang的runtime包提供了与之相应的函数接口，主要是<code>runtime.Caller</code>和<code>runtime.FuncForPC</code></p><p>先看一下二者的函数签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Caller</span><span class="params">(skip <span class="keyword">int</span>)</span> <span class="params">(pc <span class="keyword">uintptr</span>, file <span class="keyword">string</span>, line <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FuncForPC</span><span class="params">(pc <span class="keyword">uintptr</span>)</span> *<span class="title">Func</span></span></span><br></pre></td></tr></table></figure><p>单看函数签名就比较容易了解到:</p><ul><li><code>runtime.Caller</code>能够返回在函数栈中的PC(指令寄存器，可以认为存储了当前执行到了哪里)，所在的文件，所在文件的具体哪一行</li><li><code>runtime.FuncForPC</code>能够根据给定的指令寄存器给出其所在的行数</li></ul><p>其中<code>runtime.FuncForPC</code>的参数比较容易理解，就是指指令寄存器，但是<code>runtime.Caller</code>的参数需要解释一下</p><p>这里的<code>skip</code>指的是跳过多少个函数栈：</p><ul><li><code>skip == 0</code>，不跳过函数栈，返回当前函数PC，文件名，所在行</li><li><code>skip == 1</code>，跳过当前函数栈，返回上层调用者<strong>调用当前函数时的PC</strong>，文件名，所在行</li><li><code>skip == 2</code>，以此类推</li></ul><p>一般情况下这两个函数都是连在一起使用，如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取上层调用者PC，文件名，所在行</span></span><br><span class="line">pc, codePath, codeLine, ok := runtime.Caller(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> !ok&#123;</span><br><span class="line">    <span class="comment">// 不ok，函数栈用尽了</span></span><br><span class="line">    code = <span class="string">"-"</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> = "-"</span></span><br><span class="line"><span class="function">&#125; <span class="title">else</span></span> &#123;</span><br><span class="line">    <span class="comment">// 拼接文件名与所在行</span></span><br><span class="line">    code = fmt.Sprintf(<span class="string">"%s:%d"</span>, codePath, codeLine)</span><br><span class="line">    <span class="comment">// 根据PC获取函数名</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> = <span class="title">runtime</span>.<span class="title">FuncForPC</span><span class="params">(pc)</span>.<span class="title">Name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="实现重点与自动获取的优化"><a href="#实现重点与自动获取的优化" class="headerlink" title="实现重点与自动获取的优化"></a>实现重点与自动获取的优化</h2><p>可以看到，在我们使用<code>runtime.Caller</code>和<code>runtime.FuncForPC</code>这一组合击的时候，实际上的输入参数只有一个，那就是<code>runtime.Caller</code>的<code>skip</code>。</p><p>如何确定<code>skip</code>呢？在实践中，我一般使用两种方式：</p><ol><li>写死</li><li>尝试自动获取</li></ol><p>听起来第二种方法要比第一种方法好，但是事实上并不是这样的，在看完实现之后，大家就会明白了</p><h3 id="将skip写死"><a href="#将skip写死" class="headerlink" title="将skip写死"></a>将<code>skip</code>写死</h3><p>这种方式是比较常见的，通常适用于设计时确定了调用层数的情况，以日志系统为例，我们现在要提供一个接口<code>log</code>，那么我知道外界肯定是要直接调用<code>log</code>的，我最终要打印的就是调用<code>log</code>的函数的文件名，所在行，函数名</p><p>那么如果我是在<code>log</code>里使用<code>runtime.Caller</code>，那么我的<code>skip</code>就应该是<code>1</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(logLevel <span class="keyword">int</span>, logMessage <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    pc, file, line, ok := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我还做了封装，那么就要根据编写代码时的封装层数调整<code>skip</code>，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(logLevel <span class="keyword">int</span>, logMessage <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    logHelper(logLevel, logMessage)</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logHelper</span><span class="params">(logLevel <span class="keyword">int</span>, logMessage <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    logReal(logLevel, logMessage)</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logReal</span><span class="params">(logLevel <span class="keyword">int</span>, logMessage <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    pc, file, line, ok := runtime.Caller(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例中，由于多了两层封装，所以要把<code>skip</code>更改为3</p><h3 id="尝试自动获取"><a href="#尝试自动获取" class="headerlink" title="尝试自动获取"></a>尝试自动获取</h3><p>这次的尝试自动获取是我在编写日志系统时遇到的一个比较特殊的情况</p><p>在上面说的<a href="#将skip写死">#将skip写死</a>中，其实我们有一个重要的前提，那就是</p><blockquote><p>业务函数<strong>全部</strong>直接调用日志接口<code>log</code></p></blockquote><p>但是这次在开发日志系统时，遇到了这样的场景:</p><blockquote><p>日志拥有接口<code>log1</code>和<code>log2</code>，<code>log2</code>调用<code>log1</code>，业务代码既可能调用<code>log2</code>，也可能直接调用<code>log1</code><br><code>log1</code>下层调用<code>runtime.Caller</code>和<code>runtime.FuncForPC</code>组合</p></blockquote><p>这种情况下，<code>skip</code>是不可能写死在源代码里的，于是采取的解决方案如下</p><blockquote><p>由于日志系统在一个独立的包里，所以在<code>FuncForPC</code>将函数名取出来以后，判断是否是日志包中的函数，如果是，就增加<code>skip</code>的值</p></blockquote><p>实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> skip := <span class="number">1</span>; <span class="literal">true</span>; skip++ &#123;</span><br><span class="line">    pc, codePath, codeLine, ok := runtime.Caller(skip)</span><br><span class="line">    <span class="keyword">if</span> !ok&#123;</span><br><span class="line">        <span class="comment">// 不ok，函数栈用尽了</span></span><br><span class="line">        auto.Code = prevCode</span><br><span class="line">        auto.Func = prevFunc</span><br><span class="line">        <span class="keyword">return</span> auto</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        prevCode = fmt.Sprintf(<span class="string">"%s:%d"</span>, codePath, codeLine)</span><br><span class="line">        prevFunc = runtime.FuncForPC(pc).Name()</span><br><span class="line">        auto.Code = prevCode</span><br><span class="line">        auto.Func = prevFunc</span><br><span class="line">        <span class="keyword">if</span> !strings.Contains(prevFunc, <span class="string">"&lt;package_name&gt;"</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到包外的函数了</span></span><br><span class="line">            <span class="keyword">return</span> auto</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就算是一个能够解决问题的方案了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章介绍了作者在参与一个golang日志系统的开发的时候，解决需要打印出执行&lt;strong&gt;日志打印操作&lt;/strong&gt;时的&lt;strong&gt;业务函数名，业务文件名与所在行数&lt;/strong&gt;的需求过程中，遇到的问题和解决方案&lt;/p&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Vue+Axios自动更新</title>
    <link href="https://rivers-shall.github.io/2020/05/25/Vue-Axios%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0/"/>
    <id>https://rivers-shall.github.io/2020/05/25/Vue-Axios自动更新/</id>
    <published>2020-05-25T14:29:58.000Z</published>
    <updated>2020-06-01T10:43:06.047Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章记录了作者在使用Vue+Axios实现前端自动刷新数据时，遇到的一个坑点。</p><a id="more"></a><h2 id="场景需求"><a href="#场景需求" class="headerlink" title="场景需求"></a>场景需求</h2><p>在一个Vue单页应用中，使用VueRouter实现了App组件中点击链接后呈现Component组件的功能</p><p>App.Vue -&gt; Component.Vue</p><p>现在需要：在Component加载出来之后，每间隔1s的时间，自动通过Axios向后端接口获取数据并更新。</p><h2 id="有问题的实现方式"><a href="#有问题的实现方式" class="headerlink" title="有问题的实现方式"></a>有问题的实现方式</h2><p>App.Vue，内置router-link，可以跳转呈现Component</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// App.Vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;router-link :to=&quot;/Component&quot;&gt;Component&lt;/router-link&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>Component.Vue，在创建时，使用<code>setInterval</code>创建1s中的循环动作，在动作中使用Axios获取后端数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Component.Vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        // 设置一个间隔1s就进行的动作</span><br><span class="line">        setInterval(() =&gt; &#123;</span><br><span class="line">            Axios.get(&quot;/data&quot;).then((res) =&gt; &#123;</span><br><span class="line">                // 业务逻辑</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>出现问题的原因在于：</p><p><strong>只有<code>setInterval</code>，没有<code>clearInterval</code></strong></p><p>一个循环任务一旦被创建，就没有被销毁的可能，但是每次用户点击<code>Component</code>链接，都会创建<code>Component</code>实例，产生循环任务。</p><p>如果用户多次点击了<code>App.Vue</code>中的<code>Component</code>链接，那么就会在前端浏览器里产生多个循环任务，不断发送请求，最终导致前后端都不堪重负。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过<code>data</code>记录<code>created</code>中产生的循环任务，并在<code>beforeDestroy</code>里加入<code>clearInterval</code>清除它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Component.Vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            timer : &#123;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">        // 设置一个间隔1s就进行的动作</span><br><span class="line">        this.timer = setInterval(() =&gt; &#123;</span><br><span class="line">            Axios.get(&quot;/data&quot;).then((res) =&gt; &#123;</span><br><span class="line">                // 业务逻辑</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy() &#123;</span><br><span class="line">        clearInterval(this.timer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章记录了作者在使用Vue+Axios实现前端自动刷新数据时，遇到的一个坑点。&lt;/p&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="Vue" scheme="https://rivers-shall.github.io/tags/Vue/"/>
    
      <category term="Axios" scheme="https://rivers-shall.github.io/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>golang中使用elasticsearch</title>
    <link href="https://rivers-shall.github.io/2020/05/24/golang%E4%B8%AD%E4%BD%BF%E7%94%A8elasticsearch/"/>
    <id>https://rivers-shall.github.io/2020/05/24/golang中使用elasticsearch/</id>
    <published>2020-05-24T13:47:20.000Z</published>
    <updated>2020-06-01T10:42:50.444Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇介绍如何利用golang第三方库<a href="https://github.com/olivere/elastic" target="_blank" rel="noopener">https://github.com/olivere/elastic</a>进行elasticsearch的操作的文章。<br>文章中并不会介绍非常详细的API，更侧重于作者在工作中的使用经验和查文档经验。文章中主要包括以下内容：</p><ol><li>作者认为比较重要的API设计理念以及文档查阅方式</li><li>作者在工作中使用到的elasticsearch的实例，包括从接到需求，查阅文档，并实现的过程</li></ol><a id="more"></a><h2 id="API设计理念思考"><a href="#API设计理念思考" class="headerlink" title="API设计理念思考"></a>API设计理念思考</h2><h3 id="API的分类"><a href="#API的分类" class="headerlink" title="API的分类"></a>API的分类</h3><p>在使用elasticsearch的golang Client过程中，我觉得可以将olivere/elastic的常用API分作三类：</p><ol><li>面向elasticsearch的metadata的Service</li><li>面向elasticsearch的data的Service</li><li>面向Query</li></ol><p>而这三类分别对应了对elasticsearch的不同类别的操作：</p><ol><li>面向elasticsearch的metadata的Service，主要是对elasticsearch的metadata进行查询和操作，比如<ul><li>配置elasticsearch</li><li>查询elasticsearch的状态，比如集群状态，节点数目等</li></ul></li><li>面向elasticsearch的data的Service，住哟是对elasticsearch内的数据和数据格式进行操作<ol><li>elasticsearch中的index的metadata进行操作，比如<ol><li>查询是否存在某个index</li><li>创建并配置index</li></ol></li><li>elasticsearch中的index下的document的增删改操作</li></ol></li><li>面向Query，主要是对index下的document的查询操作</li></ol><h3 id="分类在代码中的体现"><a href="#分类在代码中的体现" class="headerlink" title="分类在代码中的体现"></a>分类在代码中的体现</h3><p>首先需要说明，在olivere/elastic的所有操作都是依靠生成一个<code>XXXService</code>对象然后<code>XXXService.Do(ctx)</code>来实现的，这里将他们分成面向Service和面向Query只是表示后者我们的主要精力都会集中在构造Query上</p><h4 id="面向elasticsearch的metadata的Service"><a href="#面向elasticsearch的metadata的Service" class="headerlink" title="面向elasticsearch的metadata的Service"></a>面向elasticsearch的metadata的Service</h4><p>面向elasticsearch的metadata的Service，一般是通过建立连接的ESClient，新建出查询或者操作所需的Service，而后进行操作的模式</p><p>比如如下，查询集群内es节点数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立连接的Client</span></span><br><span class="line">esClient, _ := elastic.NewClient()</span><br><span class="line"><span class="comment">// 新建出用于操作的Service</span></span><br><span class="line">clusterHealthClient := elastic.NewClusterHealthService(esClient)</span><br><span class="line"><span class="comment">// 查询，拿到结果</span></span><br><span class="line">result, _:= clusterHealthClient.Do(context.Background())</span><br><span class="line">fmt.Println(result.NumberOfNodes)</span><br></pre></td></tr></table></figure><h4 id="面向elasticsearch的data的Service"><a href="#面向elasticsearch的data的Service" class="headerlink" title="面向elasticsearch的data的Service"></a>面向elasticsearch的data的Service</h4><p>面向elasticsearch的data的Service，一般是通过建立连接的ESClient的成员函数直接取得Service，而后进行操作</p><p>比如如下，新建索引</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new index.</span></span><br><span class="line">mapping := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">    "settings":&#123;</span></span><br><span class="line"><span class="string">        "number_of_shards":1,</span></span><br><span class="line"><span class="string">        "number_of_replicas":0</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    "mappings":&#123;</span></span><br><span class="line"><span class="string">        "properties":&#123;</span></span><br><span class="line"><span class="string">            "tags":&#123;</span></span><br><span class="line"><span class="string">                "type":"keyword"</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            "location":&#123;</span></span><br><span class="line"><span class="string">                "type":"geo_point"</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            "suggest_field":&#123;</span></span><br><span class="line"><span class="string">                "type":"completion"</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">ctx := context.Background()</span><br><span class="line">createIndex, _ := esClient.CreateIndex(<span class="string">"twitter"</span>).BodyString(mapping).Do(ctx)</span><br><span class="line">fmt.Println(createIndex.Index)</span><br></pre></td></tr></table></figure><h4 id="面向Query"><a href="#面向Query" class="headerlink" title="面向Query"></a>面向Query</h4><p>面向Query，一般是先新建出Query，而后通过<code>client.Search().Index(index).Query(query).Do(ctx)</code>的方式执行查询操作</p><p>比如如下，查询上一个构造的索引中，<code>tags</code>字段含有<code>test</code>的document</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query := elastic.NewBoolQuery()</span><br><span class="line">query = query.Must(elastic.NewTermQuery(<span class="string">"tags"</span>, <span class="string">"test"</span>))</span><br><span class="line">result, _ := esClient.Search().Index(<span class="string">"twitter"</span>).Query(query).Do(context.Background())</span><br></pre></td></tr></table></figure><h2 id="API文档的查询方法"><a href="#API文档的查询方法" class="headerlink" title="API文档的查询方法"></a>API文档的查询方法</h2><p>查询olivere/elastic的文档，主要有三个来源：</p><ol><li>项目Wiki <a href="https://github.com/olivere/elastic/wiki" target="_blank" rel="noopener">https://github.com/olivere/elastic/wiki</a></li><li>源代码 <a href="https://github.com/olivere/elastic" target="_blank" rel="noopener">https://github.com/olivere/elastic</a></li><li>elasticsearch官方文档 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></li></ol><p>这三者各有特点：</p><ol><li>项目Wiki<ul><li>优点：简单直接，并且会给出相应的操作的示例代码，上手很快</li><li>缺点：示例较简单，且不全面，面对复杂逻辑/特定逻辑很可能缺乏指导性，或者找不到相关文档</li></ul></li><li>源代码<ul><li>优点：全面而且本质的东西，掌握了源代码就掌握了一切</li><li>缺点：复杂，费力，考虑投入产出比，几乎绝无必要源码级掌握(除非想成为库的开发者)</li></ul></li><li>elasticsearch官方文档<ul><li>优点：比较齐全的同时仍然是可读性较高的文档，难度在项目Wiki和源代码之间</li><li>缺点：没有直接对应到olivere/elastic的API上，找到elasticsearch的API之后，要回头再找olivere/elastic的API</li></ul></li></ol><p>一般的查询方式如下：</p><ol><li>首先明确需求，即到底需要获得elasticsearch的什么信息或者对其进行什么操作</li><li>明确需求后先查阅Wiki，如果有相应的条目，可用的就可以直接用了</li><li>Wiki中找不到，那就按照<a href="#api设计理念思考">api设计理念思考</a>中描述的进行分类</li><li>分类后有两条路径<ol><li>源代码中寻找对应的Service或者Query接口，找到后去elasticsearch文档验证</li><li>elasticsearch文档中寻找对应的查询接口，找到后去olivere/elastic中找对应的接口</li></ol></li></ol><p>当然，合理利用其他资源作为文档入口也是有必要的(或许这才是很多人的首选)：</p><ol><li>Stack Overflow，启动！</li><li>输入关键字查询，能找到合适的问答，就直接采用，不能就返回上述的一般查询方式</li></ol><h2 id="使用实例与解决过程"><a href="#使用实例与解决过程" class="headerlink" title="使用实例与解决过程"></a>使用实例与解决过程</h2><h3 id="查询集群的健康状态"><a href="#查询集群的健康状态" class="headerlink" title="查询集群的健康状态"></a>查询集群的健康状态</h3><p>过程：</p><ol><li>查阅Wiki，没有</li><li>查阅源代码，cluster为关键字查找，找到cluster_health.go，前往注释中指定的elasticsearch文档<a href="http://www.elastic.co/guide/en/elasticsearch/reference/7.0/cluster-health.html" target="_blank" rel="noopener">http://www.elastic.co/guide/en/elasticsearch/reference/7.0/cluster-health.html</a>验证想法</li><li>想法验证成功，编程</li></ol><h3 id="实现text类型的字段的模糊查找"><a href="#实现text类型的字段的模糊查找" class="headerlink" title="实现text类型的字段的模糊查找"></a>实现text类型的字段的模糊查找</h3><p>过程：</p><ol><li>查找Wiki，没有</li><li>源代码，elasticsearch文档没有“模糊查找”相关的部分</li><li>stack overflow 搜索 match part of text，找到使用正则表达式查询RegexQuery的方法</li><li>返回elasticsearch文档验证，验证成功</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇介绍如何利用golang第三方库&lt;a href=&quot;https://github.com/olivere/elastic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/olivere/elastic&lt;/a&gt;进行elasticsearch的操作的文章。&lt;br&gt;文章中并不会介绍非常详细的API，更侧重于作者在工作中的使用经验和查文档经验。文章中主要包括以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作者认为比较重要的API设计理念以及文档查阅方式&lt;/li&gt;
&lt;li&gt;作者在工作中使用到的elasticsearch的实例，包括从接到需求，查阅文档，并实现的过程&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="code snippet" scheme="https://rivers-shall.github.io/categories/code-snippet/"/>
    
    
      <category term="golang" scheme="https://rivers-shall.github.io/tags/golang/"/>
    
      <category term="elasticsearch" scheme="https://rivers-shall.github.io/tags/elasticsearch/"/>
    
  </entry>
  
</feed>
